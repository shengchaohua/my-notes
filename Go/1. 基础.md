[TOC]


# 0. 开始之前

## Golang和Java有什么区别？

1）面向对象

Java是面向对象的语言，有完整的继承体系，方便的实现多态的机制，能灵活的构造可重用性和易维护性的代码，并且通过OOP能简洁的实现反射机制。这些特性非常符合构造复杂的项目，但由于复杂性同时也导致编码的成本提升。

Go不是纯面向对象的、没有类的概念，而是通过组合和嵌入结构体的方式来实现继承，通过接口和**鸭子类型**的机制实现了多态。

2）错误处理

Java使用异常，提供了异常的捕获和处理机制。

Go 不使用异常，而是使用错误（error）来表示诸如文件结束之类的事件，并使用运行时恐慌(panic)来表示运行时错误，例如尝试索引数组越界。

3）并发性

Java语言上没有协成的概念，Java的线程模型依然用的**内核级线程模型**，多线程开发依然需要复杂的实现，而且实现方式有很多种。

Go 作为一种为现代多核计算机设计的语言，简单优雅的并发，并且具有强大的并发模型，其设计基于**两级线程模型改进的GMP模型**，这样能大大减少并发切换线程的性能开销，而且这些模型统一封装到语言级别的调度层，只需通过关键字 `go`就可以开启协成，提高了易用性。

4）垃圾回收

Java通常使用并发收集的垃圾回收机制，可能会存在长时间停止程序（Stop the world，STW）的情况。

Go 的主要功能之一是垃圾收集，尽管 Java 也有垃圾收集，但它并没有Go的那么快，虽然随着G1和ZGC的出现缩短了与Go的差距，但显然Go更擅长管理内存。它不包含引用链接，而是包含指针，而且Go的垃圾收集器经过大量优化以防止STW。整体上Go的垃圾收集方法更精细。

5）范型

Java的泛型通过类型擦除来实现，使一些代码更清晰，但是不支持泛型数组，并且具有上限和下限的类型通配符等，这让编码变得很复杂。而Go泛型没有Java的复杂，它有一些内置的泛型数据类型，比如，切片和map等，使用起来比较方便清晰易懂。

6）安全性

Java语言本身并不能保护你免受漏洞的侵害，但它的某些功能可以使您免受常见的安全漏洞的侵害。比如没有指针能避免一些未经授权的访问内存操作。其次Java有不同权限的访问修饰符，为每个应用程序创建不同级别的访问权限。从 Go 1.13 开始，go 命令默认使用 Go 模块镜像和 Go 校验和数据库下载和验证模块，语言层面内置安全策略。具体可查阅Go Module 镜像、索引和校验和数据库

7）编码的速度及容易性

Java自1995年以来一直存在，它还用于很多设备，而且由于它的向上兼容性，导致了很多功能本可以基于新的标准重新实现以提高性能，但恰恰因为兼容性让他放弃了这些，所以有很多功能效率依然是之前的标准编写的。

而Go是没这个问题的，因为它的库要比Java小的多，而且是按照现代的标准编写的，因此性能上更胜一筹。

由于Java的语法标准比较多样化，导致每个程序员写出来的Java代码都有不同的风格，而Go从设计之处就考虑到这一点，Go的代码更加的简洁和紧凑，它删除了不必要的括号和一些多余的符号，这也减少了出错的概率，更加的易于编写。

所以在编码速度和易用性上Go更胜一筹。

8）跨平台性

众所周知，Java是JVM平台的语言，一处编译处处运行，这个是Java引以为傲的优点，但它的运行时环境必须在JVM上，这就导致了Java运行时的臃肿，浪费了一部分资源。

而Go通过编译成可执行文件巧妙的解决了这个问题，虽然它不是跨平台性语言，但它在编码器层面依然可以实现一套代码编译出不同平台的执行文件，可以直接在各个平台上运行，而不用拖着一个像JVM一样的运行时环境。

Go运行时环境就是系统环境，而Java还需要一个虚拟机环境（JVM），所以在这一点上我觉得Go这种是比较好的。

### 优缺点总结

Go和Java的优缺点如下表：

|      | 优点                                                                                 | 缺点                                                  |
| ---- | ---------------------------------------------------------------------------------- | --------------------------------------------------- |
| Go   | 代码简洁性&#xA;静态类型可编译成机器码直接运行&#xA;天生多核并行&#xA;垃圾收集&#xA;跨平台且不依赖运行时环境&#xA;简洁的泛型&#xA;内置安全性 | 有限的库支持&#xA;泛型不够完善&#xA;灵活度没Java高(这个可算优点也可算缺点)        |
| Java | 优秀的文档&#xA;优秀的三方库&#xA;多线程&#xA;灵活性高&#xA;平台独立性&#xA;完善的语言特性&#xA;垃圾回收&#xA;JVM           | 垃圾回收效果不佳&#xA;大量冗余的陈旧实现导致性能不佳&#xA;代码的复杂性&#xA;复杂的继承机制 |

### 用途总结

没有一种语言适合所有的工作，但有些语言比其他语言更适合更多的工作。

Go 适合以下类型的应用程序：

-   **分布式网络服务**：Go 的内置并发特性，主要是 goroutine 和通道，非常适合开发一些网络服务。因此，许多 Go 项目用于网络、分布式功能和云服务：Web 服务器、API、应用框架、分布式存储服务等。
-   **云原生开发**：它的并发和网络能力，以及高度的移动性，使其适合构建云应用程序。事实上，Go 已被用于构建云计算的多个流行项目，包括Docker、Kubernetes和Istio等。
-   **区块链：** 由于Go有着非常好的性能，并且简洁的语法，现在它是区块链开发的首选语言。
-   **其他**：一些基础设施和独立的工具等，比如SSH服务器。

Java适合以下类型的应用程序：

-   **后端服务**：Java spring 有着完善的微服务体系，常用于后台服务的开发。
-   **Android应用**：尽管Kotlin已上升为Google的亲儿子，但他和Java很相似，都是JVM语言，而且Android的SDK依然是JAVA。
-   **大数据程序**：Hadoop 是用 Java 编写的。Scala、Kafka 和 Spark 都使用 JVM。此外，Java 使您可以访问许多经过验证的库、调试器和监控工具。
-   **金融项目**：作为金融行业最受欢迎的语言技能之一，Java 被用于服务器端和客户端来构建可靠、快速和简单的网站。它也是建模和数据模拟的首选语言。

# 1. 入门

## 1.1. 安装

> [https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md "https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md")
> [https://github.com/moovweb/gvm](https://github.com/moovweb/gvm "https://github.com/moovweb/gvm")

Go语言有多种安装方式，常见的安装方式包括：

-   Go标准包安装：Go提供了方便的安装包，支持Windows、Linux、Mac等系统。这种方式适合快速安装，可根据自己的系统位数下载好相应的安装包，一路 next 就可以轻松安装了。
-   第三方工具安装：目前有很多方便的第三方软件包工具，例如 Ubuntu 的 apt-ge t和 wget、Mac 的 homebrew 等。这种安装方式适合那些熟悉相应系统的用户。
-   Go源码安装：这是一种标准的软件安装方式。对于经常使用Unix类系统的用户，尤其对于开发者来说，从源码安装可以自己定制。

最后，如果你想在同一个系统中安装多个版本的Go，可以参考第三方工具GVM（https://github.com/moovweb/gvm）。

## 1.2. Hello World

代码如下：

```go
package main

import "fmt"

func main() {
  fmt.Println("hello world")
}
```

运行该程序的方法有两种：

1）使用`go run`命令直接运行：

```bash
# 在该文件的目录下
go run main.go

```

2）使用`go build`命令把该文件编译为二进制文件，然后运行编译出的文件即可

```bash
go build main.go # build binary
./main

# or
go build main.go && ./main
```

## 1.3. 输入输出

输入输出都使用内置的fmt包。

输出使用fmt.PrintXxx方法。

输入使用fmt.Scan方法。

## 1.4. 命令行参数

获取命令行参数有两种方法：

1）使用os.Args。第一个参数是文件名，之后的是命令行参数。这种方法的缺点很明显，无法指定命令行参数的名字。

```go
func main()  {
    fmt.Println("params count:",len(os.Args))
    for k, v:= range os.Args {
        fmt.Printf("args[%v]=[%v]\n",k,v)
    }
}

```

使用`go build`命令编译该文件，然后运行

```bash
$ ./main.go 1 2 3
params count: 4
args[0]=[./main]
args[1]=[1]
args[2]=[2]
args[3]=[3]
```

2）使用flag包，可以指定参数的名字。

```go
func main() {
  var username, password string
  flag.StringVar(&username, "u", "default_user", "username")
  flag.StringVar(&password, "p", "default_password", "password")
  flag.Parse()

  fmt.Println("username:", username)
  fmt.Println("password:", password)
}
```

编译文件后，尝试运行

```bash
$ ./main -u user -p password
username: user
password: password

$ ./main --u user --p password
username: user
password: password

$ ./main -u user
username: user
password: default_password
```

flag包还有默认的`-h`flag，返回帮助信息：

```bash
$ ./main -h                      
Usage of ./main:
  -p string
        password (default "default_password")
  -u string
        username (default "default_user")

```

# 2. 程序结构

## 2.1. 命名

Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

Go语言中类似if和switch的关键字有25个；关键字不能用于自定义名字，只能在特定语法结构中使用。

```go
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

此外，还有大约30多个预定义的名字，比如int和true等，主要对应内建的常量、类型和函数。

```go
内建常量: 
  true false iota nil

内建类型: 
  int int8 int16 int32 int64
  uint uint8 uint16 uint32 uint64 uintptr
  float32 float64 complex128 complex64
  bool byte rune string error

内建函数: 
  make len cap new append copy close delete
  complex real imag
  panic recover
```

这些内部预先定义的名字并不是关键字，可以在定义中重新使用它们，但是通常不会这么做。

如果一个名字是在函数内部定义，那么它就只在函数内部有效；如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。

名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的，也就是说可以被外部的包访问；如果是小写字母，那么它不可以被外部的包访问。

在习惯上，Go语言程序员推荐使用**驼峰式**命名，当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。

## 2.2. 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。

一个Go语言编写的程序对应一个或多个以go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。

Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。相比之下，在函数内部声明的名字就只能很小的范围被访问。

## 2.3. 变量

var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。变量声明的一般语法如下：

```go
var 变量名字 类型 = 初始化表达式
```

其中“类型”或“= 初始化表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。

```go
数值类型变量对应的零值是0
布尔类型变量对应的零值是false
字符串类型对应的零值是空字符串
接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil
数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值
```

零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。

```go
var a int
fmt.Println(a) // 0
var s string
fmt.Println(s) // ""
```

Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。

在一个声明语句，可以中同时声明一组变量，其中的变量只能是同一个类型；也可以用一组初始化表达式声明并初始化一组变量，其中变量的类型可以不同。

```go
var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string
```

另外，也可以直接使用表达式或函数调用来初始化一组变量。

```go
var a, b = 1 + 1, 1 + 2 
var f, err = os.Open(name) // os.Open returns a file and an error
```

在包级别声明的变量会在main入口函数执行前完成初始化，局部变量将在声明语句被执行到的时候完成初始化。

### 2.3.1. 简短变量声明

在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它根据表达式来自动推导变量的类型。

```go
名字 := 表达式 // 自动推导变量的类型
```

简短变量声明的要求是在该声明语句的词法域，至少要声明一个新的变量。

```go
i := 100 // an int
i := 200 // compile error: no new variables
```

和var形式的声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

```go
i, j := 0, 1
```

请记住`:=`是一个变量声明语句，而`=`是一个变量赋值操作。也不要混淆多个变量的声明和元组的多重赋值），后者是将右边各个表达式的值赋值给左边对应位置的各个变量：

```go
i, j = j, i // 交换 i 和 j 的值
```

和var形式的变量声明语句一样，简短变量声明语句也可以用函数的返回值来声明和初始化变量，像下面的`os.Open`函数调用将返回两个值：

```go
f, err := os.Open(name)
```

简短变量声明左边的变量可能并不是全部都是刚刚声明的。如果有一些变量已经在相同的词法域声明过了，那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。

```go
i, j := 0, 1 // i = 0, j = 1
i, k := 1, 2 // i = 1, k = 2
```

如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

### 2.3.2. 指针

当程序运行时，每一个变量都对应着一个内存地址（空间），该地址保存了该变量对应的类型和值。一个变量在声明语句创建时被绑定到一个变量名，通过该变量名可以读或更新对应的变量的值。

一个指针也是一个变量，但是保存了另一个变量的地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。

举例：

```go
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

说明：

-   对于一个x变量，`&x`表达式（取x变量的内存地址）将产生一个指向该整数变量的指针。指针对应的数据类型是`*int`，可以被称之为“int类型的指针”或“指向int类型的指针”。
-   如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时`*p`表达式对应p指针指向的变量的值，所以可以用`*p`表达式读取指针指向的变量的值。
-   因为`*p`对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。

任何类型的指针的零值都是nil。如果p指向某个有效变量，那么`p != nil`测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。

```go
var p = f()

func f() *int {
    v := 1
    return &v
}
// fmt.Println(f() == f()) // "false"
```

每次调用f函数都将返回不同的结果，因为指针指向了一个新的变量的地址。

每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。例如，`*p`就是变量v的别名。指针使我们可以不用知道一个变量的名字就可以访问该变量。

### 2.3.3. new函数

另一个创建变量的方法是调用内建的new函数。表达式`new(T)`将创建一个T类型的匿名变量，给该变量分配内存并初始化为T类型的零值，然后返回一个`*T`类型的指针指向该变量地址。

例如：

```go
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```

用 new 创建变量和普通变量声明语句方式创建变量没有什么区别。new函数类似是一种语法糖，而不是一个新的基础概念。

下面两个newInt函数有着相同的行为：

```go
func newInt() *int {
    return new(int)
}

func newInt() *int {
    var dummy int
    return &dummy
}
```

每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：

```go
p := new(int)
q := new(int)
fmt.Println(p == q) // "false"
```

new 函数使用通常相对比较少，直接用字面量语法创建新变量的方法会更灵活。

### 2.3.4. 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。

-   对于在包一级声明的变量，生命周期和整个程序的运行周期是一致的。
-   局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。

Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，所以一个局部变量的生命周期可能超出其所在的局部作用域。比如，一个定义在函数内部的局部变量可能在函数返回之后依然存在。

```go
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```

对于上面的代码，x变量在f函数返回后依然存在，而y变量在g函数返回后会被清除。这是因为

-   f函数返回后，x变量是可达的（可以通过包一级的global变量找到）。
-   g函数返回后，y变量是不可达的。

通常来说，局部作用域的变量都是在栈中分配内存。局部作用域结束后，栈所占据的内存会被自动释放。

> 栈内存一般用来给生命周期短的变量分配内存空间，比如函数调用内部的局部变量；相反，堆内存一般用来给生命周期长的变量分配内存空间。

但是，在Go语言中，编译器会自动选择在栈上还是在堆上给局部变量分配存储空间：

-   对于f函数，x变量必须在堆上分配，因为栈内存会在函数返回后自动释放。用Go语言的术语说，这个局部变量从函数f中逃逸了（逃逸的变量需要额外分配内存，可能会影响程序性能）。
-   对于g函数，当函数返回时，变量`*y`将是不可达的，是可以被回收的。因为`*y`并没有从函数g中逃逸，可以选择在栈上分配存储空间（当然也可以选择在堆上分配，之后通过GC回收存储空间）。

Go语言的自动垃圾收集器减轻了程序员的压力，不需要显式地分配和释放内存。但是，为了编写高效的程序，一定要了解变量的生命周期。例如，如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

## 2.4. 赋值

使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。

```go
x = 1                       // 命名变量的赋值
*p = true                   // 通过指针间接赋值
person.name = "bob"         // 结构体字段赋值
count[x] = count[x] * scale // 数组、slice或map的元素赋值
```

### 2.4.1. 元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

```go
var x, y = 1, 2
x, y = y, x // 交换x y

var i, j, k int
i, j, k = 2, 3, 5
```

注意，如果元组赋值右边的表达式太复杂的话，应该尽量避免过度使用元组赋值：因为对每个变量单独赋值的写法可读性会更好。

有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时，左边变量的数目必须和右边函数调用返回值的个数一致。比如，os.Open是用额外的返回值返回一个error类型的错误。

```go
f, err = os.Open("foo.txt") // Open returns two values
```

通常，这类函数会用额外的返回值来表达某种错误类型。还有一些是用来返回布尔值，通常被称为ok。比如，map查找、类型断言或通道接收出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功。

```go
v, ok = m[key] // map lookup
v, ok = x.(T)  // type assertion
v, ok = <-ch   // channel receive
```

和变量声明一样，我们可以用下划线空白标识符`_`来丢弃不需要的值。

```go
_, err = io.Copy(dst, src) // 丢弃字节数
_, ok = x.(T)              // 只检测类型，忽略具体值
```

### 2.4.2 可赋值性

赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。

> 在Go语言中，函数参数都是值传递。

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边得到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

可赋值性的规则对于不同类型有着不同要求。对于目前已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。

对于两个值是否可以用`==`或`!=`进行比较的能力也和可赋值性有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的。

## 2.5. 类型

变量或表达式的类型定义了对应存储值的属性特征，例如变量在内存中的存储大小和结构，关联的方法集等。

在Go语言中，创建一个新的类型是非常容易的。一个类型声明语句创建了一个新的类型名称，和对应的底层类型具有相同的结构。另外，也可以把新的类型名称为命名类型，或看作底层类型的类型别名。

```go
type 类型名字 底层类型
```

类型声明语句一般出现在包一级。如果新创建的类型名字的首字符大写，则在包外部也可以使用。

举例，

```go
import "fmt"

type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
```

Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以混在一个表达式运算或相互比较。区分类型的好处之一是可以避免一些使用不同单位的温度混合计算导致的错误。

使用Celsius(t)或Fahrenheit(t)形式的显式类型转换操作可以将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`）。

-   只有当两个类型的底层基础类型相同时，或者是两者都是指向相同底层结构的指针类型，才允许这种转型操作。
-   类型转换只改变类型，而不会影响值本身。
-   如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型。

底层类型决定了数据的内部结构和表达方式，也决定了新的类型是否像底层类型一样支持内置运算符。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型是一样的。

例如，

```go
fmt.Printf("%g\n", BoilingC-FreezingC) // "100" °C
boilingF := CToF(BoilingC)
fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
fmt.Printf("%g\n", boilingF-FreezingC)       // compile error: type mismatch

var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // "true"
fmt.Println(f >= 0)          // "true"
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"!
```

注意最后那个语句。尽管看起来像函数调用，但是`Celsius(f)`是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。测试为真的原因是因为c和f都是零值。

命名类型还可以为该类型定义新的行为（方法）。这些行为表示为一组关联到该类型的函数集合，称为类型的方法集。

例如，

```go
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
```

许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印。

## 2.6. 包和文件

Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。

一个包的源代码保存在一个或多个以`.go`为文件后缀名的源文件中，每个源文件都是以完全相同的包的声明语句开始，用来指明包的名字。包名一般是短小的名字，而且并不要求包名是全局唯一的。

对于包级别的名字，例如在一个文件中声明的类型和常量，同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。

包还可以控制哪些名字是外部可见的，来隐藏内部的实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。

每个包都对应一个独立的名字空间，不同空间可能存在相同名字的变量或方法。所以，如果要在外部引用一个包的导出成员，必须显式使用`pkgName.Name`的形式访问。例如，内置的image包和unicode/utf16包都定义了一个Decode函数。要在外部引用这两个函数，需要使用image.Decode或utf16.Decode的形式访问。

在每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。

### 2.6.1. 导入包

在Go语言中，每个包都有一个全局唯一的导入路径。Go语言规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。

导入包使用import导入语句，例如：

```go
import "fmt" 
```

导入语句可以把导入的包绑定到一个短小的名字，然后通过该名字就可以引用包中的可导出内容。默认情况下，导入的包会绑定到包名上。因为包名没有要求全局唯一，所以如果两个具有相同名字的包在同一个包中被导入时，就会产生名字冲突。此时，需要在导入包时绑定到一个不同的名称。

> 注意：在一个项目中，当同一个包在不同的地方被导入时，最好绑定到相同的名称。

如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。这种强制规则可以有效减少不必要的依赖。在这种情况下，我们需要将不必要的导入删除或注释掉。如果一个包需要被导入但不会被使用，可以在导入时绑定到`_`名称上。

### 2.6.2. 包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：

```go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```

如果包中含有多个`.go`源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将`.go`文件根据文件名排序，然后依次调用编译器编译。

如果一个包中的初始化操作稍微复杂，可以用init初始化函数来简化初始化工作。init函数是一个特殊函数，每个文件都可以包含多个init函数。

```go
func init() { /* ... */ }
```

这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。

初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。

总结，对于一个go项目，初始化的顺序大致为import –> const –> var –>init函数–>main函数。

## 2.7. 作用域

> [https://gopl-zh.github.io/ch2/ch2-07.html](https://gopl-zh.github.io/ch2/ch2-07.html "https://gopl-zh.github.io/ch2/ch2-07.html")

一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。

不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。



# 3. 基础数据类型

虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数，如整数、浮点数、比特数组、内存地址等。Go语言提供了丰富的数据组织形式，这依赖于Go语言内置的数据类型。这些内置的数据类型，兼顾了硬件的特性和表达复杂数据结构的便捷性。

Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

-   基础类型，包括数字、字符串和布尔型等。
-   复合类型，包括数组和结构体，是通过组合简单类型，来表达更加复杂的数据结构。
-   引用类型，包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。
-   接口类型，是一种特殊的空类型，Golang中所有类型都实现了接口类型。

Go语言内置以下基础数据类型：

| 类型           | 名称 | 长度  | 零值    | 说明                      |
| ------------ | -- | --- | ----- | ----------------------- |
| bool         | 布尔 | 1   | false |                         |
| byte         | 字节 | 1   | 0     |                         |
| rune         |    | 4   | 0     |                         |
| int,uint     |    | 4或8 | 0     |                         |
| int8,uint8   |    | 1   | 0     |                         |
| int16,uint16 |    | 2   | 0     |                         |
| int32,uint32 |    | 4   | 0     |                         |
| int64,uint64 |    | 8   | 0     |                         |
| float32      |    | 4   | 0.0   |                         |
| float64      |    | 8   | 0.0   |                         |
| complex64    |    | 8   |       |                         |
| complex128   |    | 16  |       |                         |
| uintptr      |    | 4或8 |       | 足以存储一个指针的uint3或uint64整数 |
| string       |    |     | ""    | UTF-8字符串                |

## 3.1. 布尔

一个布尔类型的值只有两种：true和false。if和for语句的条件部分都是布尔类型的值，并且`==`和`<`等比较操作也会产生布尔型的值。一元操作符`!`对应逻辑非操作，因此`!true`的值为`false`。

布尔值可以和`&&`（AND）和`||`（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值。因此，下面的表达式总是安全的：

```go
s != "" && s[0] == 'x'
```

其中s\[0]操作如果应用于空字符串将会导致panic异常。

## 3.2. 整型

Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。

这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint；其中int是应用最广泛的数值类型。这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设；因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。

Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。

```go
type rune int32
```

字节byte类型也是uint8类型的等价类型。byte类型一般用于强调数值是一个原始的数据，而不是一个小的整数。

```go
type byte uint8
```

最后，还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。

其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从-2^n-1到2^(n-1)-1。无符号整数的所有bit位都用于表示非负数，值域是0到2^n-1。例如，int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。

## 3.3. 浮点数

Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。

这些浮点数类型的取值范围可以从很微小到很巨大。浮点数的范围极限值可以在math包找到。常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。

一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）：

```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

浮点数的字面值可以直接写小数部分。小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分。

用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。

math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。

## 3.4. 复数

Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```

如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0。

在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：

```go
x := 1 + 2i
y := 3 + 4i
```

复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。

## 3.5. 字符和字符串

一般来说，字符就是一个字符，而字符串是一个连续的字符序列。在Go语言中，声明一个字符变量使用单引号包围一个有效的字符，而声明一个字符串变量使用双引号包围一个连续的字符序列。

```go
c := 'c'
fmt.Printf("%T\n", c) // int32
s := "string"
fmt.Printf("%T\n", c) // string
```

需要注意的是，字符的类型是int32，而字符串的类型是string。

在Go语言中，一个字符串是采用UTF8编码的rune序列（rune本质上是int32类型，用来表示一个Unicode码点）。字符串可以包含任意的数据，包括byte值0，但通常是人类可读的文本。

对于一个字符串，内置的len函数可以返回字符串中的**字节数目**（不是rune字符数目），索引操作s\[i]返回**第i个字节的字节值**，i必须满足0 ≤ i< len(s)条件约束。第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。

```go
s := "hello, world"
fmt.Println(len(s))     // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')

c := s[len(s)] // panic: index out of range
```

字符串支持切片操作。子字符串操作`s[i:j]`基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串，新字符串将包含j-i个字节。如果索引超出字符串范围或者j小于i的话将导致panic异常。另外，不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。

```go
fmt.Println(s[0:5])        // "hello"
fmt.Println(s[0:len(s)])   // "hello, world"
fmt.Println(s[0:len(s)+1]) // panic: index out of range

fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:])  // "hello, world"
```

字符串支持`+`操作符，可以把两个字符串连接构造一个新字符串。

字符串可以用`==`和`<`进行比较：逐个字节比较。因此。字符串比较的结果是字符串自然编码的顺序。

字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。

![](https://gopl-zh.github.io/images/ch3-04.png)

不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。 图3.4演示了一个字符串和两个子串共享相同的底层数据。

### 3.5.1. 字符串字面值

字符串一般用字面值方式编写，只要将一系列可见的字符包含在双引号内即可：

```go
s := "hello, world"
```

另外，字符串字面值也可以包含Unicode码点。比如，以反斜杠`\`开头的转义序列在字符串字面值中插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：

```go
\a      响铃
\b      退格
\f      换页
\n      换行
\r      回车
\t      制表符
\v      垂直制表符
\'      单引号（只用在 '\'' 形式的rune符号面值中）
\"      双引号（只用在 "..." 形式的字符串面值中）
\\      反斜杠
```

举例：

```go
s := "hello,\nworld"
fmt.Println(s)
```

Go语言可以通过十六进制或八进制转义在字符串面值中包含任意的字节。一个十六进制的转义形式是`\xhh`，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是`\ooo`，包含三个八进制的o数字（0到7），但是不能超过`\377`（对应一个字节的范围，十进制为255）。

举例：

```go
s := "hello, world\x21"
fmt.Println(s) // hello, world!
s2 := "hello, world\041"
fmt.Println(s2) // hello, world!
```

字符串字面值还有一种特殊形式：原生字符串，是使用反引号"`"包围的文本字符串序列。在原生字符串中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。

举例，

```go
s := `hello,\nworld`
fmt.Println(s)
```

注意：在原生字符串内部无法直接写"`"字符，需要用八进制或十六进制转义或+连接字符串常量完成。

原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。

### 3.5.2. Unicode

在很久以前，计算机世界只有一个字符集：美国信息交换标准代码ASCII。ASCII字符集使用7bit来表示128个字符：包含英文字母的大小写、数字、各种标点符号和设备控制符。

随着互联网的发展，混合多种语言的数据变得很常见（比如中文、日文等多种语言字符）。如何有效处理这些包含了各种语言的丰富多样的文本数据呢？答案就是使用Unicode（ [http://unicode.org](http://unicode.org "http://unicode.org") ），它收集了这个世界上所有的符号系统，包括各种不同的符号以及文字，每个符号都分配一个唯一的Unicode码点。在第八版的Unicode标准里收集了超过120,000个字符，涵盖超过100多种语言。

> Unicode码点（code point），即一个字符在Unicode编码中的编号。每个编号占32个bit。

在Go语言中，一个字符的Unicode码点可以用rune类型（底层类型是int32）来表示。所以，一个字符串可以认为是Unicode码点的序列。

例如，一个字符串可以转为一个rune类型（或int32）的Unicode码点序列。

```go
s := "hello, world"
r := []rune(s)
fmt.Println(r) // [104 101 108 108 111 44 32 119 111 114 108 100]

s2 := "hello, 世界"
r2 := []rune(s2)
fmt.Println(r2) // [104 101 108 108 111 44 32 19990 30028]
```

这种编码格式叫UTF-32或UCS-4，即每个字符的Unicode码点都使用同样大小的32bit来表示。也就是说，字符串中的每个字符都会占用4个字节。

**需要注意的是，Go语言并没有使用这种编码方式**。虽然这种编码方式比较简单，但是它会浪费很多存储空间，因为大多数计算机可读的文本是ASCII字符，而每个ASCII字符本来只需要8bit或1字节就能表示。

### 3.5.3. UTF-8

UTF8是一个将Unicode码点编码为字节序列的变长编码格式。UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。

UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。如果第一个字节的高端bit是110/1110/11110，则说明需要2/3/4个字节；后续的每个高端bit都以10开头。

```go
0xxxxxxx                             runes 0-127    (ASCII)
110xxxxx 10xxxxxx                    128-2047       (values <128 unused)
1110xxxx 10xxxxxx 10xxxxxx           2048-65535     (values <2048 unused)
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  65536-0x10ffff (other values unused)
```

变长的编码无法直接通过索引来访问第n个字符（因为字符串的索引操作返回字节值），但是UTF8编码获得了很多额外的优点。

-   UTF8编码比较紧凑，完全兼容ASCII码；效率高，通过向前回朔最多3个字节就能确定当前字符编码的开始字节的位置。
-   UTF8是前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看。没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。
-   UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列。
-   UTF8没有嵌入的NUL(0)字节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言。

Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字、字母的大小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能。

有很多Unicode字符很难直接从键盘输入，有一些甚至是不可见的字符。在Go语言中，可以使用转义字符和Unicode码点在字符串中包含任意的字符（通常是用于特殊字符）。转义字符有三种形式：`\xhh`对应小于128的码点值（即ASCII表中的字符），`\uhhhh`对应16bit的码点值，`\Uhhhhhhhh`对应32bit的码点值，其中h是一个十六进制数字。

例如，字符串`A`和`世`的Unicode转译格式。

```go
a := "A"
a2 := "\x41"
a3 := "\u0041"
a4 := "\U00000041"

s := "世"
s2 := "\u4e16"
s3 := "\U00004e16"
s4 := "\xe4\xb8\x96" // "世"占3个字节，每个字节的十六进制表示
```

另外，Unicode转义也可以使用在rune字符中。例如，字符`A`和`世`的Unicode转译格式。

```go
a := 'A'
a2 := '\x41' // \x00 - \xff
a3 := '\u0041'
a4 := '\U00000041'

s := '世'
s2 := '\u4e16'
s3 := '\U00004e16' 
// s4 := '\xe4\xb8\x96' // not allowed
```

对于一个字符，如果其码点值大于256（一个字节可以表示的范围为0-255），则必须使用`\u`或`\U`转义形式。因此，`\xe4\xb8\x96`并不是一个合法的rune字符，虽然这三个字节对应着“世“的Unicode码点。

得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀：

```go
func HasPrefix(s, prefix string) bool {
    return len(s) >= len(prefix) && s[:len(prefix)] == prefix
}
```

或者是后缀测试：

```go
func HasSuffix(s, suffix string) bool {
    return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}
```

或者是包含子串测试：

```go
func Contains(s, substr string) bool {
    for i := 0; i < len(s); i++ {
        if HasPrefix(s[i:], substr) {
            return true
        }
    }
    return false
}

```

对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。但是对应很多其它编码则并不是这样的。

如果我们真的关心每个Unicode字符，我们可以使用其它处理方式。举例，对于字符串`Hello, 世界`，它包含了中文和英文两种一共9个Unicode字符。

![image_XZN9AxaZEV](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311252028323.png)

图3.5展示了它的内存表示形式。因为Go语言使用UTF8编码格式，所以该字符串的存储为13个字节。

```go
import "unicode/utf8"

s := "Hello, 世界"
fmt.Println(len(s))                    // "13"
fmt.Println(utf8.RuneCountInString(s)) // "9"
```

为了处理这些字符，我们需要一个UTF8解码器。unicode/utf8包提供了该功能，我们可以这样使用：

```go
for i := 0; i < len(s); {
    r, size := utf8.DecodeRuneInString(s[i:])
    fmt.Printf("%d\t%c\n", i, r)
    i += size
}

// output
0  H
1  e
2  l
3  l
4  o
5  ,
6   
7  世
10  界
```

每一次调用`DecodeRuneInString`函数都返回一个字符r和长度size，其中长度size对应r采用UTF8编码后的编码字节数目。长度用于更新第i个字符在字符串中的字节索引位置。但是这种编码方式是笨拙的，我们需要更简洁的语法。

幸运的是，Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。需要注意的是，对于非ASCII，索引更新的步长将超过1个字节。

```go
for i, r := range "Hello, 世界" {
    fmt.Printf("%d\t%q\t%d\n", i, r, r)
}

// output
0  'H'  72
1  'e'  101
2  'l'  108
3  'l'  108
4  'o'  111
5  ','  44
6  ' '  32
7  '世'  19990
10  '界'  30028
```

文本字符串采用UTF8编码只是一种惯例，但是对于循环的真正字符串并不是一个惯例。如果用于循环的字符串只是一个普通的二进制数据，或者是含有错误编码的UTF8数据，将会发生什么呢？

每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符`\uFFFD`，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号"?"。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。

UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。比如，将\[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列：

```go
s := "world"
fmt.Printf("% x\n", s) // 77 6f 72 6c 64
r := []rune(s)
fmt.Printf("%x\n", r) // [77 6f 72 6c 64]

s2 := "世界"
fmt.Printf("%x\n", s2) // e4 b8 96 e7 95 8c
r2 := []rune(s2)
fmt.Printf("%x\n", r2) // [4e16 754c]
```

如果将一个\[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：

```go
fmt.Println(string(r))  // world
fmt.Println(string(r2)) // 世界
```

如果将一个整数转为字符串，则是生成只包含对应Unicode码点字符的UTF8字符串：

```go
fmt.Println(string(65))     // "A", not "65"
fmt.Println(string(0x4eac)) // "京" 
```

如果对应码点的字符是无效的，则用`\uFFFD`无效字符作为替换：

```go
fmt.Println(string(1234567)) // "?"
```

### 3.5.4. 字符串和byte切片

标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。

bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的\[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。

strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。

unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。

在Go语言中，一个字符串是采用UTF8编码的rune序列，其底层是是一个包含只读字节的数组。所以字符串一旦创建，是不可变的。

字符串和字节slice之间可以相互转换。例如，

```go
s := "abc"
b := []byte(s)
s2 := string(b)
```

从概念上讲，`[]byte(string)`转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在新的字节数组（例如变量b）被修改的情况下，原始的字符串也不会改变。`string([]byte)`转换是根据一个字节slice构造一个字符串拷贝，以确保构造出的字符串是只读的。

为了避免转换中不必要的内存分配，bytes包和strings同时提供了许多实用函数。下面是strings包中的六个函数：

```go
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string
```

bytes包中也对应的六个函数：

```go
func Contains(s, substr string) bool
func Count(s, sep string) int
func Fields(s string) []string
func HasPrefix(s, prefix string) bool
func Index(s, sep string) int
func Join(a []string, sep string) string

```

它们之间唯一的区别是字符串类型参数被替换成了字节slice类型的参数。

bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或\[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的。

举例，

```go
var buf bytes.Buffer
buf.WriteByte('1')
buf.WriteByte('2')
buf.WriteByte('3')
fmt.Println(buf)
```

当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似'\['和']'等ASCII字符则会更加有效。

### 3.5.5. 字符串和数字的转换

字符串和数字之间的转换也比较常见。

如果要将一个整数转为字符串，一种方法是使用fmt.Sprintf函数，返回一个格式化的字符串，另外一种是使用strconv包中Itoa函数。

```go
x := 123
y := fmt.Sprintf("%d", x) // "123"
y2 := strconv.Itoa(x)     // "123"
```

strconv包中的FormatInt和FormatUint函数可以用不同的进制来格式化数字：

```go
fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
```

fmt.Sprintf函数提供了%b、%d、%o和%x等格式化参数，往往比strconv包的Format函数方便很多，特别是在需要附加额外信息的时候：

```go
s := fmt.Sprintf("x=%b", x) // "x=1111011" 
```

如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：

```go
x, err := strconv.Atoi("123")             // x is an int
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits 
```

ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。

### 常见问题

#### 拼接字符串有几种方式？

1）+运算符

使用`+`操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串。

2）fmt.Sprintf函数

由于采用了接口参数，必须要用反射获取值，因此有性能损耗。

3）strings.Builder

strings.Builder底层使用了一个\[]byte切片，并提供了WriteString(s string)方法向切片中添加字符串。

另外，strings.Builder使用String方法返回拼接后的字符串，它是直接把\[]byte转换为string，从而避免变量拷贝。

源代码如下所示：

```go
type Builder struct {
  addr *Builder // of receiver, to detect copies by value
  buf  []byte
}

// WriteString appends the contents of s to b's buffer.
// It returns the length of s and a nil error.
func (b *Builder) WriteString(s string) (int, error) {
  b.copyCheck()
  b.buf = append(b.buf, s...)
  return len(s), nil
}

// String returns the accumulated string.
func (b *Builder) String() string {
  return *(*string)(unsafe.Pointer(&b.buf))
}
```

4）bytes.Buffer

bytes.Buffer底层使用了一个\[]byte切片，可以添加byte类型的数据。

源代码如下所示：

```go
// A Buffer is a variable-sized buffer of bytes with Read and Write methods.
// The zero value for Buffer is an empty buffer ready to use.
type Buffer struct {
  buf      []byte // contents are the bytes buf[off : len(buf)]
  off      int    // read at &buf[off], write at &buf[len(buf)]
  lastRead readOp // last read operation, so that Unread* can work correctly.
}
```

5）strings.Join函数

strings.Join函数是基于strings.Builder来实现的，并且可以自定义分隔符。在Join函数内，调用了b.Grow(n)方法进行内存分配，其中n就是要拼接的字符串的长度。因为可以根据传入的字符串切片确定拼接后的字符串长度，所以可以进行一次性容量分配，比较高效。

源代码如下所示：

```go
// Join concatenates the elements of its first argument to create a single string. The separator
// string sep is placed between elements in the resulting string.
func Join(elems []string, sep string) string {
  switch len(elems) {
  case 0:
    return ""
  case 1:
    return elems[0]
  }
  n := len(sep) * (len(elems) - 1)
  for i := 0; i < len(elems); i++ {
    n += len(elems[i])
  }

  var b Builder
  b.Grow(n)
  b.WriteString(elems[0])
  for _, s := range elems[1:] {
    b.WriteString(sep)
    b.WriteString(s)
  }
  return b.String()
}
```

性能比较：strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf。

示例代码如下：

```go
func main() {
  a := []string{"foo", "bar", "foo"}
  // 1) +
  ret1 := a[0] + a[1] + a[2]
  fmt.Println(ret1)

  // 2) fmt.Sprintf
  ret2 := fmt.Sprintf("%s%s%s", a[0], a[1], a[2])
  fmt.Println(ret2)

  // 3) strings.Builder
  var sb strings.Builder
  sb.WriteString(a[0])
  sb.WriteString(a[1])
  sb.WriteString(a[2])
  ret3 := sb.String()
  fmt.Println(ret3)

  // 4) bytes.Buffer
  buf := new(bytes.Buffer)
  buf.Write([]byte(a[0]))
  buf.Write([]byte(a[1]))
  buf.Write([]byte(a[2]))
  ret4 := buf.String()
  fmt.Println(ret4)

  // 5) strings.Join
  ret5 := strings.Join(a, "")
  fmt.Println(ret5)
}
```

## 3.6. 常量

常量表达式的值在编译期计算，而不是在运行期。每种常量的潜在类型都是基础类型：boolean、string或数字。

一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。例如，常量比变量更适合用于表达像π之类的数学常数，因为它们的值不会发生变化：

```go
const pi = 3.14159 // approximately; math.Pi is a better approximation
```

所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex和unsafe.Sizeof。

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，time.Duration是一个命名类型，底层类型是int64，time.Minute是对应类型的常量。下面声明的两个常量都是time.Duration类型，可以通过%T参数打印类型信息：

```go
const noDelay time.Duration = 0
const timeout = 5 * time.Minute
fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"
fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
```

### 3.6.1. iota 常量生成器

声明常量可以使用iota常量生成器，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。

下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日为0开始。在其它编程语言中，这种类型一般被称为枚举类型。

```go
type Weekday int

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

我们也可以在复杂的常量表达式中使用iota。下面是一个更复杂的例子，每个常量都是1024的幂：

```go
const (
    _ = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 << 64)
    YiB // 1208925819614629174706176
)

```

不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。

### 3.6.2. 无类型常量

虽然一个常量可以有任意一个确定的基础类型，例如int或float64，但是许多常量并没有一个明确的基础类型。Go语言编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有256bit的运算精度。有六种未明确类型的常量类型，分别是

-   类型的布尔型
-   无类型的整数
-   无类型的字符
-   无类型的浮点数
-   无类型的复数
-   无类型的字符串

通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式，甚至不需要显式的类型转换。例如，ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：`YiB/ZiB`是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：

```go
fmt.Println(YiB/ZiB) // "1024"
```

另一个例子，math.Pi是一个无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

```go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换。

对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和`\u0000`虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false是无类型的布尔类型，字符串面值常量是无类型的字符串类型。

只有常量可以是无类型的。当一个无类型的常量被赋值给一个有显式类型的变量时，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。代码如下所示：

```go
var f float64 = 3 + 0i // untyped complex -> float64
f = 2                  // untyped integer -> float64
f = 1e123              // untyped floating-point -> float64
f = 'a'                // untyped rune -> float64

```

上面的语句相当于下面的显式转换：

```go
var f float64 = float64(3 + 0i)
f = float64(2)
f = float64(1e123)
f = float64('a')
```

无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。

对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型，就像下面的例子：

```go
i := 0      // untyped integer;        implicit int(0)
r := '\000' // untyped rune;           implicit rune('\000')
f := 0.0    // untyped floating-point; implicit float64(0.0)
c := 0i     // untyped complex;        implicit complex128(0i)
```

注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。因为如果不知道浮点数类型的内存大小是很难写出正确的数值算法的。

```go
fmt.Printf("%T\n", 0)        // "int"
fmt.Printf("%T\n", 0.0)      // "float64"
fmt.Printf("%T\n", 0i)       // "complex128"
fmt.Printf("%T\n", '\u0000') // "int32" (rune)
```

当尝试将这些无类型的常量转为一个接口值时，这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。

# 4. 复合数据类型

除了基础数据类型外，Go语言还提供了一些复合类型：数组、slice、map和结构体。

## 4.1. 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，而且数组的长度是数组类型的一个组成部分，因此在Go语言中很少直接使用数组。

声明一个数组也可以使用var语句、字面值语法或new关键字。对于字面值语法，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。

```go
var a [3]int             // array of 3 integers
fmt.Println(a[0])        // print the first element
fmt.Println(a[len(a)-1]) // print the last element, a[2]

var a2 [3]int = [3]int{1, 2, 3}
var a3 [3]int = [3]int{0: 1, 1: 2, 2: 3}

var a4 = [...]int{1, 2, 3}
fmt.Printf("%T\n", a3) // "[3]int"

var a5 = new([3]int)
fmt.Println(a4) // [0, 0, 0]
```

数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。

因为数组的长度是数组类型的一个组成部分，所以\[3]int和\[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。

传递数组作为函数参数：因为函数参数传递机制导致传递的参数进行复制，所以传递数组变量作为函数参数将是低效的。而且，在函数内部，对数组参数的任何修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。

> 常见问题：Go语言的函数传递机制？
> 在Go语言中，函数参数传递机制是值传递。调用一个函数时，每个调用参数会复制一份传给函数的参数变量，所以函数的参数变量接收的是调用参数的副本，并不是调用参数的原始变量。
> 另外，Go语言对待数组的方式和其它很多编程语言不同，Go语言使用值传递，而其它一些编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。

为了在函数内部修改传入的数组变量，我们可以显式地传入一个数组指针：函数通过指针对数组的任何修改都可以直接反馈到调用者。

```go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```

虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。上面的zero函数并不能接收指向\[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。

### 4.1.1. 切片操作

数组支持切片操作：a\[low:high\[:max]]，其中0≤low≤high≤max≤len(a)，而且max部分可以省略。

数组切片的结果是一个Slice。举例：

```go
var s = [3]int{1, 2, 3}
fmt.Printf("%T %v %d %d\n", s, s, len(s), cap(s)) // [3]int [1 2 3] 3 3

s2 := s[0:1:3]
fmt.Printf("%T %v %d %d\n", s2, s2, len(s2), cap(s2)) // []int [1] 1 3
```

因为数组切片的语法和原理几乎一样，可以参见Slice的切片操作。

## 4.2. 切片Slice

> [https://gopl-zh.github.io/ch4/ch4-02.html](https://gopl-zh.github.io/ch4/ch4-02.html "https://gopl-zh.github.io/ch4/ch4-02.html")
> [https://zhuanlan.zhihu.com/p/61121325](https://zhuanlan.zhihu.com/p/61121325 "https://zhuanlan.zhihu.com/p/61121325")

切片Slice表示变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作\[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。slice的底层引用一个数组对象。

声明一个slice可以使用var语句或字面值语法。slice的零值是nil。对于字面值语法，不需要指明序列的长度。这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。和数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定。

```go
var s []int
fmt.Println(s == nil) // true

var s2 = []int{0, 1, 2, 3, 4, 5} // [0 1 2 3 4 5]
var s3 = []int{0: 0, 5: 5}       // [0 0 0 0 0 5]

```

另外，内置的make函数也可以声明一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。

```go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```

在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。在第一种语句中，slice底层是整个数组；在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。

> 问题：new关键字和make关键字的相同点和不同点？
> 首先，Go语言中的数据类型分为值类型和引用类型：值类型包括 int、float、string等，该类型变量的空间存储的是该类型的值；引用类型是 slice、map、channel和值类型对应的指针，该类型变量的空间存储的是内存中真正存储数据的首地址（即指针）。
> 相同点：
> 1）new和make都可以给变量分配内存，并进行初始化。
> 不同点：
> 1）分配对象不同：new用于值类型，包括int、float、string、bool、数组、struct等数据类型；make用于引用类型，slice、map，channel等数据类型。
> 2）返回类型不同：new返回指向变量的指针，make返回变量本身。
> 3）初始化结果不同：new分配的空间被清零，即初始化为零值；make 分配空间后，会进行初始化，比如slice的长度和底层数组。

和数组不同的是，slice之间不能比较，因此我们不能使用`==`操作符来判断两个slice是否含有全部相等元素。标准库提供了高度优化的bytes.Equal函数来判断两个\[]byte 切片是否相等，但是对于其他类型的slice，我们必须自己对每个元素进行比较。

例如，比较两个\[]string切片：

```go
func equal(x, y []string) bool {
    if len(x) != len(y) {
        return false
    }
    for i := range x {
        if x[i] != y[i] {
            return false
        }
    }
    return true
}
```

slice唯一合法的比较操作是和nil比较。一个nil值的slice并没有底层数组，而且slice的长度和容量都是0。空的切片（比如`[]int{}`或`make([]int, 3)[3:]`）的长度和容量也是0。

与任意类型的nil值一样，我们可以用`[]int(nil)`表达式来生成一个对应类型slice的nil值。

```go
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
```

如果你需要测试一个slice是否是空的，应该使用`len(s) == 0`来判断，而不是用`s == nil`。除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和长度为0的slice。

传递切片作为函数参数：虽然函数参数传递机制导致传递的参数进行复制，但是切片变量本身是引用类型（因为slice底层包含一个指向第一个slice元素的指针），即使复制也是复制引用，二者引用相同的底层。所以，在函数内部，对切片元素的修改会反应在原来的切片上。

### 4.2.1. 切片操作

和数组一样，slice也支持切片操作：s\[low:high\[:max]]，其中0 ≤ low≤ high≤ cap(s)，而且max部分可以省略。切片操作会返回一个新的slice，引用s的从第low个元素开始到第high-1个元素的子序列。新的slice将只有high-low个元素。如果low位置的索引被省略的话将使用0代替，如果high位置的索引被省略的话将使用len(s)代替。

举例，month声明了一个包含12个月份的数组：一月份是months\[1]，十二月份是months\[12]。数组的第一个元素从索引0开始，但是月份一般是从1开始的，因此我们声明数组时直接跳过第0个元素。

```go
months := [...]string{1: "January", /* ... */, 12: "December"}
all := months[1:13] // equal to months[1:] or months[:]

Q2 := months[4:7]
summer := months[6:9]
fmt.Println(Q2)     // ["April" "May" "June"]
fmt.Println(summer) // ["June" "July" "August"]
```

months\[1:13]切片操作将引用全部有效的月份，和months\[1:]操作等价；months\[:]切片操作则是引用整个数组。另外，多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。例如，Q2和summer两个slice都包含了六月份，并且都是引用数组month中的数据。

如果切片操作超出len(s)则是意味着扩展了slice，但是超出cap(s)的上限将导致一个panic异常：

```go
fmt.Println(len(summer), cap(summer)) // 3 7
endlessSummer := summer[:5] // extend a slice (within capacity)
fmt.Println(endlessSummer)  // "[June July August September October]"

fmt.Println(summer[:20]) // panic: out of range

```

### 4.2.2. append函数

内置的append函数用于向slice追加元素，并返回一个新的slice。

append函数可以追加多个元素，甚至追加一个slice。

```go
var x []int
x = append(x, 1)
x = append(x, 2, 3)
x = append(x, 4, 5, 6)
x = append(x, x...) // append the slice x
fmt.Println(x)      // "[1 2 3 4 5 6 1 2 3 4 5 6]"
```

append函数对于理解slice底层是如何工作的非常重要。简单来说，每次调用append函数，必须先检测slice底层数组是否有足够的容量来保存新插入的元素。

-   如果有足够空间，就可以直接把新插入的元素添加到底层数组，扩展slice长度使其能够访问新插入的元素，并返回slice。因此，输入的切片和返回的切片仍然引用相同的底层数组。
    -   有足够空间是指，对于新插入的元素，slice的底层数组末尾有足够的空位置。
-   如果没有足够的增长空间，则会先分配一个足够大的数组用于保存结果（扩容），先将输入的切片复制到新的数组，然后把新插入的元素添加到新的数组。因此，返回的切片和输入的切片将会引用不同的底层数组。

因为append调用可能会导致内存的重新分配，我们不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。因此，通常是将append返回的结果直接赋值给输入的slice变量。值得注意的是，Go语言编译器不允许调用了 append 函数后不使用返回值，因此下面的代码会编译失败。

```go
var x []int
append(x, 1) // append(x, 1) (value of type []int) is not used
```

为了加深理解slice和append函数，举一个《Go学习笔记》中的例子：

```go
func main() {
    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s1 := slice[2:5] // [2 3 4], len=3, cap=3
    s2 := s1[2:6:7]  // [4 5 6 7], len=4, cap=5

    s2 = append(s2, 100)
    s2 = append(s2, 200)

    s1[2] = 20

    fmt.Println(s1)    // [2 3 20]
    fmt.Println(s2)    // [4 5 6 7 100 200]
    fmt.Println(slice) // [0 1 2 3 20 5 6 7 100 9]
}
```

因为切片s1、s2、slice引用相同的底层数组，所以对切片的更新操作可能会影响底层数组。当切片一次扩容，比如第二次`s2 = append(s2, 200)`，切片s2将会引用一个新的不同的数组。

### 4.2.3. Slice内存技巧

一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack：

```go
stack = append(stack, v) // push v 
```

stack的顶部位置对应slice的最后一个元素：

```go
top := stack[len(stack)-1] // top of stack 
```

通过收缩stack可以弹出栈顶的元素：

```go
stack = stack[:len(stack)-1] // pop 
```

要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成：

```go
func remove(slice []int, i int) []int {
    copy(slice[i:], slice[i+1:])
    return slice[:len(slice)-1]
}

func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 8 9]"
}
```

如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：

```go
func remove2(slice []int, i int) []int {
    slice[i] = slice[len(slice)-1]
    return slice[:len(slice)-1]
}
```

### 底层实现和原理

> [https://halfrost.com/go\_slice/](https://halfrost.com/go_slice/ "https://halfrost.com/go_slice/")
> [https://golang.design/go-questions/slice/grow/](https://golang.design/go-questions/slice/grow/ "https://golang.design/go-questions/slice/grow/")

Slice的底层数据结构如下：

```go
// runtime/slice.go
type slice struct {
    array unsafe.Pointer // 元素指针
    len   int // 长度 
    cap   int // 容量
}
```

一个slice由三个部分构成：

-   array：指针，指向第一个slice元素对应的底层数组元素的地址。需要注意的是，slice的第一个元素并不一定就是底层数组的第一个元素。
-   len：长度对应slice中元素的数目。内置的len函数可以返回slice的长度。
-   cap：容量一般是从slice的开始位置到底层数据的结尾位置。长度不能超过容量。内置的cap函数可以返回slice的容量。

#### 声明操作

TODO

#### append 操作

append操作实际上是往底层数组添加元素，并且支持一个或多个元素。

如果切片的剩余空间无法容纳要append的元素，那么append操作就会触发切片扩容。举例，

-   如果切片的容量已经满了，无论append几个元素都会触发扩容。
-   如果切片的容量还可以容纳1个元素，那么append超过1个元素就会触发扩容。

切片扩容的核心逻辑在growslice函数，其中参数cap表示期望的新的最小容量，该值等于旧切片的容量加上append的元素数量。

在1.18版本之前，growslice函数的扩容逻辑如下（go 1.9.5）：

```go
// growslice handles slice growth during append.
// It is passed the slice element type, the old slice, and the desired new minimum capacity,
// and it returns a new slice with at least that capacity, with the old data
// copied into it.
func growslice(et *_type, old slice, cap int) slice {
  // 这里就是扩容的策略
  newcap := old.cap
  doublecap := newcap + newcap
  if cap > doublecap {
    newcap = cap
  } else {
    if old.len < 1024 {
      newcap = doublecap
    } else {
      // Check 0 < newcap to detect overflow
      // and prevent an infinite loop.
      for 0 < newcap && newcap < cap {
        newcap += newcap / 4
      }
      // Set newcap to the requested cap when
      // the newcap calculation overflowed.
      if newcap <= 0 {
        newcap = cap
      }
    }
  }

  // 返回最终新切片，容量更新为最新扩容之后的容量
  return slice{p, old.len, newcap}
}
```

总结：

-   如果所需的新的最小容量cap大于旧切片的容量oldcap的2倍，那么新切片的容量newcap即为cap。比如，旧切片的容量为3，append一次操作10个元素，那么所需的新的最小容量cap=13，大于旧切片的容量oldcap的2倍。
-   如果旧切片的长度len小于1024，那么新切片的容量newcap变为oldcap的2倍。
-   如果旧切片的长度len大于等于1024，新切片的容量newcap会经过一个循环计算`newcap += newcap / 4`，直到newcap大于等于所需的新的最小容量cap。一般来说，结果都是oldcap的1.25倍。如果循环结束计算出来的newcap溢出（小于0），那么新切片的容量newcap就是所需的新的最小容量cap。注意，之后还可能会进行内存对齐操作，导致最终的新切片的容量newcap可能变得更大。

在1.18版本及之后，growslice函数的扩容逻辑如下（go 1.18.3）：

```go
// growslice handles slice growth during append.
// It is passed the slice element type, the old slice, and the desired new minimum capacity,
// and it returns a new slice with at least that capacity, with the old data
// copied into it.
func growslice(et *_type, old slice, cap int) slice {
  ...
  newcap := old.cap
  doublecap := newcap + newcap
  if cap > doublecap {
    newcap = cap
  } else {
    const threshold = 256
    if old.cap < threshold {
      newcap = doublecap
    } else {
      // Check 0 < newcap to detect overflow
      // and prevent an infinite loop.
      for 0 < newcap && newcap < cap {
        // Transition from growing 2x for small slices
        // to growing 1.25x for large slices. This formula
        // gives a smooth-ish transition between the two.
        newcap += (newcap + 3*threshold) / 4
      }
      // Set newcap to the requested cap when
      // the newcap calculation overflowed.
      if newcap <= 0 {
        newcap = cap
      }
    }
  }
  ...
}
```

总结：

-   如果所需的新的最小容量cap大于旧切片的容量oldcap的2倍，那么新切片的容量newcap即为cap。比如，旧切片的容量为3，append一次操作10个元素，那么所需的新的最小容量cap=13，大于旧切片的容量oldcap的2倍。
-   如果旧切片的容量oldcap小于阈值threshold=256，那么新切片的容量newcap变为oldcap的2倍。
-   如果旧切片的容量oldcap大于等于阈值256，那么新切片的容量newcap会经过一个循环计算`newcap += (newcap + 3*threshold) / 4`，直到newcap大于等于所需的新的最小容量cap。如果循环结束计算出来的newcap溢出（小于0），那么新切片的容量newcap就是所需的新的最小容量cap。注意，之后还可能会进行内存对齐操作，导致最终的新切片的容量newcap可能变得更大。

### 常见问题

#### 切片作为函数参数，更新操作是否影响形参？

修改切片中的元素会影响传入的切片，但是append操作不会影响传入的切片。代码演示如下：

```go
func main() {
  nums := make([]int, 2, 4)
  fmt.Printf("%v %p %d %d\n", nums, nums, len(nums), cap(nums))
  changeSlice(nums)
  fmt.Printf("%v %p %d %d\n", nums, nums, len(nums), cap(nums))
  appendSlice(nums)
  fmt.Printf("%v %p %d %d\n", nums, nums, len(nums), cap(nums))
}

func changeSlice(nums []int) {
  nums[0] = 100
}

func appendSlice(nums []int) {
  nums = append(nums, 10)
  fmt.Printf("appendSlice: %v %p %d %d\n", nums, nums, len(nums), cap(nums))
}

// [0 0] 0xc00001e060 2 4
// [100 0] 0xc00001e060 2 4
// appendSlice: [100 0 10] 0xc00001e060 3 4
// [100 0] 0xc00001e060 2 4
```

虽然Go语言使用值传递机制，但是切片变量本身是引用类型（因为slice底层包含一个指向第一个slice元素的指针），即使复制也是复制引用，二者引用相同的底层。所以，在函数内部，对切片元素的修改会反应在原来的切片上。

由代码可知，即使函数中append操作不会导致扩容，也无法无法反映到传入的实际切片上。这是因为函数内的append操作只是把数据append底层数组，无法修改切片的长度，所以传入的切片不受影响。

## 4.3. 字典map

字典map是一个无序的key/value对的集合，也称为哈希表。字典中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map\[K]V，其中K和V分别对应key和value的类型。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。另外，K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法。对于V对应的value数据类型则没有任何的限制。

声明一个map可以使用使用var语句，字面值语法或make关键字。如果var语句中没有初始化表达式，那么Go语言默认会使用零值nil初始化map（因为map类型的零值是nil）。

```go
var m map[string]int     // nil map
fmt.Println(m == nil)    // "true" 
fmt.Println(len(m) == 0) // "true" 
m["name"] = 25           // panic: assignment to entry in nil map

var m2 = map[string]int{} // empty map
fmt.Println(len(m2) == 0) // "true" 
m2["name"] = 25
fmt.Println(m2) // map[name:25]

// 字面值语法
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}

// make
m := make(map[string]int)

```

map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。唯一不同的是向一个nil值的map存入元素将导致一个panic异常。

使用map的下标语法访问（或查找）一个key将产生一个value。查找操作总是安全的：如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值。

```go
fmt.Println(ages["alice"])  // "32"
fmt.Println(ages["alice2"]) // "0"
```

如果需要知道对应的元素是否真的是在map之中，可以使用访问操作的第二个返回值。在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。

```go
age, ok := ages["bob"]
if !ok { /* "bob" is not a key in this map; age == 0. */ }
```

内置的delete函数可以用来删除map中的元素。删除操作也是安全的，即使这些元素不在map中也没有关系。

```go
delete(ages, "alice") // remove element ages["alice"]
```

注意：map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作。禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。

```go
_ = &ages["bob"] // compile error: cannot take address of map element 
```

range风格的for循环也可以用来遍历map。注意，map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，是为了强制要求程序不会依赖具体的哈希函数实现。

```go
for name, age := range ages {
    fmt.Printf("%s\t%d\n", name, age)
}
```

和slice一样，map之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个map是否包含相同的key和value，我们必须通过一个循环实现：

```go
func equal(x, y map[string]int) bool {
    if len(x) != len(y) {
        return false
    }
    for k, xv := range x {
        if yv, ok := y[k]; !ok || yv != xv {
            return false
        }
    }
    return true
}
```

Go语言中并没有提供一个set类型，但是很容易就可以用map实现类似set的功能。

```go
set := make(map[string]bool)
set["Go"] = true
set["Java"] = true
```

有时候需要map或set的key是slice类型，但是因为map的key必须是可比较的类型，slice并不满足这个条件。解决方案是定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。注意，辅助函数k(x)也不一定是字符串类型，它可以使用任何可比较的类型，例如整数、数组或结构体等。

### 底层实现和原理

> [https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/](https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/ "https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/")
> [https://segmentfault.com/a/1190000039101378](https://segmentfault.com/a/1190000039101378 "https://segmentfault.com/a/1190000039101378")

map底层使用了数组和链表。数组是最核心的数据结构之一，其中每个元素可以认为是一个桶。map使用哈希函数计算一个键的哈希（Hash）值，然后映射到数组中的一个桶，这样就可以把一个键值对保存到对应的桶中。一个桶可以认为包含了两个长度为8的数组，分别用来存放key和value，所以一个桶（正常桶）最多存放8个键值对。如果不同的键映射到了相同的桶，即产生了哈希冲突，那么会根据key的Hash值存把key存放到桶的不同位置。如果超过了8个key，那么map会把溢出的键值对存放到溢出桶，并使用链表连接正常桶和溢出桶。

map的底层结构如下图所示：

![image_NV5yLzHip5](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311252027185.png)

第一个核心数据结构是hmap，代码如下：

```go
// A header for a Go map.
type hmap struct {
  // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
  // Make sure this stays in sync with the compiler's definition.
  count     int // # live cells == size of map.  Must be first (used by len() builtin)
  flags     uint8
  B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
  noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
  hash0     uint32 // hash seed

  buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
  oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
  nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

  extra *mapextra // optional fields
}

// mapextra holds fields that are not present on all maps.
type mapextra struct {
  overflow    *[]*bmap
  oldoverflow *[]*bmap

  // nextOverflow holds a pointer to a free overflow bucket.
  nextOverflow *bmap
}
```

解释：

-   count：哈希表个数。对map调用len函数时，返回这个值。
-   flags：状态标识，比如正在被写、buckets和oldbuckets在被遍历、等量扩容。
-   B：底层数组buckets大小的log2对数。
-   noverflow：溢出桶里bmap大致的数量。
-   hash0：哈希的种子，它能为哈希函数的结果引入随机性，这个值在创建哈希表时确定。
-   buckets：指针，指向底层数组，数组大小为2^B。
-   oldbuckets：用于扩容时保存旧的buckets中的数据。等量扩容的时候，buckets 长度和 oldbuckets 相等；双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍。
-   nevacuate：指示扩容进度，小于此地址的 buckets 迁移完成。
-   extra：溢出桶结构，正常桶里面某个bmap存满了，会使用这里面的内存空间存放键值对。

另外，对于buckets指针引用的底层数组，其中每一个元素指向了是一个叫做bmap结构体，也就是我们常说的“桶”。

```go
// A bucket for a Go map.
type bmap struct {
  // tophash generally contains the top byte of the hash value
  // for each key in this bucket. If tophash[0] < minTopHash,
  // tophash[0] is a bucket evacuation state instead.
  tophash [bucketCnt]uint8
  // Followed by bucketCnt keys and then bucketCnt elems.
  // NOTE: packing all the keys together and then all the elems together makes the
  // code a bit more complicated than alternating key/elem/key/elem/... but it allows
  // us to eliminate padding which would be needed for, e.g., map[int64]int8.
  // Followed by an overflow pointer.
}
```

可以看出，bmap只包含一个简单的 tophash 字段， 用来存储键的哈希值的高 8 位。通过比较不同键的Hash值的高 8 位，可以减少访问键值对次数以提高性能。

但是，在运行期间，bmap 其实不止包含 tophash 字段，因为哈希表中可能存储不同类型的键值对，而且 Go 语言也不支持泛型，所以键值对占据的内存空间大小只能在编译时进行推导。bmap 中的其他字段是通过计算内存地址的方式访问的，我们可以根据编译期间的 `cmd/compile/internal/gc.bmap`函数重建它的结构：

```go
type bmap struct {
    topbits  [8]uint8
    keys     [8]keytype
    values   [8]valuetype
    pad      uintptr
    overflow uintptr
}
```

解释：

-   topbits：长度为8的数组，每个元素为key的哈希值的高8位，用于遍历时对比，提高性能。
-   keys：长度为8的数组，具体的key值。
-   values：长度为8的数组，键值对key对应的value值。
-   pad：对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件。
-   overflow：指向的hmap.extra.overflow溢出桶里的bmap。

从上面的字段topbits、keys、values均为长度为8的数组可以看出，一个桶里面会最多装 8 个 键值对。如果一个桶已经存放了8个键值对，并且新写入的key也被映射到这个桶，那么这个桶会链接一个overflow指向的这个bmap（溢出桶），新写入的键值对存放在这里。不过，溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致扩容。

#### 声明操作

TODO

#### 查找操作

简单来说，查找操作通过哈希函数获取目标键的哈希值，然后找到对应的bmap桶，最后遍历bmap正常桶和溢出桶中的键数组，和目标key对比是否相同（找不到则返回空值）。

查找操作有两种形式，区别是是否有一个ok返回值。比如，

```go
res := m["name"]
res, ok := m["name"]
```

对于不带ok的形式，Go语言会使用 runtime.mapaccess1函数，该函数仅会返回一个指向目标值的指针；对于带ok的形式，Go语言会使用runtime.mapaccess2函数，该函数除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 bool 值。

查找操作的核心逻辑是一个双层循环，外层遍历 bucket 和溢出bucket，内层遍历bucket 的topbits数组和keys数组。

#### 写入操作

简单来说，写入操作类似查找操作，因为首先要找到对应的键，找到之后可以进修改，找不到就插入新的键值对。

通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 mapassign 函数。需要注意，

-   数首先会检查 map 的标志位 flags。如果 flags 的写标志位此时被置 1 了，说明有其他协程在执行“写”操作，进而导致程序 panic。这也说明了 map 对协程是不安全的，不支持并发。
-   如果 bucket 的 8 个 key 都已经放置满了，那在跳出循环后，就需要需要在 bucket 后面挂上overflow bucket。当然，也有可能是在 overflow bucket 后面再挂上一个 overflow bucket。这就说明，太多 key hash 到了此 bucket。
-   在正式存放 key 之前，还要检查 map 的状态，看它是否需要进行扩容。如果满足扩容的条件，就主动触发一次扩容操作。如果出现扩容，之前的查找定位 key 的过程还得再重新走一次。因为扩容之后，key 的分布都发生了变化。

写入操作可能导致map发生扩容。因为一个 bucket 中最多可以存放 8 个 key，如果一个bucket存放的key越来越多，就会创建溢出桶形成链表结构，导致性能变差。

Go语言定义了一个叫做装载因子的指标来衡量溢出桶的情况，计算公式为 map 的元素个数除以bucket的 数量。如下所示：

```go
loadFactor := count / (2^B)
```

在向 map 插入新 key 时，如果符合下面任意一个扩容条件，就会触发扩容：

-   第1个：装载因子超过阈值 6.5。
-   第2个：溢出桶overflow 的 bucket 数量过多：
    -   当 B 小于 16时，也就是当 bucket 总数 2^B 小于 2^15 时，如果 overflow 的 bucket 数量超过 2^B。
    -   当 B大于等于16时，也就是当 bucket 总数 2^B 大于等于 2^15，如果 overflow 的 bucket 数量超过 2^15。

扩容条件的源代码如下：

```go
// 装载因子超过 6.5
func overLoadFactor(count int64, B uint8) bool {
  return count >= bucketCnt && float32(count) >= loadFactor*float32((uint64(1)<<B))
}

// overflow buckets 太多
func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {
  if B < 16 {
    return noverflow >= uint16(1)<<B
  }
  return noverflow >= 1<<15
}
```

再解释一下扩容条件：

-   对于第1个扩容条件：我们知道，每个 bucket 有 8 个空位，在没有溢出，且所有的桶都装满了的情况下，装载因子算出来的结果是 8。因此当装载因子超过 6.5 时，表明很多 bucket 都快要装满了，查找效率和插入效率都变低了。在这个时候进行扩容是有必要的。
-   对于第2个扩容条件：这是对第 1 点的补充。比如在装载因子比较小的情况下，这时候 map 的查找和插入效率也很低，而第 1 点识别不出来这种情况。表面现象就是计算装载因子的分子比较小，即 map 里元素总数少，但是 bucket 数量多（真实分配的 bucket 数量多，包括大量的 overflow bucket）。

虽然两个扩容条件都会触发扩容，但是扩容的结果并不相同，毕竟两种条件应对的场景不同。

-   对于第1个扩容条件：元素太多，而 bucket 数量太少，扩容结果是B加一，使bucket数量变为原来的2倍。此时，需要创建一个新的bucket，最大数量变为原来bucket的最大数量的 2 倍。注意，这时元素都在老 bucket 里，还没迁移到新的 bucket 。
-   对于第2个扩容条件：元素没那么多，但是 overflow bucket 数特别多，说明很多 bucket 都没装满。解决办法就是开辟一个新 bucket 空间，将老 bucket 中的元素移动到新 bucket，使得同一个 bucket 中的 key 排列地更紧密。这样，原来在 overflow bucket 中的 key 可以移动到 bucket 中来。结果是节省空间，提高 bucket 利用率，map 的查找和插入效率自然就会提升。

最后来看一下扩容具体是怎么做的。由于 map 扩容需要将原有的 key/value 重新搬迁到新的内存地址，如果有大量的 key/value 需要搬迁，会非常影响性能。因此 Go 语言采取了一种称为“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket。

扩容的核心逻辑在hashGrow和growWork函数中，代码如下：

```go
func hashGrow(t *maptype, h *hmap) {
  // B+1 相当于是原来 2 倍的空间
  bigger := uint8(1)

  // 对应条件 2
  if !overLoadFactor(int64(h.count), h.B) {
    // 进行等量的内存扩容，所以 B 不变
    bigger = 0
    h.flags |= sameSizeGrow
  }
  // 将老 buckets 挂到 buckets 上
  oldbuckets := h.buckets
  // 申请新的 buckets 空间
  newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger)

  flags := h.flags &^ (iterator | oldIterator)
  if h.flags&iterator != 0 {
    flags |= oldIterator
  }
  // 提交 grow 的动作
  h.B += bigger
  h.flags = flags
  h.oldbuckets = oldbuckets
  h.buckets = newbuckets
  // 搬迁进度为 0
  h.nevacuate = 0
  // overflow buckets 数为 0
  h.noverflow = 0

  // ……
}

func growWork(t *maptype, h *hmap, bucket uintptr) {
  // make sure we evacuate the oldbucket corresponding
  // to the bucket we're about to use
  evacuate(t, h, bucket&h.oldbucketmask())

  // evacuate one more oldbucket to make progress on growing
  if h.growing() {
    evacuate(t, h, h.nevacuate)
  }
}
```

hashGrow 函数实际上并没有真正地“搬迁”，它只是分配好了新的 buckets，并将老的 buckets 挂到了 oldbuckets 字段上。真正搬迁 buckets 的动作在 growWork 函数中，而调用 growWork函数的动作是在 mapassign 和 mapdelete 函数中。也就是说，在插入或修改、删除 key 时，都会尝试进行搬迁 buckets 的工作。具体地，growWork函数先检查 oldbuckets 是否搬迁完毕，如果oldbuckets不为nil，即没有搬迁完毕，需要进行搬迁工作。

#### 删除操作

TODO

#### 遍历操作

TODO

### 常见问题

#### map是否支持并发读写相同的key？如果是不同的key呢？

map允许并发读，但是本不支持并发读写，无论并发读写是否是相同的key。

如果发生了并发读写同一个map的情况，那么会导致一个严重错误：`fatal error: concurrent map read and map write`。

为了保证安全，在读写map之前需要加锁，可以使用互斥锁sync.Mutex或者直接使用sync.Map。

代码演示如下：

```go
func main() {
  var m = map[int]int{}

  go func() {
    for {
      _ = m[0] // read a key
    }
  }()

  go func() {
    for {
      // _ = m[1] // support concurrent read
      // m[0] = 1 // write the same key
      m[1] = 1 // write a different key
    }
  }()

  var s string
  fmt.Scanln(&s)
}

// output:
// fatal error: concurrent map read and map write
```

## 4.4. 结构体struct

结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。

举例：声明一个Student类型并声明一个该类型的变量。

```go
type Student struct {
    Id   uint64
    Name string
}

var s Student
```

结构体变量的成员可以通过点操作符访问：

```go
fmt.Println(s.Id, s.Name) // 0, ""
s.Id = 1
s.Name = "John"
fmt.Println(s.Id, s.Name) // 1, "John"
```

点操作符也可以和指向结构体的指针一起工作：

```go
var s2 *Student = &s
s2.Name += "son"
fmt.Println(s2.Id, s2.Name) // 1, "Johnson"
```

结构体成员的顺序也有重要的意义。我们可以交换不同成员出现的先后顺序，那样的话就是定义了不同的结构体类型。

Go语言规定：如果结构体成员名字是以大写字母开头的，那么该成员就是导出的。一个结构体可能同时包含导出和未导出的成员。

另外，一个命名为S的结构体类型将不能再包含S类型的成员，因为一个聚合的值不能包含它自身。但是，S类型的结构体可以包含`*S`指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。

举例，定义一个二叉树结点类型：

```go
type TreeNode struct {
    value       int
    left, right *TreeNode
}
```

结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。例如，对于bytes.Buffer类型，结构体初始值就是一个随时可用的空缓存，还有在第9章将会讲到的sync.Mutex的零值也是有效的未锁定状态。

如果结构体没有任何成员的话就是空结构体，写作struct{}。它占用的内存大小为0，不包含任何信息，但是有时候依然是有价值的。比如，用map来模拟set数据结构时，可以用它作为map中的value类型。另外，也可以作为channel发送和接收的数据类型。

### 4.4.1. 结构体字面值

声明一个结构体变量也可以用结构体字面值语法，结构体字面值可以指定每个成员的值。

```go
type Point struct{ X, Y int }

p := Point{1, 2}
p2 := Point{X: 3, Y:4}
```

结构体字面值语法有两种形式：

-   第一种是以结构体成员定义的顺序为每个结构体成员指定一个字面值，字面值的数量等于成员的数量。这种形式比较僵化，传递的字面值的顺序和数量必须严格遵守结构体的定义，一旦结构体成员有细微的调整就可能导致代码不能编译。
-   第二种更加常用，以成员名字和相应的值来初始化，可以包含部分或全部的成员。在这种形式中，如果成员被忽略的话将默认用零值。因为提供了成员的名字，所以成员出现的顺序并不重要。

注意：

-   两种不同形式的写法不能混合使用。
-   无法在外部包中初始化结构体中未导出的成员。

结构体可以作为函数的参数和返回值。例如，下面的Scale函数将Point类型的值缩放后返回。如果考虑效率的话，较大的结构体通常会用指针的方式传入和返回。

```go
func Scale(p Point, factor int) Point {
    return Point{p.X * factor, p.Y * factor}
}

func Bonus(e *Employee, percent int) int {
    return e.Salary * percent / 100
}
```

如果要在函数内部修改结构体成员的话，必须用指针传入。因为在Go语言中，函数参数的传入发生值拷贝，函数参数将不再是函数调用时的原始变量。函数参数返回同样如此。

```go
pp := &Point{1, 2} 

pp := new(Point)
*pp = Point{1, 2} 
```

结构体通常通过指针处理，可以使用字面值和取地址运算符或new关键字创建并初始化一个结构体变量，并返回结构体的地址。不过，Uber Golang指南推荐直接使用前者。

### 4.4.2. 结构体比较

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用`==`或`!=`运算符进行比较。

具体地，相等比较运算符`==`将逐一比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：

```go
type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"
```

如果一个结构体类型是可以比较的，那么该类型可以用于map的key。

### 4.4.3. 结构体嵌入和匿名成员

Go语言提供结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员。

举例，定义一个一个Circle代表的圆形类需要两个成员：点Point表示圆心和半径。

```go
type Circle struct {
    Point
    Radius int
}
```

在Circle类型的定义中，我们声明一个了Point类型的成员而没有指定成员的名字：这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。

得益于匿名嵌入的特性，通过点运算符可以直接访问匿名结构体的成员：

```go
var c Circle
c.X = 8 // equivalent to c.Point.X = 8 
c.Y = 8 // equivalent to c.Point.X = 8
c.Radius = 5
```

注意：匿名成员并不是真的无法访问。匿名成员Point都有自己的名字——就是命名的类型名字，但是这些名字在点操作符中是可选的。出于方便，访问子成员的时候可以忽略任何匿名成员部分。

另外，使用字面值语法声明含有匿名成员的结构体变量时会稍微麻烦：

```go
c := Circle{Point{8, 8}, 5}

c2 := Circle{
    Point:  Point{X: 8, Y: 8},
    Radius: 5,
}
```

因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。

匿名成员的特性包括：

-   外层结构体可以通过点运算符语法糖访问匿名成员的成员。匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。
-   外层结构体也可以通过点运算符语法访问匿名成员的导出方法。实际上，外层结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型全部导出的方法。

在Go语言中，在结构体中声明一个匿名成员也被称为组合：组合是Go语言中面向对象编程的核心。Go语言使用“组合”实现了其他面向对象语言中的继承机制：如果一个结构体获得了匿名成员的全部成员和方法，那么就可以认为该结构体继承了匿名成员。

### 常见问题

#### 空结构体是否占内存？有什么作用？

空结构体不占内存，如下所示

```go
func main() {
  s := struct{}{}
  size := unsafe.Sizeof(s)
  fmt.Println(size) // 0
}
```

空结构体有几个用途：

1）作为map的value类型，可以模拟一个set数据类型。代码如下：

```go
type Set map[string]struct{}

func main() {
  set := make(Set)
  set["A"] = struct{}{}
  set["B"] = struct{}{}
  set["C"] = struct{}{}
  fmt.Println(len(set)) // 3

  delete(set, "B")
  fmt.Println(len(set)) // 2

  if _, ok := set["A"]; ok {
    fmt.Println("A exists") // A exists
  }
}
```

2）作为channel发送和接收的数据类型。代码如下：

```go
func main() {
  ch := make(chan struct{}, 1)
  go func() {
    <-ch
    // do something
  }()
  ch <- struct{}{}
  // ...
}
```

3）仅有方法的结构体。代码如下：

```go
type Lamp struct{}

func (l *Lamp) Run() { fmt.Println("running") }
```

## 4.5. JSON

JSON（JavaScript Object Notation，JavaScript对象表示法）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML、Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。

Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持（译注：Protocol Buffers的支持由 [github.com/golang/protobuf](http://github.com/golang/protobuf "github.com/golang/protobuf") 包提供），并且这类包都有着相似的API接口。

JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。它可以用有效可读的方式表示int、string等基础数据类型和数组、slice、结构体和map等聚合数据类型。

基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是`\Uhhhh`转义数字来表示一个UTF-16编码，而不是Go语言的rune类。

这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：

```go
boolean         true
number          -273.15
string          "She said \"Hello, BF\""
array           ["gold", "silver", "bronze"]
object          {"year": 1980,
                 "event": "archery",
                 "medals": ["gold", "silver", "bronze"]}
```

举例，定义一个Movie类型：

```go
type Movie struct {
    Title  string
    Year   int  `json:"released"`
    Color  bool `json:"color,omitempty"`
    Actors []string
}

var movies = []Movie{
    {Title: "Casablanca", Year: 1942, Color: false,
        Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
    {Title: "Cool Hand Luke", Year: 1967, Color: true,
        Actors: []string{"Paul Newman"}},
    {Title: "Bullitt", Year: 1968, Color: true,
        Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
}

```

编码是把Go语言中的数据结构编码为JSON对象， 在Go语言中一般叫做marshal。编码操作可以使用`json.Marshal`函数：该函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进（换行以便于显示）。

例如：

```go
data, err := json.Marshal(movies)
if err != nil {
    log.Fatalf("JSON marshaling failed: %s", err)
}
fmt.Printf("%s\n", data)

// output
[{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingr
id Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Ac
tors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"
Actors":["Steve McQueen","Jacqueline Bisset"]}]
```

为了生成便于阅读的格式，`json.MarshalIndent`函数可以产生有缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：

在编码结构体时，Go语言默认使用结构体成员的名字作为JSON的对象（通过reflect反射技术）。注意，只有导出的结构体成员才会被编码，这也是为什么我们选择用大写字母开头的名称的原因。

另外，在编码后，Year成员的名字变成了released，还有Color成员的名字变成了color。这是因为Movie结构体使用了成员Tag：

```go
Year  int  `json:"released"`
Color bool `json:"color,omitempty"`
```

说明：

-   结构体成员Tag是用于描述结构成员的元信息字符串，可以在编译阶段关联到对应的成员。
-   结构体成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的`key:"values"`键值对序列，其中`values`以逗号分隔；因为值中含有双引号字符，因此成员Tag用原生字符串面值的形式书写。
-   不同的key可以定义不同的行为。比如，json键对应的值用于控制`encoding/json`包的编码和解码的行为。
    -   `json:"released"`：json键对应的值的**第一部分**用于指定JSON对象的名字，比如Movie结构体中的Year成员对应到JSON中的released对象。
    -   `json:"color,omitempty"`：omitempty的作用是如果成员为空或零值，就不生成对应的JSON对象。
    -   `json:"-"`：忽略该成员，不生成JSON对象。

编码的逆操作是解码，对应将JSON数据解码为Go语言中的数据结构，在Go语言中一般叫unmarshal。解码操作通过`json.Unmarshal`函数完成，该函数需要一个字节slice和一个变量地址，用于接收解码后的数据。

例如：

```go
var titles []struct{Title string}
if err := json.Unmarshal(data, &titles); err != nil {
    log.Fatalf("JSON unmarshaling failed: %s", err)
}
fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
```

JSON已经被广泛用于web中：许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。

对于流式数据，Go语言提供了基于流式的解码器`json.Decoder`，可以从一个输入流解码JSON数据；对应的编码器是`json.Encoder`，可以从一个输出流编码JSON数据。

# 5. 函数

***

## 5.1. 函数

### 5.1.1. 函数声明

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。：

```go
func name(parameter-list) (result-list) {
    body
}

```

说明：

-   形式参数列表`parameter-list`描述了函数的参数名以及参数类型，可以简称为形参。这些参数作为函数局部变量，其值由函数调用者提供。
-   返回值列表`result-list`描述了函数返回值的变量名以及类型，其中变量名可以省略。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。
-   如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。

函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名。

函数调用必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参。

在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。

实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice、map、function、channel等类型，实参可能会由于函数的间接引用被修改。

### 5.1.2. 递归

函数递归是指函数可以直接或间接的调用自身。对许多问题而言，递归是一种强有力的技术，例如处理相同的算法问题、处理递归的数据结构。

大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加（初始时很小），所以在使用递归时不必考虑溢出和安全问题。

### 5.1.3. 多返回值

在Go语言中，一个函数可以返回多个值。许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。

调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量。如果某个值不被使用，可以将其分配给下划线标志符。

```go
res, err := func(args)
res, _ := func(args)
```

如果函数的返回值类型相同，或返回值多于2个，最好给函数返回值进行命名。虽然良好的命名很重要，但没有必要为每一个返回值都取一个适当的名字。按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息。

如果函数所有的返回值都有显式的变量名，那么该函数的return语句可以后面的返回值。这称之为bare return。当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。所以不宜过度使用bare return。

### 5.1.4. 可变参数

参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。

在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。注意，可以参数只能是参数列表中的最后一个参数。

举例，sum函数返回任意个int型参数的和。在函数体中，vals被看作是类型为\[] int的切片。sum可以接收任意数量的int型参数。

```go
func sum(vals ...int) int {
    total := 0
    for _, val := range vals {
        total += val
    }
    return total
}

fmt.Println(sum())           // "0"
fmt.Println(sum(3))          // "3"
fmt.Println(sum(1, 2, 3, 4)) // "10"
```

在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。

另外，可变参数函数也可以接收一个切片，只需要在参数后加上省略符即可。

```go
values := []int{1, 2, 3, 4}
fmt.Println(sum(values...)) // "10"
```

虽然在可变参数函数内部，`...int `型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。

## 5.2. 函数值

在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。例子如下：

```go
func square(n int) int { return n * n }
func negative(n int) int { return -n }
func product(m, n int) int { return m * n }

func main() {
    f := square
    fmt.Println(f(3)) // "9"
    
    f = negative
    fmt.Println(f(3))     // "-3"
    fmt.Printf("%T\n", f) // "func(int) int"
}
```

函数类型的零值是nil，函数值可以与nil比较，调用值为nil的函数值会引起panic错误。

```go
var f func(int) int
fmt.Println(f == nil, f != nil) // true, false
f(3) // 此处f的值为nil, 会引起panic错误

```

但是函数值之间是不可比较的，也不能用函数值作为map的key。

## 5.3. 匿名函数

拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可以绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。

函数字面量允许我们在使用函数时才定义它。举例，

```go
strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")

```

更重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量。举例，

```go
// squares返回一个匿名函数。
// 该匿名函数每次被调用时都会返回下一个数的平方。
func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // "1"
    fmt.Println(f()) // "4"
    fmt.Println(f()) // "9"
    fmt.Println(f()) // "16"
}
```

函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。

这个例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，通常也可以把函数值叫做闭包。

另外，通过这个例子，也可以看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。

## 5.4. 错误

对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I/O操作的函数都会面临出现错误的可能，即使是简单的读写。

在Go的错误处理中，对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。

Go语言使用了error类型来表示错误。它是内建的接口类型：

```go
type error interface {
    Error() string
}
```

error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，可以通过调用error.Error方法来获得字符串类型的错误信息。

```go
res, err := func()
fmt.Println(err.Error())
```

通常，当函数返回non-nil的error时，其他的返回值是未定义的（undefined），这些未定义的返回值应该被忽略。然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。

在Go语言中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制（panic），但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。

Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。

正因此，Go使用控制流机制（如if和return）处理错误，这使得编码人员能更多的关注错误处理。

### 5.4.1. 错误处理策略

当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的五种方式。

1）最常用的方式是传播错误。举例：

```go
resp, err := http.Get(url)
if err != nil{
    return nil, err
    // return nil, fmt.Errorf("getting %s: %v", url, err)
}

```

传播错误时，可以直接返回原本的错误，也可以使用fmt.Errorf添加额外的信息。由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。

另外，编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。

2）如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重试。

3）如果错误发生后，程序无法继续运行，应该输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。

举例，

```go
func main() {
    ...
    if err := WaitForServer(url); err != nil {
        log.Fatalf("Site is down: %v\n", err)
    }
}

```

4）如果错误不影响后续逻辑，输出错误信息就足够了，不需要中断程序的运行。

5）如果错误根本不需要任何处理，可以直接忽略掉错误。

在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。

### 5.4.2. 文件结尾错误（EOF）

考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义：

```go
package io

import "errors"

// EOF is the error returned by Read when no more input is available.
var EOF = errors.New("EOF")
```

调用者只需通过简单的比较，就可以检测出这个错误。下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。

```go
in := bufio.NewReader(os.Stdin)
for {
    r, _, err := in.ReadRune()
    if err == io.EOF {
        break // finished reading
    }
    if err != nil {
        return fmt.Errorf("read failed:%v", err)
    }
    // ...use r…
}
```

因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的错误信息。

## 5.5. defer延迟调用

defer用于延迟调用某个函数或方法，只需要在调用函数或方法前加上关键字defer。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数或方法才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。在一个函数中可以执行多条defer语句，它们的执行顺序与声明顺序相反。

defer语句通常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。另外，释放资源的defer语句应该直接跟在请求资源的语句后。

举例，关闭一个文件：

```go
package ioutil
func ReadFile(filename string) ([]byte, error) {
    f, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    defer f.Close()
    return ReadAll(f)
}

```

defer语句中的函数会在return语句更新返回值变量后再执行，再加上在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，可以使用defer机制和匿名函数来观察一个函数的有名返回值，甚至可以修改函数返回给调用者的返回值。

举例：

```go
func double(x int) (result int) {
    defer func() { fmt.Printf("double(%d) = %d\n", x,result) }()
    return x + x
}

func triple(x int) (result int) {
    defer func() { result += x }()
    return double(x)
}

func main() {
    _ = double(4) // "double(4) = 8"
    
    fmt.Println(triple(4)) // 12
}
```

需要注意的是，不要在循环体中使用defer语句。因为只有在函数执行完毕后，这些被延迟的函数才会执行。比如，下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。

```go
for _, filename := range filenames {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close() // NOTE: risky; could run out of file descriptors
    // ...process f…
}
```

解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。

## 5.6. panic异常

Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起panic异常。

一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。

不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：

```go
switch s := suit(drawCard()); s {
case "Spades":                                // ...
case "Hearts":                                // ...
case "Diamonds":                              // ...
case "Clubs":                                 // ...
default:
    panic(fmt.Sprintf("invalid suit %q", s)) // Joker?
}
```

虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。但是对于大部分程序中的错误，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。

## 5.7. recover捕获异常

recover函数可以用来捕获同一个goroutine发生的panic异常。通常来说，不应该对panic异常做任何处理，但有时可以从异常中恢复，或者在程序崩溃前做一些操作。

如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。

举例，recover函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。

```go
func Parse(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover(); p != nil {
            err = fmt.Errorf("internal error: %v", p)
        }
    }()
    // ...parser...
}
```

不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。安全的做法是有选择性的recover。换句话说，只恢复应该被恢复的panic异常，但是这些异常所占的比例应该尽可能的低。

为了标识某个panic是否应该被恢复，可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理。

# 6. 方法

***

## 6.1 方法声明

在函数声明时，在其名字之前放上一个变量，即是一个方法声明，相当于为这种类型定义了一个独占的方法。注意，声明方法必须和对应的类型在同一个命名空间。

举个例子：

```go
package geometry

import "math"

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

上面的代码里那个附加的参数p，叫做**方法的接收器（receiver）**，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。

在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：

```python
p := Point{1, 2}
q := Point{4, 6}
fmt.Println(Distance(p, q)) // "5", function call
fmt.Println(p.Distance(q))  // "5", method call

```

可以看到，上面的两个函数调用都是Distance，但是却没有发生冲突。第一个Distance的调用实际上用的是包级别的函数geometry.Distance，而第二个则是使用刚刚声明的Point，调用的是Point下声明的Point.Distance方法。

这种p.Distance的表达式叫做**选择器**，因为会选择p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义。

对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名。

## 6.2. 基于指针对象的方法

## 6.3. 通过嵌入结构体来扩展类型

## 6.4. 方法值和方法表达式

# 7. 接口

***

## 常见面试题

### interface{}类型的变量可以互相比较吗 ？

在Go 语言中，interface底层实现包含了 2 个字段，类型 `T` 和 值 `V`。

interface{}类型的变量可以使用 `==` 或 `!=` 比较。相等有以下 2 种情况：

-   第一种情况是，两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）。
-   第二种情况是，类型 T 相同，且对应的值 V 相等。

代码如下，

```go
type Stu struct {
  Name string
}

func main() {
  var a interface{} = nil
  var b interface{} = nil
  var c interface{} = int(10)
  fmt.Println(a == nil) // true
  fmt.Println(b == nil) // true
  fmt.Println(c == nil) // false
  fmt.Println(a == b)   // true
  fmt.Println(a == c)   // false

  var stu1, stu2 interface{} = Stu{"Tom"}, Stu{"Tom"}
  var stu3, stu4 interface{} = &Stu{"Tom"}, &Stu{"Tom"}
  fmt.Println(stu1 == stu2) // true
  fmt.Println(stu3 == stu4) // false
}
```

对于`stu1` 和 `stu2` ，二者的类型是 `Stu`，值是 Stu 结构体，且各字段相等，因此结果为 true。

对于`stu3` 和 `stu4` ，二者的类型是 `*Stu`，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。

### 不同的nil之间可以互相比较吗？

nil是有类型的，不同的nil比较有两种情况。

1）相同引用类型nil是相等的，而不同引用类型的nil是根本无法比较的，编译器会直接报错。比如，\*int32类型的nil和\*int64类型的nil根本无法比较。

代码如下所示：

```go
func main() {
  var a *int32
  var a2 *int32
  var b *int64
  fmt.Println(a == nil, a == a2) // true, true
  fmt.Println(b == nil)          // true
  fmt.Println(a == b)            // invalid operation: cannot compare a == b (mismatched types *int32 and *int64)
}
```

2）如果nil是interface{}类型的，那么就可以和其他引用类型（比如\*int）的nil进行比较，比较结果是不相等。

代码如下所示：

```go
func main() {
  var interNil interface{} = nil
  var interNil2 interface{} = nil
  var intNil *int = nil
  fmt.Println(interNil == nil)        // true
  fmt.Println(interNil == interNil2)  // true
  fmt.Println(intNil == nil)          // true
  fmt.Println(interNil == intNil)     // false
  
  fmt.Println(interNil == interface{}(intNil)) // false
  fmt.Println(interface{}(intNil) == nil)      // false
}
```

对于`interNil == intNil`，可以认为在比较之前做了一次转换，相当于`interNil == interface{}(intNil)`。由于后者的类型T不为空，所以后者根本不等于nil，二者比较的结果也就是不相等。

这里有一个nil陷阱，代码演示如下：

```go
func main() {
  f := foo()
  if f != nil {
    fmt.Println("f is not nil")
  }
}

func foo() interface{} {
  var num *int
  return num
}
```

解释：\*int类型的nil在经过interface{}转换之后不等于nil，所以不要在业务中写出这样的代码。

# 8. 包和工具



# 9. 测试



