# 介绍

> https://doc.rpcx.io/

远程过程调用（Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。

# 标准RPC

# gRPC

> https://grpc.io/ https://doc.oschina.net/grpc

gRPC是Google开发的高性能、通用的开源RPC框架，基于HTTP/2协议和ProtoBuf(Protocol Buffers)序列化协议，而且支持多种开发语言。 它的目标是跨语言开发，但是基于gRPC框架开发应用需要额外的开发，比如服务治理方面需要自己去实现。Google内部使用的也不是gRPC，而是Stubby。、

gRPC的优点包括：

- 跨语言：跨语言，且自动生成sdk。
- 性能高：比如protobuf性能高于json，比如HTTP/2性能高于HTTP/1.x。
- 强类型：编译器帮助解决类型问题。
- 支持流式处理：基于HTTP/2，支持客户端流式，服务端流式，双向流式。

gRPC 支持四种服务方法：

- 单项 RPC，即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。
- 服务端流式 RPC，即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。
- 客户端流式 RPC，即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。
- 双向流式 RPC，即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。

## HTTP/2

### 二进制分帧

HTTP/2 使用二进制分桢传输数据，而非 HTTP/1.x 的文本格式传输。文本的表现形式比较复杂，而二进制格式简单，只有0和1。

HTTP/2 会把传输的数据分割为更小消息和帧，并采用二进制格式的编码 ，其中首部信息会被封装到头部（Headers）帧，请求体被封装到数据（Data）帧里面。

由于分帧的机制，这些帧就可以乱序发送，然后根据每个帧首部的流标识符号进行组装。

对于HTTP/1.x，传输数据使用文本格式，比如通过换行符分割每一条key:value。这样会有有以下问题：

- 一次只能处理一个请求或者响应，因为对于这种以分隔符分割消息的文本数据，在完成之前不能停止解析。
- 解析这种数据无法预知需要多少内存，会给服务端有很大压力。

### 多路复用

多个请求可以在同一个连接上并行执行。即使某个请求任务耗时严重，不会影响到其它连接的正常执行。

对于HTTP/1.*来说，请求响应模型是阻塞的，即一个请求处理完才能处理后面的请求，一旦某个请求超时等，后续请求只能被阻塞，也就是人们常说头阻塞。

如下图所示：

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311252132279.webp)

另外，多路复用减少了TCP连接，

- 降低服务端和客户端对于内存、CPU的消耗。
- 避免频繁触发重新建立TCP连接，这样就不会频繁有慢启动。
- 在一定程度上可以缓解网络拥塞的情况。

为什么HTTP/1.x不能实现多路复用而HTTP/2可以？

- 因为HTTP/1.x传输是用的文本，而HTTP/2用的是二进制分帧传输。

### 头部压缩

- 固定字段压缩：HTTP/2可以通过http对body进行gzip压缩，这样可以节省带宽，但是报文中header也有很多字段没有进行压缩，比如cookie， user agent accept，这些有必要进行压缩
- 避免重复：大量请求和响应的报文里面又很多字段值是重复的，所以有必要避免重复性
- 编码改进：字段是ascii编码，效率低，改成二进制编码可以提高

### **服务器主动推送资源**

HTTP/2支持服务器主动推送资源，则可以省去一部分请求。

如果客户端要请求两个文件资源，对于HTTP/1.x，客户端需要发送两次不同的请求，然后接收两次服务端的响应。但是，对于HTTP/2，客户端可以只请求一次，然后服务端直接返回两次响应。

## protobuf

Protocal Buffer（简称protobuf）是是一种IDL（Interface Description Language）语言，由Google开发的序列化协议，用于在不同服务之间进行数据通信。常见的序列化协议还有JSON，XML等。

protobuf的特点包括：

- 序列化之后的数据体积小：
  - 没有分隔符：不需要分隔符（逗号，双引号等）就能分隔字段。
  - 空字段省略：如果一个字段的值为空，那么该字段不会存在于序列化后的数据中，即不参与序列化，而JSON会序列化这个字段，并附上一个空值。
  - 使用tag标识：通过把字段的tag转换成二进制格式，来标识一个字段，比JSON使用字符串格式节省空间。
- 编解码快：使用tag存储了字段类型，可以直接知道value的长度，或者当value是字符串的时候，则用length存储了长度，可以直接从length后取n个字节就是value的值，而如果不知道value的长度，我们就必须要做字符串匹配。

### protobuf底层编码

protobuf使用了varint 和 zigzag编码方式。

TODO

# rpcx

> https://github.com/smallnest/rpcx

rpcx号称是Go语言中最好的微服务框架之一。