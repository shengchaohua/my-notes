[TOC]









# 前言
> [计算机网络 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)

> [深入浅出TCP/IP协议栈](https://www.cnblogs.com/onepixel/p/7092302.html)

> [协议地图](http://www.023wg.com/message/message/cd_feature_cover.html)

# 介绍
计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。

OSI模型（Open Systems Interconnection model）是一种概念模型，该模型将计算网络定义为七层，由上到下分别是应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。

现实中通常使用五层模型，由上到下分别是应用层、运输层、网络层、数据链路层和物理层。
- 应用层（Application layer）：应用层的作用是为网络应用定义进程间通信的规则。不同的网络应用需要不同的协议。应用层包括DNS、HTTP、FTP、SMTP等协议。应用层交互的数据单元被称为**报文**。
- 运输层（Transport layer，也称为传输层）：运输层的作用是为两台主机中进程之间的通信提供通用的数据传输服务，把应用层产生的报文封装后进行传输。运输层有复用和分用的功能。复用就是应用层中的多个进程可同时使用运输层的服务传送报文。分用和复用相反，是运输层把收到的不同信息交付给应用层中对应的进程。运输层主要使用两种协议：TCP和UDP，二者传输的数据单元分别被称为**报文段**和**用户数据报**。
- 网络层（Network layer）：网络层的作用是为不同网络的主机通信提供路由选择和数据转发的服务，把运输层产生的报文段或用户数据报封装成**IP数据报**（IP Datagram）进行传输。网络层定义了网络地址和地址分段，可以通过主机的IP地址获取对应的MAC地址。网络层协议包括IP、ARP、路由协议等协议。网络层也叫做IP层。
- 数据链路层（Data link layer）：数据链路层的作用是将网络层交下来的IP数据报封装成帧（Frame），在两个相邻节点间的链路上进行传输。每一帧包括数据和必要的控制信息（如同步信息，地址信息等）。数据链路层通常还提供错误检测和纠正机制。
- 物理层（Physical layer）：物理层的作用是在相邻计算机节点之间传输比特流，尽可能屏蔽掉具体传输介质和物理设备的差异。物理层实际上是规定了物理设备在连接网络时的各种规格以及工作方式。

TCP/IP协议是互联网中相关的各类协议族的总称，比如TCP，UDP，IP，FTP，HTTP，ICMP，SMTP等都属于TCP/IP族内的协议。

TCP/IP协议的基本框架如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030105533.png?token=AE4F4YPY37D4KV54XLMDNL27TOAT6" alt="计算机网络TCP&IP协议框架"  />


# 应用层
## SSH
SSH（Secure Shell，安全外壳协议）是建立在应用层基础上的安全协议，可以为远程登录和其他网络服务提供安全性保证。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。


## Telnet
Telnet协议是一种应用层协议，用于实现远程登录的功能。远程登录允许用户与远程计算机进行动态交互，即用自己的键盘，鼠标等输入设备操纵远程计算机，运行远程计算机上的软件，在自己的显示器上了解运行情况，查看运行结果。

使用Telnet登录进入远程计算机系统时，事实上启动了两个程序：一个是Telnet客户程序，运行在本地主机上；另一个是Telnet服务器程序，它运行在远程计算机上。

本地主机上的客户程序主要完成以下功能：
- 建立与远程服务器的TCP连接。
- 从键盘上接收本地输入的字符。
- 将输入的字符串变成标准格式并传送给远程服务器。
- 从远程服务器接收输出的信息。
- 将该信息显示在本地主机屏幕上。

远程主机的服务器程序用于等待本地主机的请求，一接到请求，远程主机就会活跃起来，并完成以下功能：
- 建立与客户端的TCP连接。
- 等候本地主机输入命令。
- 对本地主机的命令作出反应（如显示目录内容，或执行某个程序等）。
- 把执行命令的结果送回本地计算机显示。
- 重新等候本地主机的命令。


## DNS
DNS（Domain Name System，域名系统）是一种应用层协议，提供了一个将域名和IP地址相互映射的分布式数据库，用于转换域名和对应的IP地址。域名就是上网时输入的链接，IP地址是用来标识互联网中的电脑。正常来说，输入IP也能访问对应的网站，但是IP地址不太好记，所以就产生了域名，能够使人更方便的访问互联网。

DNS使用的运输层协议是UDP。

DNS服务是分布式实现的，大量的域名服务器分布在世界各地。域名服务器由四类：根域名服务器、顶级域名服务器、授权域名服务器、本地域名服务器。

通过域名获得IP的途径有两种方法：第一，查询浏览器当前的缓存。第二，询问域名服务器。因为DNS服务做了分布式处理，询问域名服务器有两种方式：递归查询和迭代查询。大部分情况下，两种方式会结合使用，本地采用递归，其他采用迭代。


## FTP
FTP（File Transfer Protocol，文件传输协议）是一种应用层协议，使用客户端/服务器架构，用于实现计算机之间的文件传输功能。

FTP协议包括两个组成部分，一是FTP服务器，二是FTP客户端，其中服务器用来存储文件，客户端用来访问服务器。

FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而，用户并不需要真正登录到自己想要存取的计算机上面，可以用FTP访问远程资源，实现传输文件、管理目录等。在开发网站的时候，程序员通常使用FTP把网页或程序传到Web服务器上。

FTP使用的运输层协议是TCP而不是UDP，客户端在和服务器建立连接前要经过“三次握手”的过程， 保证客户端与服务器之间的连接是可靠的，为数据传输提供可靠保证。


## SMTP
SMTP（Simple Mail Transfer Protocol，简单邮件传送协议）是一种可靠且有效的电子邮件传输协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于计算机之间的邮件传递和信件通知。

SMTP重要的特性之一是它能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络上计算机之间的邮件传输，也可以通过中继器或网关实现某计算机与其它网络之间的邮件传输。具有域名服务系统（DNS）功能的邮件交换服务器还可以用来识别出传输邮件的下一跳IP地址。

SMTP是一个基于“推送”的协议，它不允许客户端根据需要从远程服务器上“拉取”消息。要做到这点，邮件客户端必须使用POP3或IMAP。


## HTTP
> [计算机网络之HTTP、HTTPS、HTTP2](https://blog.csdn.net/striveb/article/details/91585050)

> [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?)


HTTP（HyperText Transfer Protocol，超文本传输协议）是一种应用层协议，用于从互联网服务器传输超文本到本地浏览器。

HTTP协议的主要特点：
- 简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。常用的请求方法有GET、POST、DELETE等。
- 数据格式灵活：允许传输任意类型的数据对象。
- 无连接：每次连接只处理一个请求（在不使用keep-alive的情况下）。服务器处理完客户的请求，并收到客户的响应后，即断开连接。
- 无状态：对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传。每次的请求都是独立的，它的执行情况与前面的请求和之后的请求没有关系。
- 支持浏览器/服务器（Browser/Server，简称B/S）及客户端/服务器（Client/Server，简称C/S）模式。

HTTP报文格式如下图（来自《图解HTTP》）：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201102135840.png?token=AE4F4YJMYJZ6SWUZUXU6IT27T6QK2" alt="计算机网络 HTTP报文" style="zoom: 67%;" />

### 请求报文
请求报文示例：
```properties
GET / HTTP/1.1
Host: www.baidu.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
Cookie: BIDUPSID=C11E774F28D4E9B2AF4FB7190014FA25; PSTM=1533444426;...

Request body ...
```

第一行是**请求行**，包括请求方法，请求资源地址和HTTP协议版本号，并且用空格分隔。HTTP中的请求方法包括：
- GET：请求获得指定的资源；
- POST：请求更新指定的数据；
- HEAD：只请求页面的首部；
- PUT：请求取代指定文档的内容；
- DELETE：请求删除指定的页面；

最常用的两个请求方法为GET和POST，二者的区别包括：
- 应用场景：GET是查询数据，POST是修改数据；
- 数据传送方式：GET的请求参数在URL中，POST的参数在请求体中；
- 数据传送大小：GET的请求参数是有长度限制的，POST没有限制；
- 数据传送安全性：GET请求不安全，因为请求数据是明文；POST安全性高，可选择是明文还是密文；

HTTP协议版本有三种：HTTP/1.0、HTTP/1.1和HTTP/2.0。HTTP/1.0是最早使用的协议，HTTP/1.1是当前使用最广泛的协议，HTTP/2.0是新一代的协议，并且只能用于HTTPS。

HTTP/1.0和HTTP/1.1的主要区别是：
- 长连接: HTTP/1.1起，默认使用长连接，而HTTP/1.0默认使用短连接。对于短连接，每次请求都要重新建立一次连接。HTTP是基于TCP协议的，建立连接需要三次握手，断开连接需要四次挥手，所以短连接开销会比较大。
- 错误状态响应码：在HTTP/1.1中新增了24个错误状态响应码。
- 缓存处理：HTTP/1.1引入了更多的缓存控制策略。
- 带宽优化及网络连接的使用：HTTP/1.1在请求头引入了range头域，它允许只请求资源的某个部分，以便于充分利用带宽和连接。

HTTP/1和HTTP/2的主要区别是：
- HTTP/2使用了新的二进制格式。HTTP1.x的解析是基于文本的。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性；二进制则不同，只有0和1的组合。
- 多路复用。使用连接共享机制，即多个请求可以共享一个连接。
- header压缩。HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小。

接下来是**请求头部**，该部分用于描述客户端请求的一些信息。请求头部由多行组成，每行有一个键值对。举例：
- User-Agent：产生请求的用户浏览器类型。
- Accept：客户端可识别的内容类型列表。
- Host：请求的主机域名。

接下来是一个空行，再接下来是**请求主体**。

### 响应报文
响应报文示例：
```properties
HTTP/1.1 200 OK
Bdpagetype: 2
Bdqid: 0x871d0df70011f4f1
Cache-Control: private
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Mon, 28 Sep 2020 04:49:55 GMT
Expires: Mon, 28 Sep 2020 04:49:55 GMT
Server: BWS/1.1
Set-Cookie: BDSVRTM=109; path=/
Set-Cookie: BD_HOME=1; path=/
Set-Cookie: H_PS_PSSID=32812_32617_1460_7566_31660_32706_32231_7517_32115_31708_26350; path=/; domain=.baidu.com
Strict-Transport-Security: max-age=172800
Traceid: 160126859528380290669735953323954140401
X-Ua-Compatible: IE=Edge,chrome=1
Transfer-Encoding: chunked

<html>
......
</html>
```

第一行是**状态行**，包括响应HTTP协议的版本号、状态码和响应描述。状态码告知从服务器端返回的请求的状态，由一个三位数组成，可能以1-5为开头。

常用状态码对应的含义：
- 1××：请求处理中，请求已被接受，正在处理
- 2××：请求成功，请求被成功处理
    - 200 OK：客户端请求成功
- 3××：重定向，要完成请求必须进行进一步处理
    - 301 Moved Permanently：永久重定向，使用域名跳转
    - 302 Found：临时重定向，未登陆的用户访问用户中心重定向到登录页面
- 4××：客户端错误，请求不合法
    - 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
    - 401 Unauthorized：请求未经授权
    - 403 Forbidden：服务器收到请求，但是拒绝提供服务
    - 404 Not Found：请求资源不存在，比如输入了错误的URL
- 5××：服务器端错误，服务器不能处理合法请求
    - 500 Internal Server Error：服务器发生不可预期的错误
    - 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
    - 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
    - 504 Gateway Time-out：网关超时，这个有时候Nginx会抛出的异常，主要原因是请求超时，比如你想导出下载某个文件，结果文件太大，就可能请求超时了

接下来是**响应头部**，主要是返回一些服务器的基本信息。响应头部由多行组成，每行有一个键值对。举例：
- Date: 日期
- Server: 服务器类型
- Expires：Cookie过期时间
- Cache-Control: 缓存控制
- Connection: 连接保持，比如keep-alive
- Content-Encoding: 内容编码/压缩格式，比图gzip
- Content-Type: 内容类型，比如text/html;charset=utf-8

接下来是一个空行，再接下来是**响应主体**，可以为任何类型数据，一般返回的是html文件内容。

## HTTPS
> [计算机网络之HTTPS](https://www.cnblogs.com/ChangeMyWorld/p/12610719.html)

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是一个基于HTTP的应用层协议，通过传输加密和身份认证保证了传输过程的安全性，主要用到了对称加密、非对称加密、证书等技术。

HTTP和HTTPS对比图如下：

![计算机网络 HTTP和HTTPS](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110040.png?token=AE4F4YOOJPPJLDITZFCO55S7TOBHC)

SSL（Secure Sockets Layer，安全套接层）及其继任者TLS（Transport Layer Security，运输层安全）是一种为网络通信提供安全及数据完整性的安全协议。SSL/TLS采用了身份验证和数据加密技术，在应用层（HTTP）与运输层（TCP）之间对网络连接进行加密。

HTTPS使用了多种加密方法：
- 对称加密：加密和解密都使用同一个密钥，效率高；
- 非对称加密：加密使用的密钥和解密使用的密钥是不相同的。性能低，安全性高，能加密的数据长度是有限的；
- 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆，如MD5算法；
- 数字签名：在信息的后面加上信息的哈希值，证明信息没有被修改过。哈希值会加密后在和信息一起发送。

客户端和服务器通过SSL建立连接的过程：
1. 客户端发出连接请求。
2. 服务器响应客户，并把证书公钥发送给客户端。证书是是服务器提前配置好的，一个证书包含公钥和私钥等信息。公钥给客户端加密使用，私钥给自己解密使用。
3. 客户端验证证书公钥的有效性。如果有效，客户端会生成一个随机值作为会话密钥，然后用公钥加密这个随机值，发送给服务器。此时使用的是**非对称加密**。
5. 服务器收到数据后，用自己的私钥解密，得到会话密钥。此时使用的是**非对称解密**。
6. 客户端与服务器可以使用这个会话密钥进行通信。发送端发送数据时使用密钥进行加密，接收端接收数据时使用密钥进行解密。此时使用的是**对称加密和对称解密**。另外，加密时通常会使用哈希算法和数字签名。

HTTP和HTTPS的主要区别：
1. HTTP的URL以`http://`起始，默认使用端口80；HTTPS的URL以`https://`起始，默认使用端口443。
2. HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
3. HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，传输的内容都是经过加密的。
4. HTTPS传输的内容需要进行加密解密，会消耗更多的CPU和内存资源。


# 运输层
运输层主要有两种协议：TCP和UDP。

TCP和UDP比较：
协议 | 是否面向连接 | 传输可靠性 | 传输形式 | 传输效率 | 所需资源 |
---|---|---|---|---|---|
TCP | 是 | 可靠 | 字节流 | 慢 | 多
UDP | 否 | 不可靠 | 数据报 | 快 | 少

## TCP
> [理解 TCP（二）：报文结构](https://segmentfault.com/a/1190000008543172)

> [TCP报文格式](http://www.023wg.com/message/message/cd_feature_tcp_message_format.html)

> [TCP检验和](https://www.cnblogs.com/zxiner/p/7203192.html)

TCP（Transmission Control Protocol，传输控制协议 ）提供面向连接的、可靠的数据传输服务。TCP的可靠体现在TCP在数据传输前，会通过三次握手来建立连接；在数据传输中，有数据确认、重传、拥塞控制等机制保证传输成功；在数据传输结束后，会通过四次挥手断开连接，用来节约系统资源。TCP一般用于文件传输、发送邮件、远程登录等场景。

TCP报文段包括首部和数据，首部后面接着数据。TCP报文段如下图所示（图片来自 [TCP报文格式](http://www.023wg.com/message/message/cd_feature_tcp_message_format.html)）：

![计算机网络 TCP报文格式](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110119.png?token=AE4F4YKK37ZCUYW2QC3GAO27TOBJU)

TCP报文段首部包括：
- 源端口（source port）：发送报文的应用程序绑定的TCP端口，占2个字节；
- 目的端口（destination port）：接收报文的应用程序绑定的TCP端口，占2个字节；
- 序号（sequence number）：报文段发送的数据按顺序编号，占4个字节；
- 确认号（acknowledgment number）：确认报文会包含确认号，表示期望收到对方下一个报文段的序号值，占4个字节；
- 数据偏移（data offset）：表示TCP报文段数据开始的位置与TCP报文段起始处的距离，不仅指出了数据开始的位置，还指出了首部长度，占0.5个字节（4位），每位表示4个字节。该位置最小为5（0101），因为首部长度至少占20个字节，此时没有TCP选项；最大为15，因为四个二进制最大表示15（1111），此时首部长度为60个字节，TCP选项为40个字节；
- 保留（reserved）：保留为今后使用，目前为0，占0.75个字节（6位）；
- 标志位（tcp flags）：一共6个标志位，占0.75个字节（6位），每个标志占1位。
    - 紧急标志（URG, urgent）：当URG=1，表示报文段有紧急数据，应尽快传送；
    - 确认标志（ACK, acknowledgement）：当ACK=1，表示报文段是确认报文段，确认号有效；
    - 推送标志（PSH, push）：当PSH=1，表示报文段优先级较高，接收方TCP应该尽快推送给应用程序；
    - 复位标志（RST, reset）：当RST=1，表示TCP连接出现严重错误，需要释放并重新建立连接；
    - 同步标志（SYN, synchronization）：当SYN=1，表示报文段是一个请求连接报文段，也称为同步报文段，三次握手中的第一个报文就是同步报文段；
    - 结束标志（FIN, finish）：当FIN=1，表示报文段的发送方的数据已经发送完毕，要求释放TCP连接；
- 窗口大小（window size）：表示允许对方发送的数据量，告诉对方自己的缓冲区还能容纳多少字节的数据，这样可以控制对方发送数据的速度；
- 检验和（checksum）：由发送端填充，接收端用来检测报文段是否有损坏，占2个字节；
- 紧急指针（urgent pointer）：在标志位URG=1才有效，指出了紧急数据在报文段中的位置；
- 选项（options）：定义一些可选的参数，占0-40个字节；
- 填充（padding）：填充字段，用来补位，使整个首部长度是4字节的整数倍；
- 数据（data）：需要传输的数据；


## UDP
UDP（User Datagram Protocol，用户数据报协议）提供无连接的，不保证可靠性的数据传输服务。在传输数据之前不需要先建立连接，目标主机在收到UDP数据报之后，不需要给出确认。虽然UDP不提供可靠交付，但在某些情况下UDP是最有效的工作方式，比如语音通话、直播等。

UDP数据报包括首部和数据，首部后面接着数据。UDP数据报如下图所示：

![计算机网络 UDP报文格式](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110517.jpg?token=AE4F4YO6APTKZVL4BYPDVSK7TOBYK)

UDP数据报包括：
- 源端口号：发送数据报的应用程序使用的UDP端口，占2个字节（16位）；
- 目的端口号：接收数据报的应用程序使用的UDP端口，占2个字节（16位）；
- 长度：UDP数据报的长度，包括首部和数据，占2个字节（16位），每位表示1个字节。UDP数据报长度最小为8个字节，首部占8个字节，没有数据；最大为65515个字节，首部占8个字节，数据占65507个字节（因为IP数据报携带数据最大为65515个字节，此时IP数据报为65535个字节，IP首部占20个字节）；
- 校验和：检测UDP数据报在传输过程中是否被损坏，占2个字节（16位）；
- 数据：需要传送的数据，大小不定；


## TCP三次握手和四次挥手
> [TCP三次握手和四次挥手通俗理解](https://www.cnblogs.com/jainszhang/p/10641728.html) 

> [两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)


### 三次握手
客户端和服务器刚开始都处于关闭状态。TCP服务器进程先创建传输控制块TCB，准备接收客户端进程的连接请求，此时服务器处于`LISTEN`（监听）状态。

客户端发起连接请求，进入三次握手的过程：

1. 第一次：客户端发出请求建立连接的报文，也叫同步报文，设置同步标志SYN=1和自己的序号seq=x。发送之后，客户端进入`SYN-SENT`状态；
2. 第二次：服务器收到请求报文后，如果同意连接，则发出确认报文，设置确认标志ACK=1和确认序号ack=x+1。该报文还被用来请求客户端的连接，所以需要设置自己的同步标志SYN=1和自己的序号seq=y。发送之后，服务器进入`SYN-RCVD`状态；
3. 第三次：客户端收到确认报文后，还要向服务器发出确认报文，表示自己同意服务器的连接请求，设置确认标志ACK=1和确认序号ack=y+1，同时还要设置自己的序号seq=x+1（和第二次的确认序号相同）。发送之后，客户端进入`ESTABLISHED`（连接已建立）状态。服务器收到确认报文后，也进入`ESTABLISHED`状态。

三次握手的过程如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110556.jpg?token=AE4F4YMQSD2PTQDHHBPNXFK7TOB22" alt="计算机网络 TCP三次握手" style="zoom: 80%;" />


### 四次挥手
客户端和服务器处于连接状态，双方都可能主动释放连接。假设客户端主动发起释放连接请求，进入四次挥手的过程：

1. 第一次：客户端发出请求释放连接的报文，设置结束标志FIN=1和自己的序号seq=u。发送之后，客户端进入`FIN-WAIT-1`（结束等待-1）状态；
2. 第二次：服务器收到请求报文后，发出确认报文，设置确认标志ACK=1和确认序号ack=u+1，同时还要设置自己的序号seq=v。发送之后，服务器进入`CLOSE-WAIT`（关闭等待）状态。客户端收到确认报文后，进入`FIN-WAIT-2`（结束等待-2）状态。
3. 第三次：服务器还可以客户端发送数据，一旦发送完毕，就向客户端发出请求释放连接的报文，设置结束标志FIN=1和自己的序号seq=w，同时还要设置确认标志ACK=1和确认序号ack=u+1（和第二次相同），服务器进入`LAST-ACK`（最后确认）状态；
4. 第四次：客户端收到请求报文后，发出确认报文，设置确认标志ACK=1和确认序号ack=w+1，同时还要设置自己的序号seq=u+1（和第二次的确认序号相同），客户端进入`TIME-WAIT`（定时等待）状态。客户端等待2MSL（Maximum Segment Lifetime，最长报文段寿命）后，进入`CLOSED`状态。服务器收到确认报文后，立刻进入`CLOSED`状态。可以看出，服务器结束连接的时间要早于客户端。

四次挥手的过程如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110638.jpg?token=AE4F4YMR4COS6CUDGMBXNGK7TOB5Q" alt="计算机网络 TCP四次挥手" style="zoom:80%;" />



## TCP如何保证可靠传输

TCP的可靠传输体现在：
- 数据分片：TCP把应用数据分割成适合发送的数据块。
- 数据编号：TCP给发送的每一个报文进行编号，接收方可以对报文段进行排序，丢弃重复的数据，把完整有序的数据传送给应用层。
- 数据到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认。
- 校验和：TCP会计算伪首部、TCP首部和数据的检验和，目的是检测数据在传输过程中是否发生变化。如果接收端的检验和有差错，TCP将丢弃这个报文段。
- 流量控制：TCP使用滑动窗口协议实现网络数据传输的流量控制，该协议允许发送方在停止并等待确认前发送多个数据分组，加快数据传输。
- 拥塞控制：当网络拥塞时，发送端主动减少数据的发送。
- ARQ协议：ARQ的基本原理就是每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。
- 超时重传：当TCP发出一个报文段后，就启动一个定时器，等待接收端的确认报文。如果不能及时收到接收端的确认，发送端将重发这个报文段。


### 流量控制
TCP使用滑动窗口协议实现网络数据传输的流量控制。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

流量控制主要是通过接收端来决定发送端的发送速率。TCP连接的两端都有固定大小的缓冲空间，接收端只允许发送端发送接收端缓冲区能容纳的数据。接收端发送的确认报文有一个窗口字段，可以用来控制发送端发送数据的大小，从而影响发送端的发送速率。如果接收端将窗口字段设置为0，则发送端不能发送数据。


### 拥塞控制
拥塞控制是为了防止过多的数据注入网络，防止网络中的路由器或链路过载。拥塞控制采用了四种算法：
- 慢开始：刚开始发送TCP报文段时，设置拥塞窗口cwnd=1，每次加倍。当到达慢开始门限ssthresh时，改用拥塞避免算法。
- 拥塞避免：拥塞窗口每次加1。当网络出现拥塞时，慢开始门限ssthresh变为当前拥塞窗口cwnd的一半，设置拥塞窗口cwnd=1，开始使用慢开始算法。
- 快重传：当出现三个重复的ACK报文时，直接重传对方尚未接收到的报文段。
- 快恢复：当出现三个重复的ACK报文时，开始使用快恢复算法，将拥塞窗口变为原来的一半，开始使用拥塞避免算法。

在网络层也可以使路由器采用适当的分组丢弃策略，以减少网络拥塞的发生。


### ARQ协议
ARQ（Automatic Repeat Request，自动重传请求）是数据链路层和运输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。



## TCP相关问题
### 为什么是三次握手？可以使用两次握手吗？
三次握手的目的主要是防止已经失效的连接请求报文突然传送到了服务器，产生多次连接的错误。

如果使用的是两次握手建立连接，假设客户端发送了一个请求报文而且没有丢失，只是在网络中滞留了很长时间。客户端迟迟没有收到确认报文，以为服务器没有收到连接请求，就会再发送一个请求报文。如果两个报文最终都到达了服务器，就会建立两个连接，导致不必要的错误和资源的浪费。


### 为什么建立连接是三次握手，关闭连接是四次挥手呢？
三次握手的目的是为了客户端和服务端能够建立可靠的连接，保证双方都能够确认自己和对方的发送与接收是正常的。四次挥手的目的时为了双方能够安全地断开连接，不至于丢失数据。

1. 第一次握手：Client什么都不能确认；Server确认了对方发送正常，自己接收正常
2. 第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：对方发送正常，自己接收正常
3. 第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server 认了：自己发送、接收正常，对方发送、接收正常

在三次握手的第二次握手中，服务器可以把确认标志ACK和请求标志SYN放在同一个报文里发送给客户端，相当于节省了一个报文；但是在四次挥手中，当收到对方请求断开连接的报文时，仅仅表示对方不再发送数据了，但是对方还能接收数据，己方可能还要发送数据给对方，所以己方的确认报文ACK和请求释放连接的报文FIN一般都会分开发送。


### 如果三次握手中第三次的ACK报文丢了，会发生什么？
> [TCP三次握手的第三次的ack包丢失会怎样？](https://blog.csdn.net/gochenguowei/article/details/79649997)

因为第三次的ACK报文丢失，所以服务端迟迟收不到确认报文。此时服务端处于`SYN_RCVD`状态，会根据TCP的超时重传机制，等待3秒、6秒、12秒后重新发送第二次握手的SYN+ACK报文，以便客户端重新发送第三次的ACK报文。

服务端重发的次数默认为5，也可以进行手动设置。如果服务端重发达到指定次数后，仍然没有收到客户端的ACK报文，那么一段时间后，服务端会自动关闭这个连接。

在发出第三次握手的ACK报文后，客户端就进入`ESTABLISHED`，认为连接已建立。如果客户端向服务端发送数据，服务端会回复重置报文（RST=1），客户端才能感知到错误。


### 为什么四次挥手中客户端最后还要等待2MSL？
> [再叙TIME_WAIT](https://blog.huoding.com/2013/12/31/316)

主动关闭TCP连接的一方最后会发送一个ACK报文，进入TIME_WAIT状态，等待2MSL。MSL，最大报文段寿命，指的是报文段的最大生存时间。如果报文段在网络中活动了一个MSL的时间，还没有被接收，那么会被丢弃。

> MSL在RFC 793中是2分钟，但是各个平台的实现不同，有30秒，1分钟和2分钟等情况。以Linux为例，通常是30秒，2MSL就是60秒，并且这个数值是硬编码在内核中的，也就是说除非你重新编译内核，否则没法修改它。

> 为什么主动关闭的一方不直接进入CLOSED状态，而是进入TIME_WAIT状态，并且停留两倍的MSL时长呢？这是因为TCP是建立在不可靠网络上的可靠的协议。主动关闭的一方收到被动关闭的一方发出的FIN包后，回应ACK包，同时进入TIME_WAIT状态，但是因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动断开连接的一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME_WAIT直接进入CLOSED，或者在TIME_WAIT停留的时长不足两倍的MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现一些问题，就可能出现类似下面的问题：
> - 旧的TCP连接已经不存在了，系统此时只能返回RST包
> - 新的TCP连接被建立起来了，延迟包可能干扰新的连接。
> 
> 不管是哪种情况都会让TCP不再可靠，所以TIME_WAIT状态有存在的必要性。

如果主动关闭连接的是客户端：
1. 第一个原因是保证TCP正常关闭连接。客户端需要保证最后一次发送的确认报文能够到达服务器，因为这个报文可能丢失。如果服务器收到确认报文，可以正常断开连接。如果服务器没有收到，客户端可以重发第三次的FIN报文，重启2MSL计时。
2. 第二个原因是防止上一次连接中的包，迷路后重新出现，影响新的连接。因为经过2MSL，上一次连接中所有的重复包都会消失。
3. 第三个原因是处于TIME_WAIT的连接（IP和端口）不能重用，这样可以保证被重新分配的socket不会受到之前残留的延迟重发报文影响。


### 如果服务器出现了大量的CLOSE-WAIT，TIME-WAIT状态，原因可能是什么？
> [一次服务端大量CLOSE_WAIT问题的解决](https://blog.csdn.net/yu616568/article/details/44677985)

> [面试总结之time_wait状态产生的原因，危害，如何避免](https://blog.csdn.net/u013616945/article/details/77510925)

> [Linux服务器 大量的CLOSE_WAIT、TIME_WAIT解决办法](https://www.cnblogs.com/shengs/p/4495998.html)

> [再叙TIME_WAIT](https://blog.huoding.com/2013/12/31/316)

在服务器的维护过程中，可以使用命令来查看TCP连接的各种状态：
```
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```

执行该命令会输出类似的信息：
```
TIME_WAIT 814
CLOSE_WAIT 1
FIN_WAIT1 1
ESTABLISHED 634
SYN_RECV 2
LAST_ACK 1
```

客户端向服务器发送FIN报文，服务器给客户端返回ACK报文后，进入CLOSE-WAIT状态。正常来说，服务器发送完数据后就会向客户端发送FIN报文。如果服务器存在大量CLOSE-WAIT，卡在了这一步，服务器没有发送FIN报文，可能原因是代码写的有问题，比如一个客户端的请求线程访问数据库一直阻塞，但是客户端等待不了太长时间（一般5-10秒就会超时），一旦超时客户端就会断开TCP连接，但是请求线程还在阻塞，服务器就会处于CLOSE-WAIT状态。

TIME-WAIT状态是主动关闭TCP连接的一方最后的状态，在这个状态要等2个MSL，如果没有异常就可以彻底关闭连接。一般来说，客户端主和服务器都可以主动发起连接并主动关闭连接。对于服务器来说，这种情况一般会出现在爬虫服务器和Web服务器。
- 对于爬虫服务器，因为它自身就是客户端，在完成一个爬取任务后就会发起主动关闭连接，从而进TIME_WAIT状态。
- 对于Web服务器，原因可能是服务器存在高并发和短连接，在高并发和短连接的情况下，服务器处理完客户端的请求就会主动关闭连接，如果服务器没有快速回收资源，就会出现大量的TIME-WAIT状态。

解决TIME-WAIT状态过多的方案有很多，通过修改配置文件`/etc/sysctl.conf`，使服务器能够快速回收和重用那些TIME_WAIT的资源：
```python
# 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭  
net.ipv4.tcp_syncookies = 1  
# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  
net.ipv4.tcp_tw_reuse = 1  
# 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  
net.ipv4.tcp_tw_recycle = 1
# 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间  
net.ipv4.tcp_fin_timeout=30
# 控制TIME_WAIT总数
net.ipv4.tcp_max_tw_buckets
```



### 什么是丢包问题？如何解决？
> [TCP 传输协议中如何解决丢包问题](https://www.v2ex.com/t/589783)

TCP协议定义是以一种面向连接的、可靠的、基于字节流的传输层协议。为了保证可靠传输，TCP协议有如下规定：数据分片、数据编号、数据到达确认、超时重传、滑动窗口、数据校验等。

TCP协议本身可以确保传输的数据不会丢失完整性，但是TCP是基于不可靠的网路实现可靠传输，肯定会存在丢包问题。如果在通信过程中，发现缺少数据或者丢包，那么最大的可能性是程序发送过程或者接受过程中出现问题。

比如，服务器向客户端发送大量数据，并且发送频率非常高，客户端来不及处理，因此发送过中可能会出现错误（程序处理逻辑错误；多线程同步问题；缓冲区溢出错误等）。如果服务器不对发送频率进行控制，或者数据进行重发的话，那么客户端收到数据就会少，导致丢失数据。这种现象其实并不是丢包，也不是丢数据，只是因为程序处理有错误，导致有些数据没有成功地被socket发送和接收。

常见的解决方案包括拆包、添加包头和发送组合包。如果服务器或客户端断开连接，一般会使用心跳测试。 心跳测试：每隔一段时间向服务器发送数据包。为了节省资源，通常会发送空数据包。如果发送失败表明套接字已断开，此时需要根据特定条件释放资源并重新连接。

TCP传输可以保证数据交换的可靠性，这意味着一台主机将数据正确地传输到目标计算机，目标计算机的协议栈有一定的限制，如果不及时处理在目标计算机上接收到的数据，堆栈就会溢出。 这种溢出不是由TCP协议本身引起的，而是由系统的IP协议栈的缓冲区溢出引起的。


### 什么是粘包问题？如何解决？
在自顶而下的网络中，应用程序首先要将自己的数据通过套接字发送。应用层交付给TCP的是结构化的数据，结构化的数据到了TCP层做流式传输。

流式数据的最大的问题是没有边界，没有边界就会造成数据粘在一起，这种粘在一起就叫做粘包。

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

粘包问题主要发生在以下情况：
- 由TCP连接复用造成的粘包问题。如果客户端和服务器每次发送数据都建立一个新的连接，然后双方发送完一段数据就关闭连接，这样就不会出现粘包问题。
- TCP默认会使用Nagle算法，该算法会导致粘包问题。Nagle算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。多个分组拼装为一个数据段发送出去，如果没有好的边界处理，在解包的时候会发生粘包问题。
- 数据包过大造成的粘包问题。如果应用进程缓冲区的一条消息的字节的大小超过了发送缓冲区的大小，就有可能产生粘包问题。

粘包问题如何处理：
- 如果是Nagle算法问题导致的，需要结合应用场景适当关闭该算法。
- 其他几种情况的处理方法包括：
    - 尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
    - 头部标记分步接收。在TCP报文的头部加上表示数据长度。
    - 应用层发送数据时定长发送。


### SYN攻击
TCP需要三次握手才能建立连接。SYN攻击是指攻击者（客户端）向服务器发送大量的SYN报文（请求建立连接的报文），服务器回应SYN+ACK报文，但是攻击者不发送最后的ACK报文，无法建立连接，服务器默认利用超时重传机制，重新发送SYN+ACK报文。服务器消耗了大量的内存和CPU，一直尝试建立根本不可能建立的而连接。

如果攻击者处于公网，并且可以伪造IP，服务器就很难根据IP来判断攻击者，给防护带来很大的困难。

从攻击者的角度来看，有两个地方可以提高攻击性：变换端口、伪造IP。变换端口很容易做到，攻击者可以使用任意端口。如果攻击者只是内网IP，是没办法伪造IP的，因为伪造的SYN包会被路由抛弃。如果攻击者是公网IP，则有可能伪造IP，发出SYN包。

从防御者的角度来看，主要有以下的措施：内核参数的调优、防火墙禁止掉部分IP。限制SYN并发数量，在内核里有个队列用来存放还没有确认ACK的客户端请求，当等待的请求数大于`tcp_max_syn_backlog`时，后面的会被丢弃。


### Linux服务器中的一个端口最多可以建立多少个连接？
理论上是无限的，但是会受到Linux允许打开文件的句柄数和计算机内存的限制。

一个TCP连接可以用服务器IP+服务器端口+客户端IP+客户端端口唯一标识，只要服务器IP或者服务器端口不同，就表示不同的连接。

在Linux中，一切都是文件，一个TCP连接也是文件，所以TCP连接的个数受到Linux允许打开文件的句柄数限制。Linux允许打开的最大句柄数默认是65535(`2^16-1`)，可以通过`ulimit -n`查看，也可以通过`ulimit -n xxx`进行手动设置，所以说TCP连接理论上是无限的。因为打开文件需要消耗内存，所以打开文件的最大数量以及TCP连接个数归根到底是根据内存的大小决定的。


# 网络层
## IP
> [IP报文格式详解](https://blog.csdn.net/tianzez/article/details/81004380)

IP（Internet Protocol，网际协议）是TCP/IP体系中的一种网络层协议，提供一种无连接、不可靠的、尽力而为的数据报传输服务。

IP协议定义了网络地址和地址分段。IP地址目前有两个版本，IPv4和IPv6。IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议引入了子网掩码，IP地址和子网掩码通过按位与运算后就可以得到网络地址。

IP数据报包括首部和数据，首部后面接着数据。IP数据报如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110738.png?token=AE4F4YJFSR53XGKAFRJLCHS7TOCBI" alt="计算机网络 IP数据报格式" style="zoom:80%;" />

IP数据报包括：
- 版本号：IP协议的版本，占4位。通信双方使用的IP协议版本必须一致，对于IPv4来说，就是0100。
- 首部长度：首部长度，占4位，每位表示4个字节。该位置最小为5，因为首部长度至少占20个字节；最大为15，因为四个二进制最大表示15，此时首部长度为60个字节，选项占40个字节。
- 服务类型：只有在有QoS差分服务要求时这个字段才起作用，占8位，由3位优先权字段（已弃用），4位TOS字段和1位保留字段（必须置为0）组成。4位TOS分别表示：最小延迟、最大吞吐量、最高可靠性、最小成本。这四者相互冲突，只能选一个。对于SSH/Telnet这样的应用程序，最小延迟比较重要；对于FTP这样的程序，最大吞吐量比较重要。
- 总长度：IP数据报（首部+数据）整体占多少字节，占16位，每位表示1个字节，所以IP数据报最大总长度为`2^16−1=65535`字节，传输的数据最大为`65515`字节，此时IP首部占20个字节。
- 标识：标识主机发送的报文，主机每发一个报文，标识加1，分片重组时会用到该字段。当数据长度超过网络的最大传输单元而必须分片时，这个标识字段的值就被复制到所有的数据报分片的标识字段中。
- 标志位：第一位保留，必须为0；第二位DF，表示能否分分片，0表示可以分片，1表示不能分片；第三位MF，表示是否该报文为最后一片，0表示最后一片，1代表后面还有分片。
- 片偏移：分片重组时会用到该字段。表示较长的分组在分片后，某片在原分组中的相对位置。片偏移以8字节为单位，这就是说除了最后一个分片，每个分片的长度是8字节的整数倍。
- 生存时间：占8位，表示数据报可经过的最多路由数，即数据包在网络中可通过的路由器数的最大值，一般是64。每经过一个路由，TTL就会减1。如果减到0还没有到达，那就丢弃了。这个字段主要是防止出现路由循环。
- 协议：上一层协议，占8位。指出此数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个进程处理。0表示保留，1表示ICMP，6表示TCP，17表示UDP。
- 首部检验和：占16位，只检验数据包的首部，不检验数据部分。这里不采用CRC检验码，而采用简单的计算方法。
- 源地址：表示发送端的IP地址，占32位。
- 目标地址：表示接收端的IP地址，，占32位。
- 选项：可变字段，大小从1字节到40字节不等。
- 填充：把选项填充到4字节的整数倍，全0。    
- 数据：需要传输的数据。


## ARP
> [看完后，搞懂ARP的工作原理，其实并不难！](http://blog.sina.com.cn/s/blog_6bc2727c0102w9ox.html)

ARP（Address Resolution Protocol，地址解析协议）是一个网络层协议，用来根据主机的IP地址获取MAC地址。

ARP首先会发起一个请求数据报，数据报的首部包含了目标主机的IP地址，然后这个数据报会在链路层进行再次包装，生成以太网数据报，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据报，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据报。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。


## 路由协议
路由协议（Routing protocol）是一种路由选择和数据转发的网络层协议。路由协议创建了路由表，描述了网络拓扑结构；路由协议与路由器协同工作，执行路由选择和数据报转发功能。

通过ARP协议的工作原理可以发现，ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议。首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据报；如果不在同一个子网，以太网会将该数据报转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据报转发到目标IP所在的子网中，然后再通过ARP协议获取目标主机的MAC地址，最终也是通过广播形式将数据报发送给接收方。

完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据报。

通过IP地址寻找主机所在的子网，通过MAC地址和广播吧数据发送给对应的主机。


## ICMP
ICMP（Internet Control Message Protocol，因特网控制消息协议）是一个网络层协议，用于在主机和路由器之间传递控制消息。控制消息包括报告错误、交换受限控制和状态信息等，比如网络通不通、主机是否可达、路由是否可用。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

如果遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。

`ping`和`tracert`是两个常用网络管理命令，`ping`用来测试网络可达性，`tracert`用来显示到达目的主机的路径。`ping`和`tracert`都利用ICMP协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。

ICMP是个非常有用的协议﹐尤其是当我们要对网路连接状况进行判断的时候。


### 使用ping时所用到的协议
ping是为了测试另一台主机是否可达，发送一份ICMP回显请求给目标主机，并等待ICMP回显应答。这个过程用到了：
- DNS协议，将ping后接的域名转换为ip地址。DNS使用的传输层协议是UDP。
- ARP解析服务，由ip地址解析出MAC地址，以在数据链路层传输。


# 数据链路层
## ARQ协议
ARQ（Automatic Repeat Request，自动重传请求）是数据链路层和运输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。



# 常见面试题
## 从输入URL到页面加载发生了什么？

> 具体可参考：[前端经典面试题: 从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700)

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

如下图所示（图片来自《图解HTTP》）

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110947.jpg?token=AE4F4YOZM5CIX3VUHSYCSSK7TOCJO" alt="计算机网络 输入URL" style="zoom: 67%;" />




## Cookie和Session的作用和区别？
Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

Cookie的主要作用是通过客户端保存用户的信息。比如：
- 在Cookie中保存已经登录过的用户信息，下次访问网站的时候不需要登陆，访问网站其他页面也不需要重新登录。这是因为用户登录的时候，可以存放一个Token在Cookie中，下次登录的时候只需要根据Token值来查找用户即可。

Session的主要作用是通过服务端记录用户的状态。比如：
- 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的。服务端给特定的用户创建特定的 Session之后就可以标识并跟踪这个用户了。

二者的主要区别：
- Session中保存的是对象，Cookie中保存的是字符串。
- Cookie数据保存在客户端，用户能够找到cookie文件；Session数据保存在服务器端，用户看不到。
- Cookie没有Session安全。如果要在Cookie中存储一些敏感信息，不要直接写入Cookie，最好能将Cookie信息加密，然后使用到的时候再去服务器端解密。
- Session不能区分路径，同一个用户在访问一个网站期间，所有的Session在任何一个地方都可以访问到，而Cookie中如果设置了路径参数，那么同一个网站中不同路径下的Cookie互相是访问不到的。
- Session保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面。Cookie保存在本地，不会影响服务器性能。

