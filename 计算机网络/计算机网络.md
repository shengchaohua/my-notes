[TOC]





# 介绍

> [计算机网络 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md "计算机网络 - JavaGuide")
> [深入浅出TCP/IP协议栈](https://www.cnblogs.com/onepixel/p/7092302.html "深入浅出TCP/IP协议栈")
> [协议地图](http://www.023wg.com/message/message/cd_feature_cover.html "协议地图")

计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。

OSI 模型（Open Systems Interconnection model）是一种概念模型，该模型将计算网络定义为七层，由上到下分别是应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。

现实中，都在使用五层模型，由上到下分别是应用层、运输层、网络层、数据链路层和物理层。

-   应用层（Application layer）：应用层的作用是为网络应用定义进程间通信的规则。不同的网络应用需要不同的协议。应用层包括DNS、HTTP、FTP、SMTP等协议。应用层交互的数据单元被称为**报文**。
-   运输层（Transport layer，也称为传输层）：运输层的作用是为两台主机中进程之间的通信提供通用的数据传输服务，把应用层产生的报文封装后进行传输。运输层有复用和分用的功能。复用就是应用层中的多个进程可同时使用运输层的服务传送报文。分用和复用相反，是运输层把收到的不同信息交付给应用层中对应的进程。运输层主要使用两种协议：TCP和UDP，二者传输的数据单元分别被称为**报文段**和**用户数据报**。
-   网络层（Network layer）：网络层的作用是为不同网络的主机通信提供路由选择和数据转发的服务，把运输层产生的报文段或用户数据报封装成**IP数据报**（IP Datagram）进行传输。网络层定义了网络地址和地址分段，可以通过主机的IP地址获取对应的MAC地址。网络层协议包括IP、ARP、路由协议等协议。网络层也叫做IP层。
-   数据链路层（Data link layer）：数据链路层的作用是将网络层交下来的IP数据报封装成帧（Frame），在两个相邻节点间的链路上进行传输。每一帧包括数据和必要的控制信息（如同步信息，地址信息等）。数据链路层通常还提供错误检测和纠正机制。
-   物理层（Physical layer）：物理层的作用是在相邻计算机节点之间传输比特流，尽可能屏蔽掉具体传输介质和物理设备的差异。物理层实际上是规定了物理设备在连接网络时的各种规格以及工作方式。

TCP/IP协议是互联网中相关的各类协议族的总称，比如TCP，UDP，IP，FTP，HTTP，ICMP，SMTP等都属于TCP/IP族内的协议。

TCP/IP协议的基本框架如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030105533.png?token=AE4F4YPY37D4KV54XLMDNL27TOAT6" alt="计算机网络TCP&IP协议框架"  />

# 应用层

## SSH

SSH（Secure Shell，安全外壳协议）是建立在应用层基础上的安全协议，可以为远程登录和其他网络服务提供安全性保证。利用SSH协议可以有效防止远程管理过程中的信息泄露问题。

## Telnet

Telnet协议是一种应用层协议，用于实现远程登录的功能。远程登录允许用户与远程计算机进行动态交互，即用自己的键盘，鼠标等输入设备操纵远程计算机，运行远程计算机上的软件，在自己的显示器上了解运行情况，查看运行结果。

使用Telnet登录进入远程计算机系统时，事实上启动了两个程序：一个是Telnet客户程序，运行在本地主机上；另一个是Telnet服务器程序，它运行在远程计算机上。

本地主机上的客户程序主要完成以下功能：

-   建立与远程服务器的TCP连接。
-   从键盘上接收本地输入的字符。
-   将输入的字符串变成标准格式并传送给远程服务器。
-   从远程服务器接收输出的信息。
-   将该信息显示在本地主机屏幕上。

远程主机的服务器程序用于等待本地主机的请求，一接到请求，远程主机就会活跃起来，并完成以下功能：

-   建立与客户端的TCP连接。
-   等候本地主机输入命令。
-   对本地主机的命令作出反应（如显示目录内容，或执行某个程序等）。
-   把执行命令的结果送回本地计算机显示。
-   重新等候本地主机的命令。

## DNS

DNS（Domain Name System，域名系统）是一种应用层协议，提供了一个将域名和IP地址相互映射的分布式数据库，用于转换域名和对应的IP地址。域名就是上网时输入的链接，IP地址是用来标识互联网中的电脑。正常来说，输入IP也能访问对应的网站，但是IP地址不太好记，所以就产生了域名，能够使人更方便的访问互联网。DNS使用的运输层协议是UDP。

DNS服务是分布式实现的，大量的域名服务器分布在世界各地。域名服务器由四类：根域名服务器、顶级域名服务器、授权域名服务器、本地域名服务器。

通过域名获得IP的途径有两种方法：第一，查询浏览器当前的缓存；第二，询问域名服务器。因为DNS服务做了分布式处理，询问域名服务器有两种方式：递归查询和迭代查询。大部分情况下，两种方式会结合使用，本地采用递归，其他采用迭代。

## FTP

FTP（File Transfer Protocol，文件传输协议）是一种应用层协议，使用客户端/服务器架构，用于实现计算机之间的文件传输功能。

FTP协议包括两个组成部分，一是FTP服务器，二是FTP客户端，其中服务器用来存储文件，客户端用来访问服务器。

FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而，用户并不需要真正登录到自己想要存取的计算机上面，可以用FTP访问远程资源，实现传输文件、管理目录等。在开发网站的时候，程序员通常使用FTP把网页或程序传到Web服务器上。

FTP使用的运输层协议是TCP而不是UDP，客户端在和服务器建立连接前要经过“三次握手”的过程， 保证客户端与服务器之间的连接是可靠的，为数据传输提供可靠保证。

## SMTP

SMTP（Simple Mail Transfer Protocol，简单邮件传送协议）是一种可靠且有效的电子邮件传输协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于计算机之间的邮件传递和信件通知。

SMTP重要的特性之一是它能跨越网络传输邮件，即“SMTP邮件中继”。使用SMTP，可实现相同网络上计算机之间的邮件传输，也可以通过中继器或网关实现某计算机与其它网络之间的邮件传输。具有域名服务系统（DNS）功能的邮件交换服务器还可以用来识别出传输邮件的下一跳IP地址。

SMTP是一个基于“推送”的协议，它不允许客户端根据需要从远程服务器上“拉取”消息。要做到这点，邮件客户端必须使用POP3或IMAP。

## HTTP

> [计算机网络之HTTP、HTTPS、HTTP2](https://blog.csdn.net/striveb/article/details/91585050 "计算机网络之HTTP、HTTPS、HTTP2")
> [HTTP1.0、HTTP1.1 和 HTTP2.0 的区别](https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A? "HTTP1.0、HTTP1.1 和 HTTP2.0 的区别")
>

HTTP（HyperText Transfer Protocol，超文本传输协议）是一种应用层协议，用于从互联网服务器传输超文本到本地浏览器。

HTTP协议的主要特点：

-   简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。常用的请求方法有GET、POST、DELETE等。
-   数据格式灵活：允许传输任意类型的数据对象。
-   无连接：每次连接只处理一个请求（在不使用keep-alive的情况下）。服务器处理完客户的请求，并收到客户的响应后，即断开连接。
-   无状态：缺少状态意味着如果后续处理需要前面的信息，则它必须重传。每次的请求都是独立的，它的执行情况与前面的请求和之后的请求没有关系。
-   支持浏览器/服务器（Browser/Server，简称B/S）及客户端/服务器（Client/Server，简称C/S）模式。

HTTP报文可以分为请求报文和响应报文，二者的格式如下图所示（来自《图解HTTP》）：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201102135840.png?token=AE4F4YJMYJZ6SWUZUXU6IT27T6QK2" alt="计算机网络 HTTP报文" style="zoom: 67%;" />

### 请求报文

请求报文包括请求首部（Request Header）、一个空行和请求报文主体（Request Body），其中请求首部包括一行请求行和一些请求参数。

#### 请求报文首部

举例：

```http
GET / HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9,zh;q=0.8
Cache-Control: max-age=0
Connection: keep-alive
Host: 127.0.0.1:8000
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36
sec-ch-ua: "Not?A_Brand";v="8", "Chromium";v="108", "Google Chrome";v="108"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"
```

1）请求行

第一行是请求行，包括请求方法，请求资源地址和HTTP协议版本号，并且用空格分隔。

HTTP中的请求方法包括：

-   GET：请求获得指定的资源。
-   POST：请求更新指定的数据。
-   HEAD：只请求页面的首部。
-   PUT：请求取代指定文档的内容。
-   DELETE：请求删除指定的页面。

最常用的两个请求方法为GET和POST，二者的区别包括：

-   应用场景：GET是查询数据，POST是修改数据。
-   数据传送方式：GET的请求参数在URL中，POST的参数在请求体中。
-   数据传送大小：GET的请求参数是有长度限制的，POST没有限制。
-   数据传送安全性：GET请求不安全，因为请求数据是明文；POST安全性高，可选择是明文还是密文。

HTTP协议有多个版本：

-   HTTP/0.9：1991年发布，最早的原型版本，功能简陋。只有一个命令GET，只支持纯文本内容，该版本已过时。
-   HTTP/1.0：1996年发布，支持cache，MIME，method等。
-   HTTP/1.1：1997年发布，当前使用最广泛的协议。
-   HTTP/2：2015年发布，HTTP/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”（frame）：头信息帧和数据帧。另外，HTTP/2只能用于HTTPS。
-   HTTP/3：2022年发布，是HTTP第三个大版本。不像前面的版本依赖TCP进行数据传输，HTTP/3使用了支持多路复用的、建立在UDP基础之上的传输协议QUIC。

2）请求参数

接下来是请求参数，该部分用来描述客户端请求的一些信息。

请求参数由多行组成，每行有一个键值对。比如：

-   User-Agent: 产生请求的用户浏览器类型。
-   Accept: 客户端可识别的内容类型列表。
-   Host: 请求的主机域名。
-   Cache-Control: 请求时是否使用缓存。
-   Connection: 控制TCP连接。

接下来是一个空行，再接下来是请求主体。

#### 请求报文主体

请求主体是任意格式的数据。

### 响应报文

响应报文包括响应首部（Response Header）、一个空行和响应报文主体（Response Body），其中响应首部包括一行状态行和一些请求参数。

#### 响应报文首部

举例：

```http
HTTP/1.1 200 OK
Date: Tue, 31 Jan 2023 11:32:54 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8
```

1）状态行

第一行是**状态行**，包括响应HTTP协议的版本号、状态码和响应描述。状态码告知从服务器端返回的请求的状态，由一个三位数组成，可能以1-5为开头。

常用状态码和响应描述对应的含义：

-   1××：请求处理中，请求已被接受，正在处理。
-   2××：请求成功，请求被成功处理。
    -   200 OK：客户端请求成功。
-   3××：重定向，要完成请求必须进行进一步处理。
    -   301 Moved Permanently：永久重定向，使用域名跳转。
    -   302 Found：临时重定向，未登陆的用户访问用户中心重定向到登录页面。
-   4××：客户端错误，请求不合法。
    -   400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
    -   401 Unauthorized：请求未经授权。比如没有 JWT token。
    -   403 Forbidden：服务器收到请求，但是拒绝提供服务。
    -   404 Not Found：请求资源不存在，比如输入了错误的URL。
-   5××：服务器端错误，服务器不能处理合法请求。
    -   500 Internal Server Error：服务器发生不可预期的错误。
    -   502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。
    -   503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。
    -   504 Gateway Time-out：网关超时，这个有时候Nginx会抛出的异常，主要原因是请求超时，比如你想导出下载某个文件，结果文件太大，就可能请求超时了。

2）响应参数

接下来是响应参数，该部分包含一些服务器的基本信息。

响应参数由多行组成，每行有一个键值对，比如：

-   Date: 日期。
-   Server: 服务器类型。
-   Expires: GMT时间，用来控制资源过期时间。
-   Cache-Control: 缓存控制。
-   Connection: 连接保持，比如keep-alive。
-   Content-Encoding: 内容编码/压缩格式，比如gzip。
-   Content-Type: 内容类型，比如text/html;charset=utf-8。

接下来是一个空行，再接下来是响应主体。

#### 响应报文主体

响应报文主体可以为任何类型数据，一般是HTML文件内容。

### HTTPS

> [计算机网络之HTTPS](https://www.cnblogs.com/ChangeMyWorld/p/12610719.html "计算机网络之HTTPS")

HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是一个基于HTTP的应用层协议，通过传输加密和身份认证保证了传输过程的安全性，主要用到了对称加密、非对称加密、证书等技术。

HTTP和HTTPS对比图如下：

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311251927743.png)

SSL（Secure Sockets Layer，安全套接层）及其继任者TLS（Transport Layer Security，运输层安全）是一种为网络通信提供安全及数据完整性的安全协议。SSL/TLS采用了身份验证和数据加密技术，在应用层（HTTP）与运输层（TCP）之间对网络连接进行加密。

HTTPS 使用了多种加密方法：

-   对称加密：加密和解密都使用同一个密钥，效率高。
-   非对称加密：加密使用的密钥和解密使用的密钥是不相同的。性能低，安全性高，能加密的数据长度是有限的。
-   哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆，如MD5算法。
-   数字签名：在信息的后面加上信息的哈希值，证明信息没有被修改过。哈希值会加密后在和信息一起发送。

客户端和服务器通过SSL建立连接的过程：

1.  客户端发出连接请求。
2.  服务器响应客户，并把证书公钥发送给客户端。证书是是服务器提前配置好的，一个证书包含公钥和私钥等信息。公钥给客户端加密使用，私钥给自己解密使用。
3.  客户端验证证书的有效性。如果有效，客户端会生成一个随机值作为会话密钥，然后用公钥加密这个随机值，发送给服务器。此时使用的是**非对称加密**。
4.  服务器收到数据后，用自己的私钥解密，得到会话密钥。此时使用的是**非对称解密**。
5.  客户端与服务器可以使用这个会话密钥进行通信。发送端发送数据时使用密钥进行加密，接收端接收数据时使用密钥进行解密。此时使用的是**对称加密和对称解密**。另外，加密时通常会使用哈希算法和数字签名。

HTTP和HTTPS的主要区别：

-   HTTP的URL以http起始，默认使用端口80；HTTPS的URL以https起始，默认使用端口443。
-   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
-   HTTP协议运行在TCP之上，传输的内容都是明文。HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，传输的内容都是经过加密的。
-   HTTPS传输的内容需要进行加密解密，会消耗更多的CPU和内存资源。

### HTTP的不同版本

> [https://juejin.cn/post/6995109407545622542](https://juejin.cn/post/6995109407545622542 "https://juejin.cn/post/6995109407545622542")

HTTP目前有多个版本：

-   HTTP/0.9：1991年发布，最早的原型版本，功能简陋。只有一个命令GET，只支持纯文本内容，该版本已过时。
-   HTTP/1.0：1996年发布，支持cache，MIME，method等。
-   HTTP/1.1：1997年发布，当前使用最广泛的协议。
-   HTTP/2：2015年发布，HTTP/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为“帧”（frame）：头信息帧和数据帧。另外，HTTP/2只能用于HTTPS。
-   HTTP/3：2022年发布，是HTTP第三个大版本。不像前面的版本依赖TCP进行数据传输，HTTP/3使用了支持多路复用的、建立在UDP基础之上的传输协议QUIC。

#### HTTP/1.x

HTTP/1.0和HTTP/1.1的主要区别是：

-   长连接：HTTP/1.1默认使用了 Connection: Keep-Alive，也就是使用长连接。在一次请求结束后，连接不会马上关闭，使得下一次请求可以继续使用这个连接。长连接不代表一直不关闭，一段时间后这个连接就会关闭。
    -   HTTP/1.0默认使用短连接。对于短连接，每次请求都要重新建立一次连接。HTTP是基于TCP协议的，建立连接需要三次握手，断开连接需要四次挥手，所以短连接开销会比较大。
-   错误状态响应码：在HTTP/1.1中新增了24个错误状态响应码。
-   缓存处理：HTTP/1.1引入了更多的缓存控制策略。
-   带宽优化及网络连接的使用：HTTP/1.1在请求头引入了range头域，它允许只请求资源的某个部分，以便于充分利用带宽和连接。

#### HTTP/2

HTTP/2的主要特点包括：

-   HTTP/2 基本协议单元是帧，比如 head（头部信息）帧，data（传输数据细信息）帧。
-   HTTP/2 采用二进制传输数据，而非 HTTP/1.x 的文本格式传输。
-   HTTP/2 支持多路复用。多个HTTP请求或响应可以共享一个 TCP 连接。
-   HTTP/2 支持压缩头部。HTTP/1.x的header带有大量信息，而且每次都要重复发送，HTTP/2允许将多个请求压缩成成一个分组，而且在客户端和服务器端分别头部信息建立索引，相同的表头只需要传输索引就可以。

- HTTP/2 支持服务器推送。浏览器请求HTML时，就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"。

1）二进制传输。

HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。

2）多路复用

HTTP/2 支持多路复用，和 HTTP/1.x 对比如下图所示：

![image_HpOQry08zK](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311251924462.png)

多路复用也存在一些缺点：

- 服务器压力上升。多路复用没有限制同时请求数。即使请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增。
- 多路复用容易 Timeout。多路复用导致一个连接内存在多个并行的流，但是网络带宽和服务器资源有限，导致每个流传输的资源会被稀释，导致请求可能超时。

3）安全性

出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。

由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以常见的HTTP/2是加密的。也就是说，互联网上通常所能见到的HTTP/2都是使用HTTPS协议名，运行在TLS上面。

#### HTTP/3

> https://datatracker.ietf.org/doc/html/rfc9114
> [https://juejin.cn/post/6995109407545622542](https://juejin.cn/post/6995109407545622542 "https://juejin.cn/post/6995109407545622542")

HTTP/3 使用了基于 UDP 协议的 QUIC 协议，使 HTTP 运行在 QUIC 协议上而不是 TCP 上。

QUIC 协议有以下特点：

1）实现了类似TCP的流量控制、传输可靠性的功能

-   可插拔：应用程序层面就能实现不同的拥塞控制算法。
-   单调递增的 Packet Number：使用 Packet Number 代替了 TCP 的 seq。
-   不允许 Reneging：一个 Packet 只要被 Ack，就认为它一定被正确接收。
-   更多的 Ack 块和增加 Ack Delay 时间。
-   基于 stream 和 connection 级别的流量控制。

2）实现了快速握手功能

由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。

3）集成了TLS加密功能

目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。

4）多路复用，彻底解决TCP中队头阻塞的问题

和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。

## WebSocket

WebSocket 和 HTTP 都是应用层的协议，建立在TCP之上，通过TCP协议来传输数据。所以，二者都是可靠性传输协议。

1）全双工协议

WebSocket是一种全双工通信的协议。客户端和服务端可以同时发送信息。

HTTP是单向的通信协议。客户端与服务器通信，必须要有客户端发起请求，然后服务器返回结果。

2）持久连接

WebSocket只需建立一次Request/Response消息对，之后都是TCP连接，避免了需要多次建立Request/Response消息对而产生的冗余头部信息。

HTTP 可以使用短连接或长连接。短链接是每次HTTP请求都需要TCP三次握手建立连接，浪费资源。HTTP/1.1 开始默认使用长连接。长连接是在一定的期限内保持TCP连接不断开。

WebSocket 具有低延迟和高效性能，适用于需要快速、实时响应的应用。

## EventSource

> https://blog.csdn.net/DisMisPres/article/details/130539861

EventSource 是一种服务器到客户端的单向通信协议。如果一个响应的首部有 Content-Type:text/event-stream，则此次通信使用了 EventSource协议。

简单来说，客户端首先向服务端发送一个请求，然后从服务端订阅一条“流”，之后服务端可以发送消息给客户端，直到服务端或者客户端关闭该“流”，所以 EventSource 也叫作 SSE (server-sent-event)。

- EventSource 是 HTML5 中的一项 API，用于在客户端和服务器之间建立持久的、单向的通信连接。
- EventSource 基于 HTTP 协议，通过服务器推送的方式向客户端发送实时事件通知。
- 客户端通过添加事件侦听器来捕获事件并执行相应的操作。

EventSource 的优点：

- 简单易用：EventSource 使用简单，基于标准的 HTTP 协议，无需复杂的握手过程。
- 自动重连：EventSource 具有内置的重连机制，确保连接中断后自动重新连接。
- 轻量级：EventSource 使用长轮询机制，消耗的资源相对较少，适合低带宽环境。
- 跨域支持：EventSource 允许在跨域环境下进行通信，通过适当的响应头授权来自不同域的客户端连接。

EventSource 的缺点：

- 单向通信：EventSource 只支持服务器向客户端的单向通信，无法实现客户端向服务器的实时交互。

WebSocket 的优点：

- 双向通信：WebSocket 支持全双工通信，客户端和服务器可以在同一连接上进行双向数据交换。
- 实时性和效率：WebSocket 具有低延迟和高效性能，适用于需要快速、实时响应的应用。
- 大规模应用：WebSocket适用于复杂的、大规模的实时应用，如在线游戏、协同编辑等。

WebSocket 的缺点：

- 复杂性：WebSocket协议的握手过程相对复杂，需要服务器和客户端实现特定的协议逻辑。
- 难以穿越防火墙和代理服务器：WebSocket的特殊协议可能会受到防火墙和代理服务器的限制。

## 常见问题

### HTTP/1.x，HTTP/2 和 HTTPS 的关系

HTTP/2 超文本传输协议第2版，是 HTTP/1.x 的扩展。出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。

HTTPS 使用 SSL/TLS 运输层协议，该协议会对数据进行加密。

HTTP/2 协议本身并没有规定它必须基于 TLS 部署。由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，所以常见的HTTP/2是加密的。也就是说，互联网上通常所能见到的HTTP/2都是使用HTTPS协议名，运行在TLS上面。

没有安全层的 HTTP/2 被称之为 H2C （ HTTP/2 Cleartext ）。

### Keep-Alive 长连接问题

HTTP keep-alive 也称为 HTTP 长连接。它通过重用一个 TCP 连接来发送/接收多个 HTTP请求，来减少创建/关闭多个 TCP 连接的开销。

HTTP 刚开始默认使用短连接。client向server发送一个request，得到response后，连接就关闭。

HTTP/1.0 中默认是关闭的，需要在 HTTP 头加入"Connection: Keep-Alive"，才能启用Keep-Alive。

HTTP/1.1 中默认启用 Keep-Alive，如果加入"Connection: close "，才会关闭。

### 队头阻塞问题

> https://juejin.cn/post/6995109407545622542
> https://blog.csdn.net/lic721/article/details/126978238
> https://blog.csdn.net/weixin_43690495/article/details/117458860

#### HTTP/1.0

在HTTP/1.0中，队头阻塞是指：在同一个TCP通道上，客户端发出的第一个HTTP请求，会阻塞该客户端后续的请求，直到客户端接收完第一个HTTP请求的响应。

如下图所示，请求1发出后，不能立即发出请求2，要等响应1收到后，才能发出请求2。

![在这里插入图片描述](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202402171524579.png)



#### HTTP/1.1

在HTTP/1.1中，队头阻塞是指：在同一个 TCP 通道上，服务端的第一个HTTP响应，会阻塞服务端后续的 HTTP 响应，直到服务端发送完第一个HTTP响应。如下图所示，

![在这里插入图片描述](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202402171545260.png)

和 HTTP/1.0 不太一样，HTTP/1.1 使用了长连接和请求管道化（pipeline）技术，使得客户端可以连续发出多个请求，解决了 HTTP/1.0 中的客户端队头阻塞问题。但是，仍然存在服务端的队头阻塞，因为服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。

#### HTTP/2

HTTP/2 通过在应用层和传输层之间增加一个二进制分帧层，可以在一个 TCP 连接上并行发送多个请求和响应。

HTTP/2 增加了几个概念：

- 流（stream）：已建立连接上的双向字节流。
- 帧（frame）：HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）。
- 消息：与逻辑消息对应的完整的一系列数据帧。

对于一个请求消息和响应消息，HTTP/2 把消息分成多个二进制帧。这些帧可以乱序发送，然后客户端和服务端会根据每个帧头部的流标识符（stream id）重新组装。

举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着 stream id 用来标识所属的数据流。不同消息的帧可以在同一个连接中一起发送，接收方可以根据 stream id 将帧再归属到各自不同的请求当中去。

另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP/2 中可以为每个数据流设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端。

HTTP/2 并没有彻底解决队头阻塞。在HTTP/2中，多个请求是跑在一个TCP管道中的。但是，当出现丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，使用“丢包重传”机制，丢失的包必须要等待重新传输确认，导致整个 TCP 都要开始等待重传丢失的包，就会阻塞该 TCP 连接中的所有请求。而对于 HTTP/1.1 来说，因为可以开启多个 TCP 连接，如果出现丢包情况只会影响其中一个连接，其余的 TCP 连接还可以正常传输数据。

#### HTTP/3

TODO

# 运输层

运输层主要有两种协议：TCP和UDP。

TCP和UDP比较：

| 协议  | 是否面向连接 | 传输可靠性 | 传输形式 | 传输效率 | 所需资源 |
| --- | ------ | ----- | ---- | ---- | ---- |
| TCP | 是      | 可靠    | 字节流  | 慢    | 多    |
| UDP | 否      | 不可靠   | 数据报  | 快    | 少    |

## TCP

> [理解 TCP（二）：报文结构](https://segmentfault.com/a/1190000008543172 "理解 TCP（二）：报文结构")
> [TCP报文格式](http://www.023wg.com/message/message/cd_feature_tcp_message_format.html "TCP报文格式")
> [TCP检验和](https://www.cnblogs.com/zxiner/p/7203192.html "TCP检验和")

TCP（Transmission Control Protocol，传输控制协议 ）提供面向连接的、可靠的数据传输服务。TCP一般用于文件传输、发送邮件、远程登录等场景。

TCP的可靠体现在TCP在数据传输前，会通过三次握手来建立连接；在数据传输中，有数据确认、重传、拥塞控制等机制保证传输成功；在数据传输结束后，会通过四次挥手断开连接，用来节约系统资源。

TCP报文段包括首部和数据，首部后面接着数据。TCP报文段如下图所示（图片来自 [TCP报文格式](http://www.023wg.com/message/message/cd_feature_tcp_message_format.html "TCP报文格式")）：

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311251926648.png)

TCP报文段首部包括：

-   源端口（Source Port）：发送报文的应用程序绑定的TCP端口，占16个比特位（2个字节）。
-   目的端口（Destination Port）：接收报文的应用程序绑定的TCP端口，占2个字节。
-   序号（Sequence Number）：报文段发送的数据按顺序编号，占4个字节。
-   确认号（Acknowledgment Number）：确认报文会包含确认号，表示期望收到对方下一个报文段的序号值，占4个字节。
-   数据偏移（Data Offset）：表示TCP报文段数据开始的位置与TCP报文段起始处的距离，不仅指出了数据开始的位置，还指出了首部长度，占0.5个字节（4位），每位表示4个字节。该位置最小为5（0101），因为首部长度至少占20个字节，此时没有TCP选项；最大为15，因为四个二进制最大表示15（1111），此时首部长度为60个字节，TCP选项为40个字节。
-   保留（Reserved）：保留为今后使用，目前为0，占6个比特位。
-   标志位（TCP Flags）：一共6个标志位，占6个比特位，每个标志占1位。
    -   紧急标志（URG, urgent）：当URG=1，表示报文段有紧急数据，应尽快传送。
    -   确认标志（ACK, acknowledgement）：当ACK=1，表示报文段是确认报文段，确认号有效。
    -   推送标志（PSH, push）：当PSH=1，表示报文段优先级较高，接收方TCP应该尽快推送给应用程序。
    -   复位标志（RST, reset）：当RST=1，表示TCP连接出现严重错误，需要释放并重新建立连接。
    -   同步标志（SYN, synchronization）：当SYN=1，表示报文段是一个请求连接报文段，也称为同步报文段，三次握手中的第一个报文就是同步报文段。
    -   结束标志（FIN, finish）：当FIN=1，表示报文段的发送方的数据已经发送完毕，要求释放TCP连接。
-   窗口大小（Window Size）：表示允许对方发送的数据量，告诉对方自己的缓冲区还能容纳多少字节的数据，这样可以控制对方发送数据的速度。
-   检验和（Checksum）：由发送端填充，接收端用来检测报文段是否有损坏，占2个字节。
-   紧急指针（Urgent Pointer）：在标志位URG=1才有效，指出了紧急数据在报文段中的位置。
-   选项（Options）：定义一些可选的参数，占0-40个字节。
-   填充（Padding）：填充字段，用来补位，使整个首部长度是4字节的整数倍。
-   数据（Data）：需要传输的数据。

## UDP

> [http://www.023wg.com/message/message/cd\_feature\_udp\_message\_format.html](http://www.023wg.com/message/message/cd_feature_udp_message_format.html "http://www.023wg.com/message/message/cd_feature_udp_message_format.html")

UDP（User Datagram Protocol，用户数据报协议）提供无连接的，不保证可靠性的数据传输服务。在传输数据之前不需要先建立连接，目标主机在收到UDP数据报之后，也不需要给出确认。虽然UDP不提供可靠交付，但在某些情况下UDP是最有效的工作方式，比如语音通话、直播等。

UDP数据报包括首部和数据，首部后面接着数据。UDP数据报如下图所示：

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311251926052.png)

UDP数据报包括：

-   源端口号（Source Port）：发送数据报的应用程序使用的UDP端口，占2个字节（16位）。
-   目的端口号（Destination Port）：接收数据报的应用程序使用的UDP端口，占2个字节（16位）。
-   长度（Length）：UDP数据报的长度，包括首部和数据，占2个字节（16位），每位表示1个字节。UDP数据报长度最小为8个字节，首部占8个字节，没有数据；最大为65515个字节，首部占8个字节，数据占65507个字节（因为IP数据报携带数据最大为65515个字节，此时IP数据报为65535个字节，IP首部占20个字节）。
-   校验和（Checksum）：检测UDP数据报在传输过程中是否被损坏，占2个字节（16位）。
-   数据（Data）：需要传送的数据，大小不定。

## TCP三次握手和四次挥手

> [TCP三次握手和四次挥手通俗理解](https://www.cnblogs.com/jainszhang/p/10641728.html "TCP三次握手和四次挥手通俗理解")
> [两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891 "两张动图-彻底明白TCP的三次握手与四次挥手")
>

### 三次握手

客户端和服务器刚开始都处于关闭状态。TCP服务器进程先创建传输控制块TCB，准备接收客户端进程的连接请求，此时服务器处于LISTEN（监听）状态。

客户端发起连接请求，进入三次握手的过程，如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110556.jpg?token=AE4F4YMQSD2PTQDHHBPNXFK7TOB22" alt="计算机网络 TCP三次握手" style="zoom: 80%;" />

第一次：客户端发出请求建立连接的报文，也叫同步报文，设置同步标志SYN=1和自己的序号seq=x。发送之后，客户端进入SYN-SENT状态。

第二次：服务器收到请求报文后，如果同意连接，则发出确认报文，设置确认标志ACK=1和确认序号ack=x+1（客户端发送的序号seq加1）。因为服务器还可以通过该报文请求客户端的连接，所以服务器需要设置自己的同步标志SYN=1和自己的序号seq=y。发送之后，服务器进入SYN-RCVD状态。

第三次：客户端收到确认报文后，还要向服务器发出确认报文，表示自己同意服务器的连接请求，设置确认标志ACK=1和确认序号ack=y+1，同时还要设置自己的序号seq=x+1（和第二次的确认序号相同）。发送之后，客户端进入ESTABLISHED（连接已建立）状态。服务器收到确认报文后，也进入ESTABLISHED状态。

### 四次挥手

客户端和服务器处于连接状态，双方都可能主动释放连接。

假设客户端主动发起释放连接请求，进入四次挥手的过程，如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110638.jpg?token=AE4F4YMR4COS6CUDGMBXNGK7TOB5Q" alt="计算机网络 TCP四次挥手" style="zoom:80%;" />

第一次：客户端发出请求释放连接的报文，设置结束标志FIN=1和自己的序号seq=u。发送之后，客户端进入FIN-WAIT-1（结束等待-1）状态。

第二次：服务器收到请求报文后，发出确认报文，设置确认标志ACK=1和确认序号ack=u+1，同时还要设置自己的序号seq=v。发送之后，服务器进入CLOSE-WAIT（关闭等待）状态。客户端收到确认报文后，进入FIN-WAIT-2（结束等待-2）状态。

第三次：服务器还可以客户端发送数据，一旦发送完毕，就向客户端发出请求释放连接的报文，设置结束标志FIN=1和自己的序号seq=w，同时还要设置确认标志ACK=1和确认序号ack=u+1（和第二次相同），服务器进入LAST-ACK（最后确认）状态。

第四次：客户端收到请求报文后，发出确认报文，设置确认标志ACK=1和确认序号ack=w+1，同时还要设置自己的序号seq=u+1（和第二次的确认序号相同），客户端进入TIME-WAIT（定时等待）状态。客户端等待2MSL（Maximum Segment Lifetime，最长报文段寿命）后，进入CLOSED状态。服务器收到确认报文后，立刻进入CLOSED状态。可以看出，服务器结束连接的时间要早于客户端。

## TCP如何保证可靠传输

TCP的可靠传输体现在：

-   数据分片：TCP把应用数据分割成适合发送的数据块。
-   数据编号：TCP给发送的每一个报文进行编号，接收方可以对报文段进行排序，丢弃重复的数据，把完整有序的数据传送给应用层。
-   数据到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认。
-   校验和：TCP会计算伪首部、TCP首部和数据的检验和，目的是检测数据在传输过程中是否发生变化。如果接收端的检验和有差错，TCP将丢弃这个报文段。
-   流量控制：TCP使用滑动窗口协议实现网络数据传输的流量控制，该协议允许发送方在停止并等待确认前发送多个数据分组，加快数据传输。
-   拥塞控制：当网络拥塞时，发送端主动减少数据的发送。
-   ARQ协议：ARQ的基本原理就是每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。
-   超时重传：当TCP发出一个报文段后，就启动一个定时器，等待接收端的确认报文。如果不能及时收到接收端的确认，发送端将重发这个报文段。

### 流量控制

TCP使用滑动窗口协议实现网络数据传输的流量控制。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

流量控制主要是通过接收端来决定发送端的发送速率。TCP连接的两端都有固定大小的缓冲空间，接收端只允许发送端发送接收端缓冲区能容纳的数据。接收端发送的确认报文有一个窗口字段，可以用来控制发送端发送数据的大小，从而影响发送端的发送速率。如果接收端将窗口字段设置为0，则发送端不能发送数据。

### 拥塞控制

拥塞控制是为了防止过多的数据注入网络，防止网络中的路由器或链路过载。拥塞控制采用了四种算法：

-   慢开始：刚开始发送TCP报文段时，设置拥塞窗口cwnd=1，每次加倍。当到达慢开始门限ssthresh时，改用拥塞避免算法。
-   拥塞避免：拥塞窗口每次加1。当网络出现拥塞时，慢开始门限ssthresh变为当前拥塞窗口cwnd的一半，设置拥塞窗口cwnd=1，开始使用慢开始算法。
-   快重传：当出现三个重复的ACK报文时，直接重传对方尚未接收到的报文段。
-   快恢复：当出现三个重复的ACK报文时，开始使用快恢复算法，将拥塞窗口变为原来的一半，开始使用拥塞避免算法。

在网络层也可以使路由器采用适当的分组丢弃策略，以减少网络拥塞的发生。

### ARQ协议

ARQ（Automatic Repeat Request，自动重传请求）是数据链路层和运输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

## TCP相关问题

### 为什么是三次握手？可以使用两次握手吗？

三次握手的目的主要是防止已经失效的连接请求报文突然传送到了服务器，产生多次连接的错误。

如果使用的是两次握手建立连接，假设客户端发送了一个请求报文而且没有丢失，只是在网络中滞留了很长时间。客户端迟迟没有收到确认报文，以为服务器没有收到连接请求，就会再发送一个请求报文。如果两个报文最终都到达了服务器，就会建立两个连接，导致不必要的错误和资源的浪费。

### 为什么建立连接是三次握手，关闭连接是四次挥手呢？

三次握手的目的是为了客户端和服务端能够建立可靠的连接，保证双方都能够确认自己和对方的发送与接收是正常的。四次挥手的目的时为了双方能够安全地断开连接，不至于丢失数据。

1.  第一次握手：Client什么都不能确认；Server确认了对方发送正常，自己接收正常
2.  第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：对方发送正常，自己接收正常
3.  第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server 认了：自己发送、接收正常，对方发送、接收正常

在三次握手的第二次握手中，服务器可以把确认标志ACK和请求标志SYN放在同一个报文里发送给客户端，相当于节省了一个报文；但是在四次挥手中，当收到对方请求断开连接的报文时，仅仅表示对方不再发送数据了，但是对方还能接收数据，己方可能还要发送数据给对方，所以己方的确认报文ACK和请求释放连接的报文FIN一般都会分开发送。

### 如果三次握手中第三次的ACK报文丢了，会发生什么？

> [TCP三次握手的第三次的ack包丢失会怎样？](https://blog.csdn.net/gochenguowei/article/details/79649997 "TCP三次握手的第三次的ack包丢失会怎样？")

因为第三次的ACK报文丢失，所以服务端迟迟收不到确认报文。此时服务端处于SYN\_RCVD状态，会根据TCP的超时重传机制，等待3秒、6秒、12秒后重新发送第二次握手的SYN+ACK报文，以便客户端重新发送第三次的ACK报文。

服务端重发的次数默认为5，也可以进行手动设置。如果服务端重发达到指定次数后，仍然没有收到客户端的ACK报文，那么一段时间后，服务端会自动关闭这个连接。

在发出第三次握手的ACK报文后，客户端就进入ESTABLISHED，认为连接已建立。如果客户端向服务端发送数据，服务端会回复重置报文（RST=1），客户端也能感知到错误。

### 为什么四次挥手中客户端最后还要等待2MSL？

> [再叙TIME\_WAIT](https://blog.huoding.com/2013/12/31/316 "再叙TIME_WAIT")

主动关闭TCP连接的一方最后会发送一个ACK报文，进入TIME\_WAIT状态，等待2MSL。MSL，最大报文段寿命，指的是报文段的最大生存时间。如果报文段在网络中活动了一个MSL的时间，还没有被接收，那么会被丢弃。

> MSL在RFC 793中是2分钟，但是各个平台的实现不同，有30秒，1分钟和2分钟等情况。以Linux为例，通常是30秒，2MSL就是60秒，并且这个数值是硬编码在内核中的，也就是说除非你重新编译内核，否则没法修改它。

为什么主动关闭的一方不直接进入CLOSED状态，而是进入TIME\_WAIT状态，并且停留两倍的MSL时长呢？

> 这是因为TCP是建立在不可靠网络上的协议。主动关闭的一方收到被动关闭的一方发出的FIN包后，回应ACK包，同时进入TIME\_WAIT状态，但是因为网络原因，主动关闭的一方发送的这个ACK包很可能延迟，从而触发被动断开连接的一方重传FIN包。极端情况下，这一去一回，就是两倍的MSL时长。如果主动关闭的一方跳过TIME\_WAIT直接进入CLOSED，或者在TIME\_WAIT停留的时长不足两倍的MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现一些问题，就可能出现类似下面的问题：
> \- 旧的TCP连接已经不存在了，系统此时只能返回RST包。
> \- 新的TCP连接被建立起来了，延迟包可能干扰新的连接。
> 不管是哪种情况都会让TCP不再可靠，所以TIME\_WAIT状态有存在的必要性。

如果主动关闭连接的是客户端，

1）第一个原因是保证TCP正常关闭连接。客户端需要保证最后一次发送的确认报文能够到达服务器，因为这个报文可能丢失。如果服务器收到确认报文，可以正常断开连接。如果服务器没有收到，客户端可以重发第三次的FIN报文，重启2MSL计时。

2）第二个原因是防止上一次连接中的包，迷路后重新出现，影响新的连接。因为经过2MSL，上一次连接中所有的重复包都会消失。

3）第三个原因是处于TIME\_WAIT的连接（IP和端口）不能重用，这样可以保证被重新分配的socket不会受到之前残留的延迟重发报文影响。

### 如果服务器出现了大量的CLOSE-WAIT，TIME-WAIT状态，原因可能是什么？

> [一次服务端大量CLOSE\_WAIT问题的解决](https://blog.csdn.net/yu616568/article/details/44677985 "一次服务端大量CLOSE_WAIT问题的解决")
> [面试总结之time\_wait状态产生的原因，危害，如何避免](https://blog.csdn.net/u013616945/article/details/77510925 "面试总结之time_wait状态产生的原因，危害，如何避免")
> [Linux服务器 大量的CLOSE\_WAIT、TIME\_WAIT解决办法](https://www.cnblogs.com/shengs/p/4495998.html "Linux服务器 大量的CLOSE_WAIT、TIME_WAIT解决办法")
> [再叙TIME\_WAIT](https://blog.huoding.com/2013/12/31/316 "再叙TIME_WAIT")

在服务器的维护过程中，可以使用命令来查看TCP连接的各种状态：

```bash
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```

执行该命令会输出类似的信息：

```纯文本
TIME_WAIT 814
CLOSE_WAIT 1
FIN_WAIT1 1
ESTABLISHED 634
SYN_RECV 2
LAST_ACK 1
```

CLOSE-WAIT状态是被动关闭TCP连接的一方的状态。如果客户端主动断开连接，客户端向服务器发送FIN报文，服务器给客户端返回ACK报文后，进入CLOSE-WAIT状态。如果服务器存在大量CLOSE-WAIT，说明服务器卡在了这一步，没有发送FIN报文。一个可能的原因是代码有问题，比如一个客户端的请求线程访问数据库一直阻塞，但是客户端等待不了太长时间，一般5-10秒就会超时。一旦超时，客户端就会断开TCP连接，但是因为请求线程还在阻塞，服务器就会处于CLOSE-WAIT状态。

TIME-WAIT状态是主动关闭TCP连接的一方最后的状态，在这个状态要等2个MSL，如果没有异常就可以彻底关闭连接。一般来说，客户端主和服务器都可以主动发起连接并主动关闭连接。对于服务器来说，这种情况一般会出现在爬虫服务器和Web服务器。

-   对于爬虫服务器，因为它自身就是客户端，在完成一个爬取任务后就会发起主动关闭连接，从而进TIME\_WAIT状态。
-   对于Web服务器，原因可能是服务器存在高并发和短连接。在高并发和短连接的情况下，服务器处理完客户端的请求就会主动关闭连接，如果服务器没有快速回收资源，就会出现大量的TIME-WAIT状态。

解决TIME-WAIT状态过多的方案有很多，通过修改配置文件`/etc/sysctl.conf`，使服务器能够快速回收和重用那些TIME\_WAIT的资源：

```.properties
# 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭  
net.ipv4.tcp_syncookies = 1  
# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭  
net.ipv4.tcp_tw_reuse = 1  
# 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭  
net.ipv4.tcp_tw_recycle = 1
# 表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间  
net.ipv4.tcp_fin_timeout=30
# 控制TIME_WAIT总数
net.ipv4.tcp_max_tw_buckets
```

### 什么是丢包问题？如何解决？

> [TCP 传输协议中如何解决丢包问题](https://www.v2ex.com/t/589783 "TCP 传输协议中如何解决丢包问题")

TCP协议是以一种面向连接的、可靠的、基于字节流的传输层协议。为了保证可靠传输，TCP协议有如下规定：数据分片、数据编号、数据到达确认、超时重传、滑动窗口、数据校验等。

TCP协议本身可以确保传输的数据不会丢失完整性，但是TCP是基于不可靠的网路实现可靠传输，肯定会存在丢包问题。如果在通信过程中，发现缺少数据或者丢包，那么最大的可能性是程序发送过程或者接受过程中出现问题。

比如，服务器向客户端发送大量数据，并且发送频率非常高，客户端来不及处理，因此发送过中可能会出现错误（程序处理逻辑错误；多线程同步问题；缓冲区溢出错误等）。如果服务器不对发送频率进行控制，或者数据进行重发的话，那么客户端收到数据就会少，导致丢失数据。这种现象其实并不是丢包，也不是丢数据，只是因为程序处理有错误，导致有些数据没有成功地被socket发送和接收。

常见的解决方案包括拆包、添加包头和发送组合包。如果服务器或客户端断开连接，一般会使用心跳测试。 心跳测试：每隔一段时间向服务器发送数据包。为了节省资源，通常会发送空数据包。如果发送失败表明套接字已断开，此时需要根据特定条件释放资源并重新连接。

TCP传输可以保证数据交换的可靠性，这意味着一台主机将数据正确地传输到目标计算机，目标计算机的协议栈有一定的限制，如果不及时处理在目标计算机上接收到的数据，堆栈就会溢出。 这种溢出不是由TCP协议本身引起的，而是由系统的IP协议栈的缓冲区溢出引起的。

### 什么是粘包问题？如何解决？

TCP协议是以一种面向连接的、可靠的、基于字节流的传输层协议。为了保证可靠传输，TCP协议有如下规定：数据分片、数据编号、数据到达确认、超时重传、滑动窗口、数据校验等。

在自顶而下的网络中，应用程序首先要将自己的数据通过套接字发送。应用层交付给TCP的是结构化的数据，结构化的数据到了TCP层做流式传输。

流式数据的最大的问题是没有边界，没有边界就会造成数据粘在一起，这种粘在一起就叫做粘包。

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

粘包问题主要发生在以下情况：

-   TCP连接复用导致的粘包问题。如果客户端和服务器每次发送数据都建立一个新的连接，然后双方发送完一段数据就关闭连接，这样就不会出现粘包问题。
-   TCP默认会使用Nagle算法，该算法会导致粘包问题。Nagle算法主要做两件事：1）只有上一个分组得到确认，才会发送下一个分组；2）收集多个小分组，在一个确认到来时一起发送。多个分组拼装为一个数据段发送出去，如果没有好的边界处理，在解包的时候会发生粘包问题。
-   数据包过大造成的粘包问题。如果应用进程缓冲区的一条消息的字节的大小超过了发送缓冲区的大小，就有可能产生粘包问题。

粘包问题如何处理：

-   如果是Nagle算法问题导致的，需要结合应用场景适当关闭该算法。
-   其他几种情况的处理方法包括：
    -   尾部标记序列。通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
    -   头部标记分步接收。在TCP报文的头部加上表示数据长度。
    -   应用层发送数据时定长发送。

### SYN攻击

TCP需要三次握手才能建立连接。SYN攻击是指攻击者（客户端）向服务器发送大量的SYN报文（请求建立连接的报文），服务器回应SYN+ACK报文，但是攻击者不发送最后的ACK报文，无法建立连接，服务器默认利用超时重传机制，重新发送SYN+ACK报文。服务器消耗了大量的内存和CPU，一直尝试建立根本不可能建立的而连接。

如果攻击者处于公网，并且可以伪造IP，服务器就很难根据IP来判断攻击者，给防护带来很大的困难。

从攻击者的角度来看，有两个地方可以提高攻击性：变换端口，伪造IP。变换端口很容易做到，攻击者可以使用任意端口。如果攻击者只是内网IP，是没办法伪造IP的，因为伪造的SYN包会被路由抛弃。如果攻击者是公网IP，则有可能伪造IP，发出SYN包。

从防御者的角度来看，主要有以下的措施：内核参数的调优，防火墙禁止掉部分IP，限制SYN并发数量。在内核里有个队列用来存放还没有确认ACK的客户端请求，当等待的请求数大于tcp\_max\_syn\_backlog参数时，后面的会被丢弃。

### Linux服务器中的一个端口最多可以建立多少个连接？

理论上是无限的，但是会受到Linux允许打开文件的句柄数和计算机内存的限制。

一个TCP连接可以用服务器IP+服务器端口+客户端IP+客户端端口唯一标识，只要服务器IP或者服务器端口不同，就表示不同的连接。

在Linux中，一切都是文件，一个TCP连接也是文件，所以TCP连接的个数受到Linux允许打开文件的句柄数限制。Linux允许打开的最大句柄数默认是65535(2^16-1)，可以通过`ulimit -n`查看，也可以通过`ulimit -n xxx`进行手动设置，所以说TCP连接理论上是无限的。因为打开文件需要消耗内存，所以打开文件的最大数量以及TCP连接个数归根到底是根据内存的大小决定的。

# 网络层

## IP

> [IP报文格式详解](https://blog.csdn.net/tianzez/article/details/81004380 "IP报文格式详解")

IP（Internet Protocol，网际协议）是TCP/IP体系中的一种网络层协议，提供一种无连接、不可靠的、尽力而为的数据报传输服务。

IP协议定义了网络地址和地址分段。IP地址目前有两个版本，IPv4和IPv6。IPv4是一个32位的地址，常采用4个十进制数字表示。IP协议将这个32位的地址分为两部分，前面部分代表网络地址，后面部分表示该主机在局域网中的地址。如果两个IP地址在同一个子网内，则网络地址一定相同。为了判断IP地址中的网络地址，IP协议引入了子网掩码，IP地址和子网掩码通过按位与运算后就可以得到网络地址。

IP数据报包括首部和数据，首部后面接着数据。IP数据报如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110738.png?token=AE4F4YJFSR53XGKAFRJLCHS7TOCBI" alt="计算机网络 IP数据报格式" style="zoom:80%;" />

IP数据报包括：

-   版本号：IP协议的版本，占4位。通信双方使用的IP协议版本必须一致，对于IPv4来说，就是0100。
-   首部长度：首部长度，占4位，每位表示4个字节。该位置最小为5，因为首部长度至少占20个字节；最大为15，因为四个二进制最大表示15，此时首部长度为60个字节，选项占40个字节。
-   服务类型：只有在有QoS差分服务要求时这个字段才起作用，占8位，由3位优先权字段（已弃用），4位TOS字段和1位保留字段（必须置为0）组成。4位TOS分别表示：最小延迟、最大吞吐量、最高可靠性、最小成本。这四者相互冲突，只能选一个。对于SSH/Telnet这样的应用程序，最小延迟比较重要；对于FTP这样的程序，最大吞吐量比较重要。
-   总长度：IP数据报（首部+数据）整体占多少字节，占16位，每位表示1个字节，所以IP数据报最大总长度为`2^16−1=65535`字节，传输的数据最大为`65515`字节，此时IP首部占20个字节。
-   标识：标识主机发送的报文，主机每发一个报文，标识加1，分片重组时会用到该字段。当数据长度超过网络的最大传输单元而必须分片时，这个标识字段的值就被复制到所有的数据报分片的标识字段中。
-   标志位：第一位保留，必须为0；第二位DF，表示能否分分片，0表示可以分片，1表示不能分片；第三位MF，表示是否该报文为最后一片，0表示最后一片，1代表后面还有分片。
-   片偏移：分片重组时会用到该字段。表示较长的分组在分片后，某片在原分组中的相对位置。片偏移以8字节为单位，这就是说除了最后一个分片，每个分片的长度是8字节的整数倍。
-   生存时间：占8位，表示数据报可经过的最多路由数，即数据包在网络中可通过的路由器数的最大值，一般是64。每经过一个路由，TTL就会减1。如果减到0还没有到达，那就丢弃了。这个字段主要是防止出现路由循环。
-   协议：上一层协议，占8位。指出此数据包携带的数据使用何种协议，以便目的主机的IP层将数据部分上交给哪个进程处理。0表示保留，1表示ICMP，6表示TCP，17表示UDP。
-   首部检验和：占16位，只检验数据包的首部，不检验数据部分。这里不采用CRC检验码，而采用简单的计算方法。
-   源地址：表示发送端的IP地址，占32位。
-   目标地址：表示接收端的IP地址，，占32位。
-   选项：可变字段，大小从1字节到40字节不等。
-   填充：把选项填充到4字节的整数倍，全0。
-   数据：需要传输的数据。

## ARP

> [看完后，搞懂ARP的工作原理，其实并不难！](http://blog.sina.com.cn/s/blog_6bc2727c0102w9ox.html "看完后，搞懂ARP的工作原理，其实并不难！")

ARP（Address Resolution Protocol，地址解析协议）是一个网络层协议，用来根据主机的IP地址获取MAC地址。

ARP首先会发起一个请求数据报，数据报的首部包含了目标主机的IP地址，然后这个数据报会在链路层进行再次包装，生成以太网数据报，最终由以太网广播给子网内的所有主机，每一台主机都会接收到这个数据报，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据报。ARP接收返回消息，以此确定目标机的MAC地址；与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

## 路由协议

路由协议（Routing Protocol）是一种路由选择和数据转发的网络层协议。路由协议创建了路由表，描述了网络拓扑结构；路由协议与路由器协同工作，执行路由选择和数据报转发功能。

通过ARP协议的工作原理可以发现，ARP的MAC寻址还是局限在同一个子网中，因此网络层引入了路由协议。首先通过IP协议来判断两台主机是否在同一个子网中，如果在同一个子网，就通过ARP协议查询对应的MAC地址，然后以广播的形式向该子网内的主机发送数据报；如果不在同一个子网，以太网会将该数据报转发给本子网的网关进行路由。网关是互联网上子网与子网之间的桥梁，所以网关会进行多次转发，最终将该数据报转发到目标IP所在的子网中，然后再通过ARP协议获取目标主机的MAC地址，最终也是通过广播形式将数据报发送给接收方。

完成这个路由协议的物理设备就是路由器，在错综复杂的网络世界里，路由器扮演者交通枢纽的角色，它会根据信道情况，选择并设定路由，以最佳路径来转发数据报。

通过IP地址寻找主机所在的子网，通过MAC地址和广播吧数据发送给对应的主机。

## ICMP

ICMP（Internet Control Message Protocol，因特网控制消息协议）是一个网络层协议，用于在主机和路由器之间传递控制消息。控制消息包括报告错误、交换受限控制和状态信息等，比如网络通不通、主机是否可达、路由是否可用。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

如果遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。

`ping`和`tracert`是两个常用网络管理命令，其中`ping`用来测试网络可达性，`tracert`用来显示到达目的主机的路径。`ping`和`tracert`都利用ICMP协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。

ICMP是个非常有用的协议﹐尤其是当我们要对网路连接状况进行判断的时候。

### 使用ping时所用到的协议

ping是为了测试另一台主机是否可达，发送一份ICMP回显请求给目标主机，并等待ICMP回显应答。这个过程用到了：

-   DNS协议，将ping后接的域名转换为IP地址。DNS使用的传输层协议是UDP协议。
-   ARP解析服务，由IP地址解析出MAC地址，以在数据链路层传输。

# 数据链路层

## ARQ协议

ARQ（Automatic Repeat Request，自动重传请求）是数据链路层和运输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

# 常见面试题

## 从输入URL到页面加载发生了什么？

> 具体可参考：[前端经典面试题: 从输入URL到页面加载发生了什么？](https://segmentfault.com/a/1190000006879700 "前端经典面试题: 从输入URL到页面加载发生了什么？")

总体来说分为以下几个过程:

1.  DNS解析。
2.  TCP连接。
3.  发送HTTP请求。
4.  服务器处理请求并返回HTTP报文。
5.  浏览器解析渲染页面。
6.  连接结束。

如下图所示（图片来自《图解HTTP》）：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030110947.jpg?token=AE4F4YOZM5CIX3VUHSYCSSK7TOCJO" alt="计算机网络 输入URL" style="zoom: 67%;" />

## Cookie和Session的作用和区别？

Cookie和Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

Cookie的主要作用是通过客户端保存用户的信息。比如：

-   在Cookie中保存已经登录过的用户信息，下次访问网站的时候不需要登陆，访问网站其他页面也不需要重新登录。这是因为用户登录的时候，可以存放一个Token在Cookie中，下次登录的时候只需要根据Token值来查找用户即可。

Session的主要作用是通过服务端记录用户的状态。比如：

-   典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为HTTP协议是无状态的。服务端给特定的用户创建特定的 Session之后就可以标识并跟踪这个用户了。

二者的主要区别：

-   Session中保存的是对象，Cookie中保存的是字符串。
-   Cookie数据保存在客户端，用户能够找到cookie文件；Session数据保存在服务器端，用户看不到。
-   Cookie没有Session安全。如果要在Cookie中存储一些敏感信息，不要直接写入Cookie，最好能将Cookie信息加密，然后使用到的时候再去服务器端解密。
-   Session不能区分路径，同一个用户在访问一个网站期间，所有的Session在任何一个地方都可以访问到，而Cookie中如果设置了路径参数，那么同一个网站中不同路径下的Cookie互相是访问不到的。
-   Session保存在服务器上，当访问增多，会比较占用服务器的性能，考虑到减轻服务器性能方面。Cookie保存在本地，不会影响服务器性能。
