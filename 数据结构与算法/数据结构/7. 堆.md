[TOC]


# 基础

## 堆实现和堆排序

> [Python实现 《算法导论 第三版》中的算法 第6章 堆排序](https://blog.csdn.net/shengchaohua163/article/details/83038413 "Python实现 《算法导论 第三版》中的算法 第6章 堆排序")

下面的代码实现了一个最大堆以及堆排序算法：

```python
def get_parent(i):
    return (i - 1) // 2


def get_left(i):
    return 2 * i + 1


def get_right(i):
    return 2 * i + 2


def max_heapify_recursive(A, heap_size, i):
    l = get_left(i)
    r = get_right(i)
    largest_ind = i
    if l < heap_size and A[l] > A[largest_ind]:
        largest_ind = l
    if r < heap_size and A[r] > A[largest_ind]:
        largest_ind = r
    if largest_ind == i:
        return
    else:
        A[i], A[largest_ind] = A[largest_ind], A[i]
        max_heapify_recursive(A, heap_size, largest_ind)
    
    
def max_heapify_loop(A, heap_size, i): 
    while i < heap_size:
        l = get_left(i)
        r = get_right(i)
        largest_ind = i
        if l < heap_size and A[l] > A[largest_ind]:
            largest_ind = l
        if r < heap_size and A[r] > A[largest_ind]:
            largest_ind = r
        if largest_ind == i:
            break
        else:
            A[i], A[largest_ind] = A[largest_ind], A[i]
            i = largest_ind


def build_max_heap(A, heap_size):
    begin = len(A)//2 - 1  # len(A)//2 - 1是堆中第一个叶子节点的前一个节点
    for i in range(begin, -1, -1):
        max_heapify_loop(A, heap_size, i)


def heap_sort(A):
    heap_size = len(A)
    build_max_heap(A, heap_size)
    for i in range(len(A)-1, 0, -1):
        A[0], A[i] = A[i], A[0]  # 每次固定最后一个元素，并将堆大小减一
        heap_size -= 1
        max_heapify_loop(A, heap_size, 0)
```

## 不同编程语言的支持

1）Python

Python内置的heapq模块实现了最小堆，并提供了多个方法，如下所示

```python
heap = []            # creates an empty heap
heappush(heap, item) # pushes a new item on the heap
item = heappop(heap) # pops the smallest item from the heap
item = heap[0]       # smallest item on the heap without popping it
heapify(x)           # transforms list into a heap, in-place, in linear time
item = heapreplace(heap, item) # pops and returns smallest item, and adds
                               # new item; the heap size is unchanged
```

2）Go

Go语言内置的"container/heap"包实现了通用的最小堆，并提供了接口，便于实现自定义的堆。


# 编程题
## 前K个高频元素

> [https://leetcode.cn/problems/top-k-frequent-elements](https://leetcode.cn/problems/top-k-frequent-elements "https://leetcode.cn/problems/top-k-frequent-elements")

一、题目

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

示例 1:

```python
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]

```

示例 2:

```text
输入: nums = [1], k = 1
输出: [1]
```

提示：

-   1 <= nums.length <= 105
-   k 的取值范围是 \[1, 数组中不相同的元素的个数]
-   题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的&#x20;

进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。

二、解析

使用一个最小堆，用频率作为判断。

代码如下：

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        num_freq = {}
        for num in nums:
            if num not in num_freq:
                num_freq[num] = 0
            num_freq[num] += 1
        l = []
        for num, freq in num_freq.items():
            l.append((freq, num))
        
        import heapq
        heap = []
        for ele in l:
            if len(heap) < k:
                heapq.heappush(heap, ele)
            else:
                if heap[0][0] < ele[0]:
                    heapq.heappushpop(heap, ele)
        
        res = []
        while heap:
            res.append(heap.pop()[1])
        return res

```

Golang实现如下：

```python
func topKFrequent(nums []int, k int) []int {
    occurrences := map[int]int{}
    for _, num := range nums {
        occurrences[num]++
    }
    h := &IHeap{}
    heap.Init(h)
    for key, value := range occurrences {
        heap.Push(h, [2]int{key, value})
        if h.Len() > k {
            heap.Pop(h)
        }
    }
    ret := make([]int, k)
    for i := 0; i < k; i++ {
        ret[k - i - 1] = heap.Pop(h).([2]int)[0]
    }
    return ret
}

type IHeap [][2]int

func (h IHeap) Len() int           { return len(h) }
func (h IHeap) Less(i, j int) bool { return h[i][1] < h[j][1] }
func (h IHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IHeap) Push(x interface{}) {
    *h = append(*h, x.([2]int))
}

func (h *IHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

```

