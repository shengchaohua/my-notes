# 简介

分布式和集群类似。

从解决问题的角度，说一下分布式与集群的差异：

- 分布式是以缩短单个任务的执行时间来提升效率的；
- 集群则是通过提高单位时间内执行的任务数来提升效率。

从软件部署的角度，说一下分布式和集群的关系：

- 分布式是指将不同的业务分布在不同的地方；
- 集群则是将几台服务器集中在一起，实现同一业务；
- 分布式中的每一个节点，都可以做集群；
- 集群并不一定就是分布式的。

# CAP

> https://zhuanlan.zhihu.com/p/33999708

CAP理论是指一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。

## 一致性Consistency

一致性指“all nodes see the same data at the same time”，即所有节点在同一时间的数据完全一致。那么一致性问题就是指有些节点看到了和其他节点不一致的数据。比如在多个数据拷贝下的场景下，并发读写可能导致这样的问题。

对于一致性，可以分为从客户端和服务端两个不同的视角来看：

- 从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。
- 从服务端来看，一致性主要指的是如何使数据更新分布到整个系统，以保证数据最终一致。

另外，一致性可以分为两类，强一致性和弱一致性。强一致性也叫做线性一致性，除此以外，所有其他的一致性都是弱一致性的特殊情况，比如最终一致性。

### 强一致性和弱一致性

对于关系型数据库，要求更新过的数据在数据库每一个结点都能呗后续的访问看到，则是强一致性。如果能容忍后续的部分或者全部访问不到，则是弱一致性。

举个例子，用户更新网站头像，在某个时间点，用户向主库发送更新请求，不久之后主库就更新了数据。在某个时刻，主库又会将数据变更转发给自己的从库，从库也会更新自己的数据。

如果在返回给用户“更新成功”并使新头像对其他用户可见之前，主库需要等待从库的确认，确保从库已经收到写入操作，那么复制是同步的，即强一致性。

如果主库写入成功后，不等待从库的响应，直接返回“更新成功”，则复制是异步的，即弱一致性。

强一致性可以保证从库有与主库一致的数据。如果主库突然宕机，我们仍可以保证数据完整。但如果从库宕机或网络阻塞，主库就无法完成写入操作。

### 最终一致性

如果经过一段时间后，分布式系统中的所有节点能访问到更新后的数据，则是最终一致性。

单领导者的主从复制算法要求所有写入都由单个节点处理，但只读查询可以由任何节点处理。对于读多写少的场景，我们往往创建很多从库，并将读请求分散到所有的从库上去。这样能减小主库的负载，并允许向最近的节点发送读请求。当然这只适用于异步复制——如果尝试同步复制，则单个节点故障将使整个系统无法写入。

当用户从**异步从库**读取时，**如果此异步从库落后，他可能会看到过时的信息。这种不一致只是一个**暂时的状态——如果等待一段时间，从库最终会赶上并与主库保持一致。这称为**最终一致性。**

**最终**两个字用得很微妙，因为从写入主库到反映至从库之间的延迟，可能仅仅是几分之一秒，也可能是几个小时。

## 可用性Availability

可用性指“Reads and writes always succeed”，即服务在正常响应时间内一直可用。

好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下和分布式数据冗余，负载均衡等有着很大的关联。

## 分区容错性Partition Tolerance

分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。

## CAP证明

TODO

## **CAP权衡**

通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，必须有有所取舍：

- CAP without P：保证一致性（C）和可用性（A），不保证分区容错性（P），或不允许分区。但其实分区不是你想不想的问题，而是始终会存在，因此一致性（C）和可用性（A）的系统更多的是允许分区后各子系统依然保持。
- CAP without A：保证一致性（C）和分区容错性（P），不保证可用性（A）。如果要求保证一致性（C）和分区容错性（P），这相当于每个请求都需要在不同的节点之间保证数据一致，而分区容错性（P）会导致同步时间无限延长，这样的一致性（C）和分区容错性（P）也是可以保证的。比如很多传统的数据库分布式事务都属于这种模式。
- CAP without C：保证可用性（A）和分区容错性（P），不保证一致性（C）。因为要求系统保证分区容错性，但是一旦分区发生，节点之间可能会失去联系。为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。比如现在很多的NoSQL都属于这种模式。

对于多数大型互联网应用的场景，服务器主机众多、部署分散，而且集群规模越来越大，然而节点故障、网络故障是常态，再加上要保证服务可用性达到N个9。也就是说，系统需要保证可用性（A）和分区容错性（P），同时也意味着系统只能舍弃一致性（C），但是会退而求其次保证最终一致性。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。

对于涉及到钱财这样数据不能出错的场景，系统必须保证一致性（C）。如果网络发生故障，宁可停止服务。这就是要保证一致性（C）和可用性（A），舍弃分区容错性（P）。还有一种是保证一致性（C）和分区容错性（P），舍弃可用性（A），例如网络故障后系统只读不写。

孰优孰略，没有定论，只能根据场景决定，适合的才是最好的。

# BASE理论

BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。

BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

BASE理论的三要素：

- 基本可用（Basically Available）：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。注意，这绝不等价于系统不可用。比如：
  - 响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒。
  - 系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。
- 软状态（Soft State）：软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。
- 最终一致（Eventually Consistent）：最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。最终一致的核心做法就是通过记录对应操作并在操作失败时不断进行重试直到成功为止

在出现一致性问题时如果系统的并发或不一致情况较少，可以先使用重试来解决。如下图所示：

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311252213537.png)

在调用Service B超时或失败时进行重试：

- 同步调用，捕获异常重新调用Service B。
- 异步消息，捕获异常发送延迟消息重新调用Service B。
- 异步线程，捕获异常开启异步线程重新调用Service B。

如果重试还是不能解决问题，那么需要使用分布式事务来解决。

# 分布式事务

> https://www.cnblogs.com/liconglong/p/16277356.html https://cloud.tencent.com/developer/article/1763155

在分布式系统中，随着系统架构演进，原来的原子性操作会随着系统拆分而无法保障原子性从而产生一致性问题，但业务实际又需要保障一致性。

对于分布式一致性问题，可以采用分布式事务来解决。

分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上,且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

> 和分布式事务对应的是本地事务。起初，事务仅限于对单一数据库资源的访问控制，架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源，这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。

## XA协议

XA协议主要包含AP、RM、TM三个成员：

- AP（Application）表示应用程序。
- RM（Resource Manager）表示资源管理器，例如数据库。
- TM（Transaction Manager）表示事务管理器。

### 两阶段提交

### 三阶段提交

## TCC

TCC分为Try、Confirm、Cancel三个阶段：

- Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）。
- Confirm 阶段：确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作要求具备幂等设计，Confirm 失败后需要进行重试。
- Cancel 阶段：取消执行，释放 Try 阶段预留的业务资源。Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致，要求满足幂等设计。

TCC的实现原理是通过数据库的唯一索引保证全局事务的，在本地数据库，建立分支事务状态表sub_trans_barrier，唯一键为全局事务id-子事务id-子事务分支名称（try/confirm/cancel），执行try，会往分支事务状态表中插入一条数据（全局事务id+分支事务id+try）。

优点：并发度较高，无长期资源锁定。一致性较好，不会发生SAGA已扣款最后又转账失败的情况。

缺点：开发量较大，需要提供Try/Confirm/Cancel接口。

## 本地消息表

本地消息表这个方案最初是 ebay 架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章。

简单来说，写本地消息和业务操作放在一个事务里，保证了业务和发消息的原子性，要么他们全都成功，要么全都失败。

本地消息表有容错机制：扣减余额事务失败时，事务直接回滚，无后续步骤；轮序生产消息失败， 增加余额事务失败都会进行重试。

本地消息表的缺点：

- 不支持回滚。
- 轮询生产消息难实现，如果定时轮询会延长事务总时长，如果订阅binlog则开发维护困难。

本地消息表适用于可异步执行的业务，且后续操作无需回滚的业务。

## SAGA

通过时间监听机制，分段提交回滚。

SAGA是这一篇数据库论文提到的一个方案。其核心思想是将长事务拆分为多个本地短事务，由SAGA事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。
