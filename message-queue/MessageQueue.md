# 介绍

消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。

另外，队列是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3...对于消费者就会按照1,2,3...的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。

除了上面说的消息消费顺序的问题，使用消息队列，我们还要考虑如何保证消息不被重复消费、如何保证消息的可靠性传输、如何处理消息丢失的问题等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。


## 为什么要用消息队列

使用消息队列主要有两点好处：1、通过异步处理提高系统性能（削峰、减少响应所需时间）；2、降低系统耦合性。

通过异步处理提高系统性能（削峰、减少响应所需时间），如下图所示（图片来自JavaGuide）:

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201101154928.png?token=AE4F4YPGKEP3TP4QO3W43G27TZUSK" alt="消息队列 异步处理"  />

在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。

通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201101154942.png?token=AE4F4YIJMMBA3KV3KLLQ74C7TZUTI" alt="消息队列 削峰" style="zoom: 33%;" />

因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此使用消息队列进行异步处理之后，需要适当修改业务流程进行配合，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功。

消息队列可以降低系统耦合性。如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。如下图所示：

<img src="https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201101155048.png?token=AE4F4YJ5SZ75AQT7L44G2LK7TZUXQ" alt="消息队列 解耦"  />

生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合， 这显然也提高了系统的扩展性。

消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。 从上图可以看到消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计。

消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。

另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。


## 使用消息队列的问题

系统可用性降低： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了！

系统复杂性提高： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！

一致性问题： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了！

# JMS&AMQP

## JMS

JMS（Java Message Service）是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。JMS是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。比如ActiveMQ，RocketMQ。

JMS支持两种消息模型：

1. 点到点（P2P）模型：使用队列作为消息通信载体。满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。如果有一个生产者生产消息，两个消费者消费消息，那么两个消费者会轮流消费消息。
2. 发布/订阅（Pub/Sub）模型：使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。

JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- StreamMessage：Java原始值的数据流
- MapMessage：一套名称值对
- TextMessage：一个字符串对象
- ObjectMessage：一个序列化的 Java对象
- BytesMessage：一个字节的数据流


## AMQP

AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。比如RabbitMQ。

AMQP支持5种消息模型：

1. direct exchange：
2. fanout exchange：
3. topic change：
4. headers exchange：
5. system exchange：


## 对比

JMS是Java API规范，只适用于Java，不能跨语言，也不能跨平台，只提供了两种消息模型，支持多种消息类型。

AMQP是一种应用协议，跨语言，跨平台，提供了五种消息模型，消息类型为二进制。

总结：

- AMQP为消息定义了协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。
- JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。
- 由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。


# 流行的消息队列

流行的消息队列有ActiveMQ，RabbitMQ，RocketMQ，Kafka等等。

ActiveMQ和RabbitMQ的吞吐量为万级十万级，RocketMQ和Kafka的吞吐量在十万级百万计。通常来说，ActiveMQ < RabbitMQ < RocketMQ < Kafka。

四种消息队列都可以实现高可用。ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性。RocketMQ 基于分布式架构。 kafka 也是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用。

RabbitMQ 基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级，其他三个都是毫秒级。

除了 Kafka，其他三个功能都较为完备。 Kafka 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准。

ActiveMQ 和 RabbitMQ 丢失的可能性非常低， RocketMQ 和 Kafka 理论上不会丢失。

总结：

- ActiveMQ的社区算是比较成熟，但是较目前来说，ActiveMQ的性能比较差，而且版本迭代很慢，不推荐使用。
- RabbitMQ在吞吐量方面虽然稍逊于Kafka和RocketMQ，但是由于它基于erlang开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为RabbitMQ基于erlang开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ一定是你的首选。
- RocketMQ是阿里出品的开源项目，可以直接阅读源代码，然后可以进行定制，并且RocketMQ有阿里巴巴的实际业务场景的实战考验。RocketMQ社区活跃度相对较为一般，文档相对来说简单一些，然后接口这块不是按照标准JMS规范，所以有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险。
- Kafka仅提供较少的核心功能，但是提供超高的吞吐量，毫秒级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。Kafka最好是支撑较少的topic数量，保证其超高吞吐量，适合大数据实时计算以及日志收集。Kafka唯一的一点劣势是消息可能重复消费，对数据准确性会造成轻微的影响，但是在大数据领域中以及日志采集中，这点轻微影响可以忽略。