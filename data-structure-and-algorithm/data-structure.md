[TOC]



# 推荐资料

> [旧金山大学数据结构与算法可视化工具](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)



# 线性数据结构

> [Python实现 《算法导论 第三版》中的算法 第10章 基本数据结构](https://blog.csdn.net/shengchaohua163/article/details/84371408)

线性数据结构是最基本的数据结构，包括数组、链表、栈、队列等。

## 数组

数组可以说是最简单的一种数据结构，它占据一块连续的内存并按照顺序存储数据。

在创建数组时，必须指定数组的容量大小，然后根据大小分配内存。即使只在数组中存储一个数字，也需要分配指定容量大小的内存。因此数组的空间效率不是很好，可能会有空闲的区域没有得到利用。

由于数组中的内存是连续的，于是可以根据下标在$O(1)$的时间读写任何元素，访问时间效率高。

为了解决数组空间效率不高的问题，许多语言都提供了动态数组，比如C++的STL中的`vector`，Java中的`ArrayList`，Python中的`list`等。

## 链表

链表是一种动态数据结构，由指针把若干个结点连接成链状结构。

在创建链表时，无须知道链表的长度。当插入一个结点时，只需要为新结点分配内存，并调整指针的指向来确保新结点被链接到链表当中。链表的内存不是在创建链表时一次性分配的，而是每添加一个结点分配一次内存。所以链表没有闲置的内存，空间效率比数组高。

另外，由于链表的内存不是一次性分配的，所以自然无法保证链表的内存和数组一样是连续的。如果想访问链表的结点，我们只能从头结点开始遍历链表，因此链表的访问时间效率低。

常见的链表有单链表，双链表。单链表中的结点有指向下一个结点的指针，而双链表既有指向上一个结点的指针，也有指向下一个结点的指针。如果一个链表的头尾结点相连，形成了一个环路，这种链表可以称为循环链表。头尾结点相连的情况通常出现在双链表中，头结点中指向前一个结点的指针指向尾结点，尾结点中指向下一个结点的指针指向头结点，此时该链表可以称为循环双链表。

如果需要自己实现链表，通常会在头结点之前添加一个虚拟头结点（哨兵），这样可以简化链表的插入、删除等操作。

## 栈

栈是一种动态集合。栈的特点是后进先出：最先进入的元素最后被删除，最后进入的元素被最先删除。

### 最小栈

> [Leetcode 155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

> 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
>
> - push(x) —— 将元素 x 推入栈中。
> - pop() —— 删除栈顶的元素。
> - top() —— 获取栈顶元素。
> - getMin() —— 检索栈中的最小元素。

**解析**：增加一个辅助栈，用来保存当前栈内的最小元素。

```python
class MinStack:

    def __init__(self):
        self.stack = []
        self.aux_stack = []

    def push(self, x: int) -> None:
        self.stack.append(x)
        if len(self.aux_stack) == 0:
            self.aux_stack.append(x)
        else:
            cur_min = self.aux_stack[-1]
            self.aux_stack.append(min(cur_min, x))

    def pop(self) -> None:
        if self.stack:
            self.stack.pop()
            self.aux_stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]
        return 0

    def min(self) -> int:
        if self.aux_stack:
            return self.aux_stack[-1]
```

### 用队列实现栈

>  [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

> 使用队列实现栈的下列操作：
>
> - push(x) -- 元素 x 入栈
> - pop() -- 移除栈顶元素
> - top() -- 获取栈顶元素
> - empty() -- 返回栈是否为空

**解析**：增加一个辅助队列，用来转换元素的顺序。

```python
class MyStack:

    def __init__(self):
        self.queue = []
        self.aux_queue = []  # 辅助队列

    def push(self, x: int) -> None:
        self.aux_queue.append(x)
        while self.queue:
            self.aux_queue.append(self.queue.pop(0))
        self.queue, self.aux_queue = self.aux_queue, self.queue

    def pop(self) -> int:
        return self.queue.pop(0)

    def top(self) -> int:
        return self.queue[0]

    def empty(self) -> bool:
        return len(self.queue) == 0
```

## 队列

队列是一种动态集合。队列的特点时先进先出：最先进入的元素最先被删除，最后进入的元素被最后删除。

### 用两个栈实现队列

>  [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

> 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

**解析**：两个栈，一个用于入队，一个用于出队。

```python
class CQueue:
    def __init__(self):
        self.in_stack = []
        self.out_stack = []

    def appendTail(self, value: int) -> None:
        self.in_stack.append(value)

    def deleteHead(self) -> int:
        if len(self.out_stack) == 0:
            while self.in_stack:
                self.out_stack.append(self.in_stack.pop())
        if len(self.out_stack) == 0:
            return -1
        return self.out_stack.pop()
```



# 散列表

散列表，也称为哈希表。

## 散列函数



## 散列冲突

1. 开放定址法
   - 线性探测法：就是一旦冲突了就放到下一个位置就好了，只要存储空间够大总会有位置放的（但是这样会产生堆积，因为他可能会把其他的原来属于别人的位置只是暂时空着的给占了）
   - 二次探测法：冲突了就放在1或者2或者3等等的平方后的位置，而不是像前面那样就是单纯的不停地加1，这样就可以不让关键字对集中在一块地方
   - 随机探测法：用一个种子产生一个随机数来作为位移量来避免冲突，然后最后查找这个数在不在的时候也用这个种子生成随机数来找
2. 再散列函数法：准备多个散列函数，这个冲突了就换下一个，总会有一个能解决冲突的
3. 链地址法：把冲突的放在一个单链表中，冲突的就串在一起就好了
4. 公共溢出区法：把冲突的放在另一个数组中，然后以后查找的时候没找到还要在这个数组中顺序查找一遍





# 树

[[Data Structure] 数据结构中各种树](https://www.cnblogs.com/maybe2030/p/4732377.html)

树是一种非常重要的数据结构。类似于链表，树中的结点也是通过结点自带的指针相连。通常来说，树中会有一个根结点，根结点没有父结点，除了根结点之外每个结点只有一个父结点。另外，除了叶子结点之外，每个结点都有一个或多个孩子结点。

## 二叉树

二叉树是树结构中最基础的一种结构，其中每个结点最多有两个子结点。

二叉树还有两种特殊情况：

1. 满二叉树：树中所有的叶子结点都位于树的最底层，其他层的所有结点均有两个子结点。换句话说，在当前的高度下，树中每一层的结点数量都达到最大值。
2. 完全二叉树：树中最底层的所有结点连续出现在最左边，其他层的结点数量都达到最大值。因此，完全二叉树可以用数组来表示（用数组的下标来表示结点之间的父子关系），而不需要使用指针相连，空间效率高。此时，用数组表示的完全二叉树通常用来实现堆结构。

一般的二叉树没有太多具体的用途，因为其中的结点没有规律。例如，如果要查找二叉树中是否包含某个值，只能遍历所有结点进行检查

## 二叉搜索树

二叉搜索树，也称为二叉查找树，是一种特殊的二叉树。相比一般的二叉树，二叉搜索树可以提高访问效率。

二叉搜索树的性质包括：

1. 没有值相等的结点；
2. 左孩子结点的值小于父结点的值，右孩子结点的值大于父结点的值。

对于二叉搜索树，一般有三种操作：

1. 查找：类似于二分查找；
2. 插入：依赖查找操作，在进行插入；
3. 删除：依赖查找操作，如果存在再进行删除；

假设二叉搜索树的高度为$n$，查找的平均时间复杂度为$O(\lg{n})$。当二叉搜索树退化为单链表时（最坏情况），此时查找效率为$O(n)$。插入和删除的时间复杂度依赖于查找操作。

## 平衡二叉树

平衡二叉树是指平衡的二叉树，其中的“平衡”是通过限制树中每个结点的左子树和右子树的高度来实现的。因为一般的二叉树用处不大，所以“平衡”这一性质主要应用在二叉搜索树上。

平衡二叉搜索树主要是为了解决一般的二叉搜索树存在退化的问题。当二叉搜索树退化为单链表时，查找效率急剧下降。

平衡二叉搜索树有多种不同的实现，比如AVL树、红黑树等。

### AVL树

AVL树是最早发明的平衡二叉搜索树。在AVL树中，每个结点的左子树和右子树的深度之差的绝对值不超过1。因此，AVL树是高度平衡的。

假设AVL树的高度为$n$，查找、插入和删除在平均和最坏情况下的时间复杂度都是$O(\lg{n})$。

AVL

### 红黑树

红黑树

## 多叉树

### B树

### B+树



## 堆

### 二叉堆

### 优先队列



## 其他

### 字典树

### 线段树

### 树状数组





# 图

