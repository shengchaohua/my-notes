> https://www.ruanyifeng.com/blog/2022/04/microservice.html

# 为什么要使用微服务？

微服务（microservice）是一种软件架构，正得到越来越多的关注。

## 单体

早期的软件，所有功能都写在一起，这称为**单体架构**（monolithic software）。

整个软件就是单一的整体，彷佛一体化的机器。

可以想到，软件的功能越多，单体架构就会越复杂，很多缺点也随之暴露出来。

（1）所有功能耦合在一起，互相影响，最终难以管理。 （2）哪怕只修改一行代码，整个软件就要重新构建和部署，成本非常高。 （3）因为软件做成了一个整体，不可能每个功能单独开发和测试，只能整体开发和测试，导致必须采用瀑布式开发模型。

## 面向服务的架构

为了解决上面这些问题，必须打破代码的耦合，把单体架构的软件拆分成一个个独立的功能单元。

大概在20多年前，随着互联网的出现，功能单元可以用远程"服务"的形式提供，就诞生出了"面向服务的架构"（service-oriented architecture，简称 SOA）。

所谓服务（service），就是在后台不间断运行、提供某种功能的一个程序。最常见的服务就是 Web 服务，通过80端口向外界提供网页访问。

"面向服务的架构"就是把一个大型的单体程序，拆分成一个个独立服务，也就是较小的程序。每个服务都是一个独立的功能单元，承担不同的功能，服务之间通过通信协议连在一起。

这种架构有很多优点。

（1）每种服务功能单一，相当于一个小型软件，便于开发和测试。 （2）各个服务独立运行，简化了架构，提高了可靠性。 （3）鼓励和支持代码重用，同一个服务可以用于多种目的。 （4）不同服务可以单独开发和部署，便于升级。 （5）扩展性好，可以容易地加机器、加功能，承受高负载。 （6）不容易出现单点故障。即使一个服务失败了，不会影响到其他服务。

跟单体架构不一样，面向服务架构是语言不敏感的，不同服务可以使用不同的语言和工具开发，可能需要部署在不同的系统和环境。

这意味着，**面向服务架构默认运行在不同服务器上**，每台服务器提供一种服务，多台服务器共同组成一个完整的网络应用。

## 微服务

> https://zh.wikipedia.org/wiki/微服務

简单来说，**微服务就是采用容器技术实现的面向服务的架构**。它依然使用"服务"作为功能单元，但是变成了轻量级实现，即每个服务运行在一个或多个Docker容器上。另外，只用一台服务器就实现了面向服务的架构。这种实现方式就叫做微服务。

**一个Docker容器运行着一个微服务，可以看作一个独立的进程。** 这个进程可以运行在本机，也可以运行在别的服务器，或者在云端（比如云服务和云函数 FaaS）。

它的特点与面向服务架构是一样的，但因为更轻量级，所以功能的解耦和服务化可以做得更彻底。而且，它可以标准化，同样的容器不管在哪里运行，结果都是一样的，所以市场上有很多 SaaS 产品，提供标准化的微服务。

正是由于微服务这些突出的优点，这几年才会变得如此流行。它和容器技术、云服务一起，一定会在未来的软件开发中，扮演越来越重要的角色。

# RPC

> https://doc.rpcx.io/

对于微服务来说，不通的服务之间通常通过RPC进行交互。

RPC（Remote Procedure Call，远程过程调用）是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，比如 Java RMI。

RPC是一个分布式计算的客户端-服务器（Client/Server）的例子，它简单而又广受欢迎。 远程过程调用总是由客户端对服务器发出一个执行若干过程请求，并用客户端提供的参数。执行结果将返回给客户端。 由于存在各式各样的变体和细节差异，对应地派生了各式远程过程调用协议，而且它们并不互相兼容。

为了允许不同的客户端均能访问服务器，许多标准化的 RPC 系统应运而生了。其中大部分采用接口描述语言（Interface Description Language，IDL），方便跨平台的远程过程调用。

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311262131550.png)

有些实现扩展了远程调用的模型，实现了双向的服务调用，但是不管怎样，调用过程还是由一个客户端发起，服务器端提供响应，基本模型没有变化。

服务的调用过程为：

1. client调用client stub，这是一次本地过程调用
2. client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling
3. client所在的系统将消息发送给server
4. server的的系统将收到的包传给server stub
5. server stub解包得到参数。 解包也被称作 unmarshalling
6. 最后server stub调用服务过程. 返回结果按照相反的步骤传给client

## 对比RPC和RESTful API

RPC 的消息传输可以通过 TCP、UDP 或者 HTTP等协议，所以可以分为 RPC over TCP、RPC over HTTP。RPC 通过 HTTP 传输消息的时候和 RESTful API的架构是类似的，但是也有不同。

1）比较 RPC over HTTP 和 RESTful API。

首先， RPC 的客户端和服务器端是紧耦合的，客户端需要知道调用的服务名称或ID，过程的名字，过程的参数等。一旦服务端更改了过程的实现， 客户端的实现很容易出问题。RESTful基于 HTTP的语义操作资源，参数的顺序一般没有关系，也很容易的通过代理转换链接和资源位置。从这一点上来说，RESTful 更灵活。

其次，它们操作的对象不一样。 RPC 操作的是方法和过程，它要操作的是方法对象。 RESTful 操作的是资源（resource），而不是方法。

第三，RESTful执行的是对资源的操作，增加、查找、修改和删除等，主要是CURD，所以如果你要实现一个特定目的的操作，比如为名字姓张的学生的数学成绩都加上10这样的操作， RESTful的API设计起来就不是那么直观或者有意义。在这种情况下，RPC的实现更有意义，它可以实现一个 `Student.Increment(Name, Score)` 的方法供客户端调用。

![img](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311262131700.png)

2）比较一下 RPC over TCP 和 RESTful API。

如果RPC是基于TCP socket实现的，除了上面的不同外，我们可以获得性能上的优势。RPC over TCP可以通过长连接减少连接的建立所产生的花费，在调用次数非常巨大的时候（这是目前互联网公司经常遇到的情况），这个花费影响是非常巨大的。

虽然 RESTful 也可以通过 keep-alive 实现长连接， 但是它最大的一个问题是它的request-response模型是阻塞的 (http1.0和 http1.1存在这样的问题, http 2.0没这个问题)， 发送一个请求后只有等到response返回才能发送第二个请求 (有些http server实现了pipeling的功能，但不是标配)， RPC的实现没有这个限制。

## RPC框架

> https://mp.weixin.qq.com/s/jUgmW3oflsTwyX-6kNZCfw

RPC框架是系统微服务化的首要基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。

RPC框架的**职责**是：让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。

常见的RPC框架包括gRPC、Dubbo等。