# 并发

> [Java 并发基础常见面试题总结 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81 "Java 并发基础常见面试题总结 - JavaGuide")
> [Java 并发进阶常见面试题总结 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions.md#1-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97 "Java 并发进阶常见面试题总结 - JavaGuide")
> [Java并发编程 - 黑马程序员](https://www.bilibili.com/video/BV1jE411j7uX "Java并发编程 - 黑马程序员")
> [并发和并行的区别](https://www.jianshu.com/p/cbf9588b2afb "并发和并行的区别")

## 并发和并行

并发和并行都是指同时处理多个任务。并发是指在一个处理器上**同一时间间隔**处理两个或多个任务，而并行是指在多个处理器上**同一时刻**处理两个或多个任务。

对于单个单核CPU，不能在同一时刻处理多个任务，也就没有并行的概念；但是存在并发，因为CPU可以快速切换，保证在同一时间间隔处理多个任务。对于多核CPU或多个CPU，多个任务可能在并发处理，也可能在并行处理。

## 进程和线程

进程是程序的一次执行过程，是系统运行程序、分配资源的基本单位。

线程是系统调度的基本单位。线程存在于进程中，一个进程中至少有一个线程。一个进程中的多个线程能够共享进程的堆和方法区等资源，每个线程有自己私有的程序计数器、虚拟机栈和本地方法栈。

进程和线程对比：

-   调度：进程是操作系统分配资源的基本单位，线程是 CPU调度的基本单位。
-   并发性：引入线程之后，不仅进程之间是可以并发执行的，而且在一个进程之中的多个线程也是可以并发执行的，甚至是允许一个进程中的全部进程并发执行。同样，不同的进程中的线程也是可以并发执行的。

### 进程的状态和生命周期

一般把进程分为 5 种状态：

-   创建状态（new）：进程正在被创建，尚未到就绪状态。
-   就绪状态（ready）：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行。
-   运行状态（running）：进程正在处理器上上运行（单核CPU下任意时刻只有一个进程处于运行状态）。
-   阻塞状态（waiting）：又称为等待状态，进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
-   结束状态（terminated）：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

### 如何查看进程

对于Windows系统：

-   任务管理器可以查看进程和线程数，也可以用来杀死进程
-   tasklist：查看进程
-   taskkill：杀死进程

对于Linux系统：

-   ps -ef：查看所有进程
-   ps -fT -p ：查看某个进程（PID）的所有线程
-   kill：杀死进程
-   top：按大写 H 切换是否显示线程
-   top -H -p ：查看某个进程（PID）的所有线程

Java自带的命令：

-   jps：查看所有 Java 进程。
-   jstack ：查看某个 Java 进程（PID）的所有线程状态。
-   jconsole：来查看某个 Java 进程中线程的运行情况（图形界面）。

## Java多线程

Java并发通常是指Java多线程。

### 并发三要素

并发三要素包括：原子性，可见性，和有序性。

#### 原子性

原子性是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

Java可以通过使用synchronized和Lock锁来确保原子性。另外，volatile关键字是无法保证复合操作的原子性。

#### 可见性

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

Java提供了volatile关键字来保证可见性。另外，synchronized和Lock锁也可以保证可见性，因为锁保证每个时刻是有一个线程执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。

#### 有序性

有序性是指程序执行的顺序按照代码的先后顺序执行。

Java内存模型允许编译器和处理器对指令进行重排序，前提是不影响程序的结果。重排序过程不会影响到单线程程序的执行，但是却会影响到多线程并发执行的正确性。

Java提供了volatile关键字来保证有序性。另外，synchronized和Lock锁也可以保证有序性，因为锁保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

### 如何创建线程

创建线程有三种方式：

1）继承Thread类，重写run方法，该方法为线程执行体。创建子类的实例，即可创建一个线程。

2）实现Runnable接口，重写run方法，该方法为线程执行体。创建线程仍然需要Thread配合，先创建Runnable实现类的实例，然后用Thread接收该实例创建一个线程。

3）实现Callable接口，重写call方法，该方法为线程执行体，并且可以返回结果或抛出异常。创建线程仍然需要Thread配合，先创建Callable实现类的实例，使用FutureTask包装该实例得到一个FutureTask对象，最后用Thread接收该FutureTask对象创建一个线程。

伪代码：

```java
// 1. Thread
ThreadSubClass t = new ThreadSubClass();
t.start();
// 2. Runnable
RunnableImpl r = new RunnableImpl();
Thread t = new Thread(r);
t.start();
// 3. Callable
CallableImpl c = new CallableImpl();
FutureTask task = new FutureTask(c);
Thread t = new Thread(task);
t.start();
Object ret = task.get(); // 当前线程阻塞，等待task获取结果
```

对比：

-   继承Thread类的方式比较简单，但是不太灵活，因为不能再继承其他的类；实现Runnable接口和Callable接口的方式比较灵活，线程本身和线程执行的任务对象分开，耦合性更低。
-   实现Runnable接口重写run方法，该方法没有返回值；实现Callable接口重写call方法，该方法有返回值，还可以抛出异常。
-   运行Callable任务可以拿到一个FutureTask对象，可以查看返回结果，还可以取消任务的执行。

### 线程的状态和生命周期

Java线程在生命周期中存在6种状态，如下图所示（图源《Java并发编程的艺术》4.1.4 节）：

![image_tV8Uyf0mcr](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261010225.png)

线程并不是固定处于某一个状态，而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java并发编程的艺术》4.1.4 节）：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201029201036.png?token=AE4F4YMXR3RBL4H6MWF4BCC7TKY5S)

> 订正：在RUNNABLE到WAITING状态的转换中，join实际上是Thread类的成员方法，但这里写成了Object。

由上图可以看出：线程创建之后处于NEW（初始）状态，调用`start()`方法后，线程此时处于RUNNABLE（运行）状态。

对于一个处于RUNNABLE状态的线程，

-   如果调用了Thread类的`join()`成员方法或调用了锁对象的`wait()`方法，那么线程就会进入WAITING（等待）状态；
-   如果调用了Thread类的`sleep(long)`方法或调用了锁对象的`wait(long)`方法，那么线程就会进入TIMED\_WAITING（超时等待）状态；
-   如果调用了同步方法，在没有获取到锁的情况下，线程就会进入到BLOCKED（阻塞）状态；
-   如果线程的`run()`方法执行完之后，线程就会进入到TERMINATED（终止）状态；

> Java虚拟机隐藏了操作系统中的Ready（就绪）和RUNNING（运行）状态，我们只能看到RUNNABLE状态。操作系统中的线程在处于Ready（就绪）状态时，如果得到了CPU使用权，就进入Running（运行）状态；CPU使用权结束，就回到Ready（就绪）状态。

### Java线程模型

通常来说，实现多线程主要有3种模型：内核线程模型、用户线程模型和混合线程模型。

它们之间最大的差异就在于用户线程与内核调度实体（Kernel Scheduling Entity，KSE）之间的对应关系上，其中内核调度实体是指可以被操作系统内核调度器调度的对象实体。准确来说 ，KSE 的具体实现就是内核级线程（Kernel-Level Thread，KVT），是操作系统内核的最小调度单元。

#### 内核线程模型

内核线程模型即完全依赖操作系统内核提供的内核级线程来实现多线程。

在这种模型下，用户线程与内核线程是一对一对应的关系。也就是说，每一个用户线程需要绑定一个实际的内核线程，因此线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成。

大部分编程语言的线程库（比如Java的java.lang.Thread、C++11的std::thread等）都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个KSE。

这种模型的主要优点是实现简单，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行。

这种模型的主要缺点是线程操作和切换需要在用户态和内核态之间频繁切换，消耗较大。

#### 用户线程模型

用户线程模型完全建立在用户空间的线程库上，不依赖于系统内核。具体地，用户线程的创建、销毁以及线程间的同步等操作都是由用户自己的线程库来负责（在用户态执行），不需要切换到内核态。

在这种模型中，用户线程与内核线程KSE是多对一（N : 1）的映射关系。多个用户线程的一般从属于单个进程，并且多线程的调度是由用户自己的线程库来完成，而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定。也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。

许多语言实现的协程库基本上都属于这种方式（比如Python的gevent）。

在这种线程模型下，线程的各种操作以及切换消耗很低，但线程的所有操作都需要在用户态实现，线程的调度实现起来异常复杂，处理器映射更是无法实现。

#### 混合线程模型

混合线程模型是前述两种模型的混合版本，也可以称为两级线程模型。

在这种模型中，用户线程仍然是在用户态中创建，用户线程的创建、切换和销毁的消耗很低，用户线程的数量不受限制。而LWP在用户线程和内核线程之间充当桥梁，就可以使用操作系统提供的线程调度和处理器映射功能。

#### Java线程模型

当前，Java虚拟机使用的线程模型是基于操作系统提供的原生线程模型来实现的，Windows系统和Linux系统都是使用的内核线程模型，而Solaris系统支持混合线程模型和内核线程模型两种实现。

### Java线程调度

线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。

#### 协同式调度

如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。Lua语言中的“协同例程”就是这类实现。

协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。

它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。

#### 抢占式调度

如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题。**Java的线程调度方式正是抢占式调度**。

在Java中，Thread.yield方法可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的。

#### 线程优先级

虽然Java线程调度是操作系统完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点时间——这项操作可以通过设置线程优先级来完成。Java一共提供了10个级别的线程优先级（Thread.MIN\_PRIORITY至Thread.MAX\_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。

不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统内核线程上来实现的，所以线程调度最终还是取决于操作系统。虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应，比如Solaris系统中有2147483648（2^32）种优先级，

### 与线程状态有关的多个函数

#### wait/notify

wait/notify是Object类的final成员方法，子类可以直接使用。另外，wait/notify必须和synchronized关键字配合使用。wait/notify的原理参见synchronized重量级锁一节。

wait方法有`wait()`和`wait(long)`两种形式，作用让线程等待。

-   如果一个线程在synchronized同步块中调用了锁对象的`wait()`方法，那么线程就会进入WAITING（等待）状态并**释放锁**，只能等待其他线程调用同一个锁对象的notify或notifyAll方法进行唤醒。
-   如果调用了`wait(long)`方法，那么线程就会进入TIMED\_WAITING（超时等待）状态并**释放锁**。该线程在指定的时间内可以被打断或被唤醒，或者当超时时间到达后自动返回到运行状态。

notify方法有`notify()`和`notifyAll()`两种形式，主要作用是唤醒调用了同一个锁对象的wait方法（处于等待或超时等待状态）的线程。被唤醒的线程进入EntryList竞争锁，成功抢到锁的线程可以恢复运行。

-   notify只能唤醒一个等待的线程，notifyAll可以唤醒所有等待的线程。
-   因为notify方法只能随机唤醒其中一个线程，如果唤醒了不正确的线程，称为**虚假唤醒**。解决办法是使用notifyAll方法。

wait/notify的基本用法如下面的伪代码所示：

```java
Object object = new Object();
// 一个线程的执行体
public void run() {
    synchronized(object) {
        object.wait();
        ......
    }
}
// 另一个线程的执行体
public void run() {
    synchronized(object) {
        object.notify();
        ......
    }
}
```

另外，wait/notify通常是配合while循环和判断标记一起使用，其中的while循环不能替换为if判断，因为if判断只会执行一次，而while循环可以执行多次。举个例子，小南和小女线程分别在等待烟和外卖，第三个线程用来唤醒这两个线程。

```java
public class TestWaitNotify {
    static final Object room = new Object();
    static boolean hasCigarette = false;
    static boolean hasTakeout = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            synchronized (room) {
                System.out.println("有烟没：" + hasCigarette);
                while (!hasCigarette) { // 不能使用if
                    System.out.println("没烟，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("有烟没：" + hasCigarette + "，开始干活了");
            }
        }, "小南").start();

        new Thread(() -> {
            synchronized (room) {
                System.out.println("外卖送到没：" + hasTakeout);
                while (!hasTakeout) { // 不能使用if
                    System.out.println("没外卖，先歇会！");
                    try {
                        room.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println("外卖送到没：" + hasTakeout + "，开始干活了");
            }
        }, "小女").start();

        Thread.sleep(1);
        new Thread(() -> {
            synchronized (room) {
                hasTakeout = true;
                System.out.println("外卖到了哦！");
//                hasCigarette = true;
//                System.out.println("烟送到了哦！");
                room.notifyAll();
            }
        }, "送外卖的").start();
    }
}
```

#### sleep

sleep方法是Thread类的静态方法，它有`sleep(long)`和`sleep(long,int)`两种形式。该方法的作用是让线程睡眠一段时间，让出CPU，让其他线程有机会继续执行，但是它并不释放对象锁，其他想要获得同一把锁的线程仍然会阻塞。

#### join

join方法是Thread类的成员方法，它有`join()`，`join(long)`和`join(long,int)`三种形式。如果在主线程中调用`t.join()`，则主线程会暂停，等待`t`线程执行完之后才继续运行；如果调用了后两种形式的方法，则主线程只会等待给定的时间。

join方法实际上是调用者轮询检查线程alive状态，相关源码如下所示：

```java
public final void join() throws InterruptedException {
    join(0);
}
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;
        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }
        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

#### yield

yield方法只有一种形式`yield()`，它是Thread类的静态本地（native）方法。该方法的作用是让出CPU，但是不能保证让出成功，而且也不释放对象锁。

#### interrupt/interrupted/isInterrupted

interrupt方法是Thread类的成员方法，它只有一种形式`interrupt()`。该方法的作用是打断线程，设置中断标记为`true`，但是线程仍然会继续运行。设置中断标记的目的是为了让线程本身来处理打断，而不是直接中断线程的运行。比如在主函数中调用`t.intertupt()`可以打断`t`线程，`t`线程可以在线程体中判断打断标记是否为`true`，并进行相应的处理。

interrupted方法Thread类的静态方法，它只有一种形式`interrupted()`。该方法的作用是判断当前线程是否被打断，并清除打断标记。比如线程`t`已经被打断，在它的线程体中调用`Thread.interrupted()`，返回`true`，并且把打断标记重置为`false`。清除打断标记表示该线程还可以被打断。

isInterupted方法Thread类的成员方法，它只有一种形式`isInterrupted()`。该方法的作用是判断当前是否被打断，但是不清除打断标记。

interrupted方法和isInterupted方法本质上都是调用了Thread的本地方法`isInterrupted(boolean)`。

三个方法的相关源码如下所示：

```java
public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess();

    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();           // Just to set the interrupt flag
            b.interrupt(this);
            return;
        }
    }
    interrupt0();
}

private native void interrupt0();

public static boolean interrupted() {
    return currentThread().isInterrupted(true); // 使用当前线程，true表示清除打断标记
}

public boolean isInterrupted() {
    return isInterrupted(false); // false表示不清除打断标记
}

private native boolean isInterrupted(boolean ClearInterrupted);
```

## 线程池

> 《Java 并发编程的艺术》

Java中的线程池主要有两种：ThreadPoolExecutor线程池和ForkJoin线程池，其中前者是通常所说的和主要使用的线程池。还有一种用于执行异步任务或者周期性任务的线程池ScheduledThreadPoolExecutor，继承自ThreadPoolExecutor。

线程池的继承关系如下图所示：

![image_BFul929V-c](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261011481.png)

### ThreadPoolExecutor

ThreadPoolExecutor线程池提供了一种管理线程资源的工具。

ThreadPoolExecutor线程池的好处包括：

-   降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
-   提高响应速度。当任务到达时，任务不需要等到线程创建就能立即执行。
-   提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

线程池ThreadPoolExecutor最完整的构造函数：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler)
    ...
}
```

参数说明：

-   corePoolSize：核心线程数，最大的可以一直存活的线程数量；
-   workQueue：任务队列。当运行的线程数量达到核心线程数，新提交的任务就会被存放在队列中；
-   maximumPoolSize：最大线程数，通常大于核心线程数。当队列中存放的任务达到队列容量，可以创建非核心线程（救急线程）来执行任务，非核心线程的数量上限为最大线程数减去核心线程数；
-   keepAliveTime：当线程池中的线程数量大于核心线程数时，如果没有新的任务提交，核心线程外的线程不会立即销毁，而是会存活一段时间；
-   unit：keepAliveTime 参数的时间单位；
-   threadFactory：创建新线程的工厂；
-   handler：拒绝策略，也称为饱和策略，包括：
    -   AbortPolicy：抛出RejectedExecutionException异常（默认）；
    -   DiscardPolicy：直接丢弃该任务；
    -   DiscardOldestPolicy：丢弃最早的未处理的任务，该任务加入队列；
    -   CallerRunsPolicy：让调用者运行该任务；

ThreadPoolExecutor工作流程如下图所示（图片来自JavaGuide）：

![image_bEtPUtv7e6](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261011376.png)

#### 底层实现和原理

线程池定义了一个AtomicInteger类型的变量`ctl`，用高3位来表示线程池的状态，用低29位来表示线程池中的线程数量。线程池把线程池状态与线程个数存储在一个原子变量`ctl`中，目的不是为了减少存储空间，而是为了可以用一次CAS原子操作进行赋值，保证线程池状态和线程数量的统一。

线程池有5种状态，如下表所示：

| 状态             | ctl高3位 | 接受新任务 | 处理阻塞队列中的任务 | 说明                           |
| -------------- | ------ | ----- | ---------- | ---------------------------- |
| RUNNING（运行）    | 111    | Y     | Y          | 接受新的任务，处理排队的任务               |
| SHUTDOWN（关闭）   | 000    | N     | Y          | 不接受新的任务，但处理排队的任务             |
| STOP（停止）       | 001    | N     | N          | 不接受新的任务，不处理排队的任务，尝试打断正在执行的任务 |
| TIDYING（整理）    | 010    | -     | -          | 任务执行完毕或被终止，工作线程为0的时候         |
| TERMINATED（终止） | 011    | -     | -          | 执行完`terminated`方法            |

当线程池处于不同状态时，比较变量`ctl`的大小：`TERMINATED > TIDYING > STOP > SHUTDOWN > RUNNING`，其中`RUNING`最高位为1，此时`ctl`为负数，所以最小。

相关源码如下所示：

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = Integer.SIZE - 3; // 32-3=29
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1; // 线程池容量、最大线程数

    // runState is stored in the high-order bits
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
    
    // Packing and unpacking ctl
    private static int runStateOf(int c)     { return c & ~CAPACITY; }
    private static int workerCountOf(int c)  { return c & CAPACITY; }
    private static int ctlOf(int rs, int wc) { return rs | wc; }
    ...
}
```

线程池的状态转换包括：

-   RUNNING -> SHUTDOWN：执行`shutdown()`；
-   RUNNING/SHUTDOWN -> STOP：执行`shutdownNow()`；
-   SHUTDOWN -> TIDYING：当`queue`和`pool`都为空时；
-   STOP -> TIDYING：当`pool`为空时；
-   TIDYING -> TERMINATED：当`terminated()`方法结束时；

线程池的状态转换如下图所示：

![image_EVAOE8uouH](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261011682.png)

ThreadPoolExecutor的常用方法包括：

-   void execute(Runnable command)：执行任务；
-   Future submit(Callable task)：提交任务task，返回一个Future对象，用来获得任务执行结果；
-   void shutdown()：关闭线程池，线程池状态变为SHUTDOWN，不会接收新任务，但已提交任务会执行完；
-   void shutdownNow()：立刻关闭线程池，线程池状态变为STOP，不会接收新任务，会将队列中的任务返回，并尝试打断正在执行的任务；
-   boolean isShutdown()：如果线程池不在RUNNING状态，返回true，否则返回false；
-   boolean isTerminated()：如果线程池在TERMINATED状态，返回true，否则返回false；

#### 执行execute方法和submit方法的区别是什么呢？

execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否。

submit方法用于提交需要返回值的任务。线程池会返回一个Future对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的`get()`方法来获取返回值，`get()`方法会阻塞当前线程直到任务完成。

#### 如何自定义拒绝策略？

拒绝策略都实现了RejectedExecutionHandler接口，如果需要自定义拒绝策略，需要实现该接口。

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

#### 创建线程池多少比较合适？

线程池过小会导致程序不能充分地利用系统资源、容易导致饥饿，过大会导致更多的线程上下文切换，占用更多内存。

对于CPU密集型任务，通常采用`CPU核数+1`能够实现最优的CPU利用率，`+1`是保证当线程由于页缺失故障（操作系统）或其它原因导致暂停时，额外的这个线程就能顶上去，保证CPU时钟周期不被浪费。

对于IO密集型任务，CPU不总是处于繁忙状态。当程序执行业务计算时，这时候会使用CPU资源，但是当执行I/O操作时，比如读写文件或者读写数据库，这时候CPU就闲下来了，可以利用多线程提高它的利用率。

经验公式如下为：

```纯文本
线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU 计算时间+等待时间) / CPU 计算时间
```

例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 CPU 被 100% 利用，套用公式，得到`4 * 100% * 100% / 50% = 8`。

### ScheduledThreadPoolExecutor

==TODO==

### ForkJoinPool

ForkJoinPool是JDK1.7加入一种新的线程池实现，它使用的是一种分治思想，适用于能够进行任务拆分的CPU密集型运算。

所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。对于递归相关的一些计算，比如归并排序、斐波那契数列，都可以用分治思想进行求解。

ForkJoinPool在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率。

ForkJoinPool默认会创建与CPU核心数大小相同的线程池。

### Executors

Executors是线程池工具类，定义了一系列静态方法，用来创建已经封装好的线程池。

相关源码如下所示：

```java
public class Executors {
    // 方法体省略
    public static ExecutorService newCachedThreadPool();
    public static ExecutorService newCachedThreadPool(ThreadFactory);
    public static ExecutorService newFixedThreadPool(int)
    public static ExecutorService newFixedThreadPool(int, ThreadFactory);
    public static ScheduledExecutorService newScheduledThreadPool(int)
    public static ScheduledExecutorService newScheduledThreadPool(int, ThreadFactory);
    public static ExecutorService newSingleThreadExecutor();
    public static ExecutorService newSingleThreadExecutor(ThreadFactory);
    public static ExecutorService newWorkStealingPool();
    public static ExecutorService newWorkStealingPool(int)
    ...
}
```

#### newFixedThreadPool

创建一个固定大小的线程池，核心线程数等于最大线程数，因此不需要设置超时时间。阻塞队列为LinkedBlockingQueue，是无界的，可以存放任意数量的任务。该线程池可以用来控制线程最大并发数，超出核心线程数的任务会在队列中等待。

相关源码如下所示：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

该线程池适合数量已知，比较耗时的任务。

因为任务队列没有长度限制，如果任务数量过多，就会一直向队列中添加，可能会导致OOM（OutOfMemoryError）。

#### newSingleThreadExecutor

创建一个只有一个线程的线程池，核心线程数和最大线程数均为1，因此不需要设置超时时间。阻塞队列为LinkedBlockingQueue，是无界的，可以存放任意数量的任务。该线程池只会用唯一的工作线程来执行任务，当任务数大于1时，任务就会放入队列排队。当任务执行完毕，这个唯一的线程也不会被释放。

相关源码如下所示：

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

该线程池适合任务数量不多，需要所有任务按照提交顺序执行的情况。

因为任务队列没有长度限制，如果任务数量过多，就会一直向队列中添加，可能会导致OOM。

#### newCachedThreadPool

创建一个可缓存线程的线程池，核心线程数为0，最大线程数为`Integer.MAX_VALUE`。该线程池没有核心线程，所有线程都是非核心线程，生存时间为60秒。如果线程池中的线程没有任务需要执行，超过生存时间就可以进行回收。阻塞队列为SynchronousQueue，没有容量，意味着如果没有线程来取任务，那么任务就无法提交到线程池中。

相关源码如下所示：

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

该线程池适合任务数比较密集，但每个任务执行时间较短的情况。

因为线程数量没有限制，如果任务数量过多，就会一直创建线程，可能会导致OOM。

#### newScheduledThreadPool

创建一个任务调度线程池，给定核心线程数，最大线程数为`Integer.MAX_VALUE`。   阻塞队列为DelayedWorkQueue。当任务多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。该线程池用于执行定时和周期性任务。

相关源码如下所示：

```java
// Executors类
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
// ScheduledExecutorService类
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

因为线程数量没有限制，可能会导致OOM。

#### newWorkStealingPool

创建一个ForkJoin线程池。

相关源码如下所示：

```java
public static ExecutorService newWorkStealingPool() {
    return new ForkJoinPool
        (Runtime.getRuntime().availableProcessors(),
         ForkJoinPool.defaultForkJoinWorkerThreadFactory,
         null, true);
}
```

## synchronized

synchronized关键字是用来保证多个线程之间访问共享资源的同步性，保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

### 线程不安全

如果多个线程同时访问共享资源，不同线程对共享资源的读取和写入会对其他线程造成影响（主要是写入），导致线程安全问题。

举例，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，代码如下所示：

```java
public class TestCounter {
    public static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter++;
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                counter--;
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println("counter=" + counter);
    }
}
```

变量`counter`的预期结果是零，但也可能是正数或者负数，因为Java中对变量的自增、自减并不是原子操作，而且多个线程对共享资源读写操作时很可能发生了指令交错，导致了程序结果无法预测的问题。

### 临界区

如果一段代码块存在对共享资源的多线程读写操作，称这段代码块为**临界区**。比如：

```java
static int counter = 0;
static void increment(){ // 临界区
    counter++;
}
static void decrement(){ // 临界区
    counter--;
}
```

如果多个线程在临界区内执行，由于代码或底层指令的执行顺序不同而导致结果无法预测，称之为发生了**竞态条件**。

为了避免临界区的竞态条件发生，可以使用：

-   阻塞式解决方案，比如synchronized、Lock。
-   非阻塞式解决方案，比如CAS。

### 介绍

synchronized，一般称为“对象锁”，它采用互斥的方式让同一时刻至多只有一个线程能持有为“对象锁”，其它线程再想获取这个为“对象锁”时就会阻塞住。这样就能保证持有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

虽然 Java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：

-   互斥是保证临界区的竞态条件不发生，同一时刻只能有一个线程执行临界区代码。
-   同步是由于线程执行的先后、顺序不同，需要一个线程等待其它线程运行到某个点。

synchronized关键字主要有三种使用方式：

1.  修饰实例方法，此时锁是当前对象。
2.  修饰静态方法，此时锁是类对象。
3.  修饰代码块，此时需要指定锁对象。

代码如下所示：

```java
public class Test {
    // 1. 修饰实例方法
    public synchronized void increment() {
        // 临界区
    }
    // 2. 修饰静态方法
    public static synchronized void print() {
        // 临界区
    }
    
    public void codeblock() {
        // 3. 修饰代码块
        synchronized(对象) {
            // 临界区
        }
    }
}
```

synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。

在Java早期版本中，synchronized属于重量级锁，效率低下，因为使用了监视器`Monitor`锁。`Monitor`锁是依赖操作系统来实现的，如果要暂停或者唤醒一个线程，都需要操作系统帮忙完成。

JDK1.6对synchronized的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。需要注意的是，这些优化对使用者来说是透明的，使用语法仍然是synchronized。

锁主要存在四种状态，随着竞争的激烈而逐渐升级，依次是无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。注意锁可以升级，不可以降级，这种策略是为了提高获得锁和释放锁的效率。

### 线程安全分析

对于成员变量和静态变量，

-   没有共享，线程安全。
-   共享了，如果只有读操作，则线程安全；如果有读写操作，则这段代码是临界区，需要考虑线程安全问题。

对于局部变量，

-   局部变量是线程安全的。
-   局部变量引用的对象未必是线程安全的，如果该对象没有逃离方法的作用访问，是线程安全的；如果该对象逃离方法的作用范围，需要考虑线程安全。

常见的线程安全类有：

-   String，不可变类，线程安全。
-   Integer，不可变类，线程安全。
-   StringBuffer，可变类，方法上有synchronized修饰，保证线程安全。
-   Random。
-   Vector，方法上有synchronized修饰，保证线程安。
-   Hashtable，方法上有synchronized修饰，保证线程安全。
-   java.util.concurrent包下的类。

注意，线程安全是指多个线程调用它们同一个实例的某个方法时，不会出现问题。线程安全类的的每一个方法是原子的，但是多个方法的组合不是原子的，仍然需要考虑线程安全问题。

### 底层实现和原理

> [Java对象头详解](https://www.jianshu.com/p/3d38cba67f8b "Java对象头详解")
> [Java对象头与锁](https://www.cnblogs.com/ZoHy/p/11313155.html "Java对象头与锁")

synchronized加锁和解锁依赖于锁对象的对象头。简单来说，Java把锁对象当前的锁状态记录在对象头中，并根据锁状态进行对应的加锁和解锁流程。

Java对象由多部分构成：对象头，属性字段、补齐区域等。补齐区域是指如果对象总大小不是4字节的整数倍，会填充上一段内存地址使之成为整数倍。

每个Java对象都有一个对象头，对象头由`Mark Word`，`Class Word`组成。如果该对象是数组，对象头还包括数组长度。

-   `Mark Word`：用来存储对象自身的运行时数据，如`identity_hashcode`、分代年龄、锁标志位等。
-   `Class Word`：用来存储对象的类型指针，该指针指向它的类，通过这个指针确定对象是哪个类的实例。

`Mark Word`和`Class Word`的长度与JVM的位数相同，32位JVM为32位，64位JVM为64位。

对于32位JVM，非数组和数组对象的对象头如下所示：

```纯文本
// 非数组对象对象头
|------------------------------------------------|
|              Object Header (64 bits)           |
|-----------------------|------------------------|
|  Mark Word (32 bits)  |  Klass Word (32 bits)  |
|-----------------------|------------------------|

// 数组对象对象头
|---------------------------------------------------------------------------|
|                         Object Header (96 bits)                           |
|-----------------------|------------------------|--------------------------|
|  Mark Word (32 bits)  |  Klass Word (32 bits)  |  array length (32 bits)  |
|-----------------------|------------------------|--------------------------|
```

32位JVM和64位JVM的`Mark Word`如下所示：

```纯文本
// 32位 Mark Word
|-------------------------------------------------------|--------------------|
|                  Mark Word (32 bits)                  |       State        |
|-------------------------------------------------------|--------------------|
| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
|-------------------------------------------------------|--------------------|
|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |
|-------------------------------------------------------|--------------------|
|               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|               ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                              | lock:2 |    Marked for GC   |
|-------------------------------------------------------|--------------------|

// 64位 Mark Word
|------------------------------------------------------------------------------|--------------------|
|                                  Mark Word (64 bits)                         |       State        |
|------------------------------------------------------------------------------|--------------------|
| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |       Normal       |
|------------------------------------------------------------------------------|--------------------|
| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |       Biased       |
|------------------------------------------------------------------------------|--------------------|
|                       ptr_to_lock_record:62                         | lock:2 | Lightweight Locked |
|------------------------------------------------------------------------------|--------------------|
|                     ptr_to_heavyweight_monitor:62                   | lock:2 | Heavyweight Locked |
|------------------------------------------------------------------------------|--------------------|
|                                                                     | lock:2 |    Marked for GC   |
|------------------------------------------------------------------------------|--------------------|
```

**以32位JVM的对象头为例**，各部分的含义如下所示：

-   identity\_hashcode：对象的哈希值，占25个二进制位。
-   age：对象的分代年龄，占4个二进制位。在垃圾回收中，如果对象在存活区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，年龄阈值为15，因为4个二进制最大表示15。
-   biased\_lock：偏向锁标志位，占1个二进制位。为1时表示对象使用偏向锁，为0时表示对象没有使用偏向锁。
-   lock：锁标志位，占2个标志位，表示不同的锁状态。
-   thread：持有偏向锁的线程ID，占23个二进制位。
-   epoch：加偏向锁的时间戳，占2个二进制位。
-   ptr\_to\_lock\_record：指向栈中锁记录的指针，占30个二进制位。
-   ptr\_to\_heavyweight\_monitor：指向监视器锁`Monitor`对象的指针，占30个二进制位。

偏向锁标志位和锁标志位的状态如下表所示：

| biased\_lock | lock | 状态   |
| ------------ | ---- | ---- |
| 0            | 01   | 无锁   |
| 1            | 01   | 偏向锁  |
|              | 00   | 轻量级锁 |
|              | 10   | 重量级锁 |
|              | 11   | GC标记 |

当对象处于不同的锁状态，该对象的对象头的`Mark Word`会被替换成不同的内容：

-   **当对象未加锁时**，`Mark Word`包含哈希值、分代年龄、偏向锁标志位和锁标志位，其中偏向锁标志位为`0`，锁标志位为`01`。
-   **当对象加偏向锁时**，`Mark Word`包含持有偏向锁的线程ID、加偏向锁的时间戳、分代年龄、偏向锁标志位和锁标志位，其中偏向锁标志位为`1`，锁标志位为`01`。
-   **当对象加轻量级锁时**，`Mark Word`被设置为指向栈里面的锁记录的指针，没有偏向锁标志位，锁标志位为`00`。
-   **当对象加重量级锁时**，`Mark Word`被设置为指向`Monitor`对象的指针，没有偏向锁标志位，锁标志位为`11`。

#### 重量级锁

每个Java对象都可以关联一个Monitor对象，用于实现重量级锁。重量级锁加锁和解锁都需要使用锁对象关联的`Monitor`对象，如下图所示（图片来自 Java并发编程 课件）：

![image_Rzy6ldBdCO](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261012730.png)

说明：

-   当没有任何线程持有重量级锁时，Monitor对象中的Owner线程为`null`，计数器为0。Owner用来指示持有锁的线程，计数器用来记录一个线程上锁的次数，计数器为0表示没有任何线程持有锁。
-   当Thread-2执行`synchronized(obj)`并成功竞争到锁时，Monitor对象中的Owner线程会被设置为Thread-2，计数器加1。同时，还要把锁对象对象头的`Mark Word`修改为指向Monitor对象的指针，把`Mark Word`保存在Monitor对象中。
    -   如果Thread-2再次执行`synchronized(obj)`，则发生了锁重入，Monitor对象中的计数器加1。
    -   如果Thread-2不想继续执行，可以调用锁对象的`wait()/wait(long)`方法，释放锁，进入Monitor对象的WaitSet，变为WAITING/TIMED\_WAITING状态。注意，TIMED\_WAITING 线程可以在超时时间内被唤醒，或者在超时时间到达后自动进入EntryList，竞争锁，得到锁后恢复运行。
-   在Thread-2持有锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行`synchronized(obj)`，就会进入EntryList，并变成BLOCKED（阻塞）状态。总结，EntryList中的线程没有竞争到锁，处于BLOCKED状态。BLOCKED 线程会在Owner线程释放锁时**自动唤醒**。
-   当Thread-2执行完同步代码块的内容，JVM会调用锁对象的notify/notifyAll方法唤醒EntryList中阻塞的线程来竞争锁，竞争是非公平的。
    -   notify方法只会选择WaitSet中的一个线程进行唤醒，该线程进入EntryList，竞争锁，没有被唤醒的线程仍然会待在WaitSet，无法恢复运行。
    -   notifyAll方法会唤醒WaitSet中的所有线程，都进入EntryList，竞争锁，得到锁的线程恢复运行。
-   WaitSet中的线程（Thread-0，Thread-1）是之前获得过锁，但是可能调用wait方法进入WAITING（等待）状态的线程。

重量级锁synchronized的底层原理是同步器指令：

-   对于synchronized修饰的代码块，JVM在代码块的字节码前后分别添加`monitorenter`和`monitorexit`指令，分别指向同步代码块的开始位置和结束位置。当线程进入同步代码块时，线程会尝试获取锁对象的Monitor对象，并修改锁对象的对象头和Monitor对象。
    -   如果成功，表示成功获得锁。
    -   如果失败，就会进入Monitor对象的EntryList，进入阻塞状态。
-   对于synchronized修饰的方法，JVM会给方法设置`ACC_SYNCHRONIZED`标志，调用方法的时候根据这个标志判断该方法是否是同步方法。

**总结**，重量级锁加锁就是把Monitor对象中的Owner设置为持有锁的线程，计数器加1，把锁对象的`Mark Word`修改为指向Monitor对象的指针，同时把`Mark Word`保存在Monitor中；解锁就是把Monitor对象中的Onwer设置为`null`，计数器减1，恢复锁对象的`Mark Word`。

#### 轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多个线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。需要注意的是，轻量级锁对使用者是透明的，即语法仍然是synchronized。

轻量级锁使用了CAS机制来尝试设置锁对象为轻量级锁，把锁记录的指针保存在所对象的对象头，并用锁记录来记录锁重入的次数。

> CAS（compare and swap，比较并交换）是一种轻量级锁，可以用来保证线程安全，而且开销比synchronized小，适用于读多写少的场景。

轻量级锁的基本结果如下图所示（参考 Java并发编程 课件）：

![image_2Dab9a0TMA](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261012445.png)

说明：

-   线程先创建`Lock Record`（锁记录）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁对象的`Mark Word`。
-   让锁记录中`Object reference`（对象引用）指向锁对象，并尝试用 `CAS` 替换锁对象的`Mark Word`为锁记录的指针，并将`Mark Word`的值存入锁记录：
    -   如果`CAS`替换成功，则对象头的`Mark Word`被设置为指向锁记录的指针和锁状态状态`00`，表示由该线程给对象加轻量级锁。
    -   如果`CAS`替换失败，有两种情况：
        -   其它线程已经持有了该锁对象的轻量级锁，表明有竞争，进入锁膨胀过程。
        -   自己执行了锁重入，那么需要再添加一条值为`null`锁记录，表示锁重入计数。
-   当退出synchronized代码块（解锁时），如果锁记录的值为`null`，表示有重入，此时需要弹出一个锁记录，表示重入计数减1。
-   当退出synchronized代码块（解锁时），如果锁记录的值不为`null`，就会尝试用`CAS`将`Mark Word`的值恢复给锁对象的对象头。
    -   如果成功，则解锁成功。
    -   如果失败，说明轻量级锁进行了锁膨胀，需要进入重量级锁解锁流程。参加锁膨胀。

#### 锁膨胀

如果在尝试加轻量级锁的过程中，`CAS`操作无法成功，可能是因为已经有其它线程为此对象加上了轻量级锁（有竞争）。这时需要进行锁膨胀，将轻量级锁变为重量级锁。此时锁对象的`Mark Word`被设置为指向对象的监视器Monitor的指针，没有偏向锁标志位，锁标志位为`10`。

锁膨胀的流程如下图所示（参考 Java并发编程 课件）：

![image_vIiXAT6Fs6](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261012405.png)

说明：

-   当Thread-1尝试轻量级加锁时，如果Thread-0已经对该对象加了轻量级锁，那么Thread-1加锁失败，进入锁膨胀流程：
    -   虚拟机为锁对象申请Monitor对象，把锁对象对象头的`Mark Word`修改为指向Monitor对象的指针，把Monitor中的Owner设置为 Thread-0。
    -   Thread-1会进入Monitor对象的EntryList阻塞。
-   当Thread-0退出同步块解锁时，尝试使用`CAS`将`Mark Word`的值恢复给对象头，失败。这时会进入重量级锁解锁流程，即按照锁对象对象头中的Monitor指针找到Monitor对象，把`Mark Word`保存在其中，设置Owner为`null`，唤醒EntryList中阻塞的线程。

#### 自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持有锁的线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。

说明：

-   自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势。
-   在 Java 6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋。
-   Java 7之后不能控制是否开启自旋功能。

#### 偏向锁

轻量级锁在没有竞争时，比如就自己一个线程，每次重入仍然需要执行`CAS`操作。

Java 6引入了偏向锁来做进一步优化：第一次使用`CAS`将线程ID设置到锁对象对象头的`Mark Word`，之后发现这个线程ID是自己，表示没有竞争，不用重新`CAS`。只要以后不发生竞争，这个锁对象就归该线程所有。此时`Mark Word`保存线程ID和加锁的时间戳，其中偏向锁标志位为`1`，锁标志位为`01`。

需要注意的是：

-   如果调用了锁对象的`hashCode()`方法，因为锁对象的`Mark Word`中存储的是线程ID，那么偏向锁会被撤销。轻量级锁会在锁记录中记录`hashcode`，重量级锁会在`Monitor`中记录`hashcode`。
-   如果有其它线程使用了偏向锁对象，偏向锁会升级为轻量级锁。
-   如果锁对象调用了`wait/notify`方法，偏向锁会升级为重量级锁。

批量重偏向：如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的线程ID。当撤销偏向锁阈值超过`20`次后，JVM会重新偏向至加锁线程。

批量撤销：当撤销偏向锁阈值超过`40`次后，JVM会觉得自己偏向错了，根本不应该偏向，于是整个类的对象都会变为不可偏向的。

#### 锁消除

Java虚拟机在JIT编译时，通过扫描运行上下文，去除不可能存在共享资源竞争的锁。通过锁消除，可以节省没有意义的请求锁和释放锁的时间。比如：

```java
@Override
public synchronized StringBuffer append(String str) {
    toStringCache = null;
    super.append(str);
    return this;
}
```

该方法是线程安全的。如果在代码中只有一个线程执行该方法，没有线程安全问题，`synchronized`就可能被锁消除去掉。

#### 锁粗化

对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化。

举一个比较极端的例子：

```java
// 锁粗化前
for(int i=0;i<size;i++){
    synchronized(lock){
    }
}
// 锁粗化后
synchronized(lock){
    for(int i=0;i<size;i++){
    }
}
```

每次进入循环都需要加锁，浪费时间，锁粗化可以把加锁优化到循环外面。

## volatile

volatile关键字的主要作用就是保证变量的可见性和防止指令重排序。

在当前的Java内存模型下，线程可以把变量保存到线程的本地内存中，加快线程的读取速度，而不是直接在主存中进行读写。虽然提高了访问速度，但是可能造成数据的不一致。比如一个线程在主存中修改了一个变量的值，而另外一个线程还在使用本地内存的拷贝。

volatile关键字的底层实现原理是内存屏障：

-   对 volatile 变量的写指令之后，加入写屏障。
-   对 volatile 变量的读指令之前，加入读屏障。

保证可见性：

-   写屏障保证在该屏障之前，对共享变量的改动，都同步到主存当中。
-   读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据。

保证有序性：

-   写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后。
-   读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前。

### synchronized和volatile的区别

-   volatile用来解决变量在多个线程之间的可见性，而synchronized用来解决变量的原子性。
-   volatile能保证数据的可见性，但不能保证数据的原子性，而synchronize两者都能保证。
-   volatile是线程同步的轻量级实现。多线程访问volatile不会发生阻塞，而synchronized可能会发生阻塞。
-   volatile只能用于变量，而synchronized可以修饰方法以及代码块。

## 线程活跃性问题

线程活跃性问题有三种：死锁、活锁和饥饿。

### 死锁

死锁是指多个进程或多个线程因竞争资源而造成的一种僵局，互相等待，无法继续运行。

当一个线程需要获取多把锁才能运行，就容易发生死锁。举例，`t1`线程先获得`A`对象锁，接下来想获取`B`对象的锁，`t2`线程先获得`B`对象锁，接下来想获取`A`对象的锁，但是两个线程都获取不到各自的第二个锁，代码如下所示：

```java
public class TestDeadLock {
    public static void main(String[] args) {
        Object A = new Object();
        Object B = new Object();
        Thread t1 = new Thread(() -> {
            synchronized (A) {
                System.out.println(Thread.currentThread().getName() + " - lock A");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (B) {
                    System.out.println(Thread.currentThread().getName() + " - lock B");
                }
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            synchronized (B) {
                System.out.println(Thread.currentThread().getName() + " - lock B");
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (A) {
                    System.out.println(Thread.currentThread().getName() + " - lock A");
                }
            }
        }, "t2");
        t1.start();
        t2.start();
    }
}
```

死锁的四个必要条件是：

1.  互斥条件：一个资源只被一个线程占有。
2.  不可抢占条件：一个线程占有的资源不能被其他线程抢占。
3.  请求和保持条件：一个线程请求新的资源，而且不释放已经占有的资源。
4.  循环等待条件：两个或多个线程循环等待其他线程释放资源。

如何避免死锁：

1.  破坏不可抢占条件。允许进程或线程抢占其他资源，设置一个超时时间，如果在规定时间无法获得，就释放自己占有的资源。
2.  破坏请求和保持条件。要求进程或线程在运行之前，必须一次性申请需要的所有资源，如果无法一次性申请，就必须等待。
3.  破坏循环等待条件。将系统中的所有资源统一编号，进程或线程必须按顺序申请资源。
4.  银行家算法。

#### 如何检测死锁

1）使用jconsole工具（Java管理控制台），连接到本地进程或远程进程，在线程界面可以检测死锁。

2）使用jps和jstack，先用jps定位进程id，再用jstack定位死锁。

```bash
cmd> jconsole

cmd> jps
14464 Launcher
2068 Jps
14796 TestDeadLock

cmd> jstack 14796
// 省略部分输出
Found one Java-level deadlock:
=============================
"t2":
  waiting to lock monitor 0x0000000002dfbdf8 (object 0x000000076ac88c70, a java.lang.Object),
  which is held by "t1"
"t1":
  waiting to lock monitor 0x0000000002dfa958 (object 0x000000076ac88c80, a java.lang.Object),
  which is held by "t2"
```

#### 哲学家就餐问题

哲学家就餐问题是一个著名的死锁案例。

有五位哲学家，围坐在圆桌旁。他们只做两件事，思考和吃饭：

-   思考一会吃口饭，吃完饭后接着思考；
-   吃饭时要用两根筷子，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子；
-   如果筷子被身边的人拿着，自己就得等待；

代码如下所示：

```java
// 筷子
class Chopstick {
    private String name;

    public Chopstick(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "筷子{" + name + '}';
    }
}
// 哲学家
class Philosopher extends Thread {
    private final Chopstick left;
    private final Chopstick right;

    public Philosopher(String name, Chopstick left, Chopstick right) {
        super(name);
        this.left = left;
        this.right = right;
    }

    private void eat() throws InterruptedException {
        System.out.println(getName() + " 使用 " + left + " 和 " + right + " eating...");
        Thread.sleep(1000);
    }

    @Override
    public void run() {
        while (true) {
            synchronized (left) { // 获得左手筷子
                synchronized (right) { // 获得右手筷子
                    try {
                        eat();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }
}
// 测试
public class TestPhilosopher {
    public static void main(String[] args) {
        Chopstick c1 = new Chopstick("1");
        Chopstick c2 = new Chopstick("2");
        Chopstick c3 = new Chopstick("3");
        Chopstick c4 = new Chopstick("4");
        Chopstick c5 = new Chopstick("5");
        new Philosopher("苏格拉底", c1, c2).start();
        new Philosopher("柏拉图", c2, c3).start();
        new Philosopher("亚里士多德", c3, c4).start();
        new Philosopher("赫拉克利特", c4, c5).start();
        new Philosopher("阿基米德", c5, c1).start();
    }
}
```

上述代码运行一会就运行不下去了，使用jconsole工具可以检测到死锁。

### 活锁

活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。代码如下所示：

```java
public class TestLiveLock {
    static volatile int count = 10;
    static final Object lock = new Object();
    
    public static void main(String[] args) {
        new Thread(() -> {
            // 期望减到 0 退出循环
            while (count > 0) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                count--;
                System.out.println(Thread.currentThread().getName() + " count: " + count);
            }
        }, "t1").start();
        new Thread(() -> {
            // 期望超过 20 退出循环
            while (count < 20) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                count++;
                System.out.println(Thread.currentThread().getName() + "count: " + count);
            }
        }, "t2").start();
    }
}
```

### 饥饿

一个线程因为处理时间全部被其他线程抢走而不能运行，这种状态就是饥饿。比如线程优先级“不均”，在CPU繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。

解决饥饿问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。

这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。方案二的适用场景相对来说更多一些。

## ThreadLocal

通常情况下，多线程访问共享数据需要考虑同步问题。如果多个线程访问同一个共享数据，但是不想考虑该数据的同步问题，可以使用ThreadLocal类型的变量。

如果创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有一个该变量的线程本地副本，可以使用`get`和`set`方法来获取和修改当前线程所存的副本，从而避免了线程安全问题。

如何创建一个ThreadLocal变量，比如：

```java
public ThreadLocal<Integer> num = new ThreadLocal<Integer>();
```

### 底层实现和原理

Thread类的相关源码如下所示：

```java
public class Thread implements Runnable {
    //与此线程有关的ThreadLocal值。由ThreadLocal类维护
    ThreadLocal.ThreadLocalMap threadLocals = null;
    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
    ......
}
```

从源码可以看出，每个Thread实例都会有两个ThreadLocalMap类型的变量：一个是`threadLocals`、另一个是`inheritableThreadLocals`。ThreadLocalMap类是ThreadLocal中自定义的哈希表类，用来保存线程的局部变量。

默认情况下这两个变量都是`null`，只有在线程中调用`threadLocal`变量的`set`或`get`方法时才创建它们。通过`threadLocal`变量访问线程局部变量时，实际是先通过当前线程得到其中的`threadLocals`实例变量，然后调用对应的`getEntry`和`set`方法。

ThreadLocal类的源码如下所示：

```java
public class ThreadLocal {
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
    
    static class ThreadLocalMap {
        static class Entry extends WeakReference<ThreadLocal<?>> {
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
    
        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            ......
        }
    }
}
```

通过上面这些内容，我们足以得出结论：

-   每个线程Thread实例中都有`ThreadLocal.ThreadLocalMap`实例，用来保存以`ThreadLocal`为`key`，`Object`对象为`value`的键值对。
-   线程的局部变量最终是放在了线程的`ThreadLocal.ThreadLocalMap`中，而不是ThreadLocal。ThreadLocal可以理解为只是ThreadLocalMap的封装。
-   在ThrealLocal类中，通过`Thread.currentThread()`获取到当前线程对象，然后通过`getMap(Thread)`可以访问到该线程的`ThreadLocalMap`对象。

### ThreadLocal内存泄露问题

`ThreadLocalMap`中的`Entry`继承自弱引用`WeakReference`类，其中`Entry`的`key`为`ThreadLocal`对象，而`value`是`Object`对象的强引用。所以，如果`ThreadLocal`没有被外部强引用，在垃圾回收的时候，`key`会被回收，而`value`不会被回收。这样一来，`ThreadLocalMap`中就会出现`key`为`null`的`Entry`。

假如线程长时间运行，`value`可能一直没有被回收，就会产生内存泄露。其实`ThreadLocalMap`已经考虑了这种情况，在调用`set`、`get`、`remove`方法的时候，会清理掉`key`为`null`的记录。

使用完`ThreadLocal`后，**最好**手动调用`remove`方法，防止内存泄漏。

### ThreadLocal的实际例子

> [Mybatis入门](https://mybatis.org/mybatis-3/zh/getting-started.html "Mybatis入门")

在Mybatis中，SqlSession是主要的接口之一，可以通过这个接口来执行命令，获取映射器示例和管理事务。

每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。

如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。

# 并发工具包JUC

## LockSupport

> [Java多线程进阶（五）—— J.U.C之locks框架：LockSupport](https://segmentfault.com/a/1190000015562456 "Java多线程进阶（五）—— J.U.C之locks框架：LockSupport")

LockSupport是用来实现线程暂停和唤醒的工具类，比如AQS就使用它来控制线程的暂停和唤醒。

LockSupport有两个核心的静态方法：

-   park()：用来暂停当前线程，通常在线程体中使用；
-   unpark(Thread)：用来唤醒指定线程；

LockSupport还有两种形式的park方法：

-   parkNanos(long)：暂停线程一段时间；
-   parkUntil(long)：暂停线程直到某一时间点；

LockSupport的park/unpark类似于wait/notify，二者的区别在于：

-   `wait/notify`必须配合`synchronized`一起使用，而`park/unpark`不需要；
-   `park/unpark`以线程为单位进行暂停和唤醒，从语义上更加清晰，而`notify`只能随机唤醒一个等待线程或唤醒所有等待线程，达不到线程级别的精确性；
-   `park/unpark`可以先`unpark`，而`wait/notify`不能先`notify`;

LockSupport使用了一种`permit`（许可）的概念来实现暂停和唤醒线程的功能，可以把许可看成是一种0/1信号量，但与信号量不同的是，许可的累加上限是1。

-   初始时，`permit`为0；
-   当调用`park`方法时，
    -   如果`permit`为0，则当前线程暂停，进入阻塞状态；
    -   如果`permit`为1，则`permit`减1，当前线程不会暂停，而是继续运行；
-   当调用`unpark`方法时，
    -   如果指定线程被`park`方法暂停（`permit`为0），处于阻塞状态，则唤醒该线程（`permit`仍然为0）；
    -   如果指定线程正在运行（`permit`为0），没有被`park`方法暂停，则`permit`变为1；
    -   如果`permit`为1，达到上限，则该方法不起作用，`permit`保持不变；

LockSupport相关源码如下所示：

```java
public class LockSupport {
    private LockSupport() {} // Cannot be instantiated.
    
    public static void unpark(Thread thread) {
        if (thread != null)
            UNSAFE.unpark(thread);
    }
    
    public static void park() {
        UNSAFE.park(false, 0L);
    }
    
    public static void parkNanos(long nanos) {
        if (nanos > 0)
            UNSAFE.park(false, nanos);
    }
    
    public static void parkUntil(long deadline) {
        UNSAFE.park(true, deadline);
    }
    
    private static final sun.misc.Unsafe UNSAFE;
    ...
}
```

## AQS

> [Java并发之AQS详解](https://www.cnblogs.com/waterystone/p/4920797.html "Java并发之AQS详解")

AQS（AbstractQueuedSynchronizer，抽象队列同步器）是一个用来构建同步器的框架，提供了通用的同步器机制，主要是用来实现自定义的同步器。

早期的Java程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在JSR166（Java规范提案）中创建了AQS，提供了通用的同步器机制。

AQS要实现的功能目标：

-   阻塞版本获取锁（acquire方法）和非阻塞版本尝试获取锁（tryAcquire方法）。
-   获取锁超时机制。
-   通过打断取消机制（interrupt方法）。
-   独占机制及共享机制。
-   条件不满足时的等待机制（类似wait/notify）。

AQS的核心思想是，如果请求的共享资源空闲，则将当前请求资源的线程设置为工作线程，并且将共享资源设置为占用状态。如果请求的共享资源被占用，那么就需要一套线程阻塞和唤醒的机制，这个机制是用双向队列实现的，即将暂时获取不到锁的线程加入到队列中。

AQS的队列是双向的，如下图所示：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201029210939.png?token=AE4F4YPIM2ZLFJ7TTHKO6YC7TK72W)

AQS为同步状态的原子性管理、线程的暂停和唤醒以及线程排队提供了一种通用的机制。

-   用一个int类型的`state`属性来表示资源的同步状态，使用`volatile`和`CAS`机制保证原子性。AQS中有3个方法来读取和更新这个状态：
    -   getState()：获取`state`状态。
    -   setState(int)：设置`state`状态。
    -   compareAndSetState(int)：使用`CAS`机制设置`state`状态。
-   提供了线程等待队列，没获得锁的线程会进入队列阻塞，类似于`Monitor`的`EntryList`。
-   提供了`condition`条件变量来实现线程的等待和唤醒机制，类似于`Monitor`的`WaitSet`，但是`AQS`支持多个条件变量。
-   使用`park/unpark`方法来实现线程的暂停和恢复，类似于wait/notify，但是`park/unpark`是针对线程的，控制粒度比较精细。

AQS定义了两种获取共享资源的方式：

-   Exclusive：独占模式。只允许一个线程访问共享资源，比如ReentrantLock。
-   Share：共享模式。允许多个线程同时访问共享资源，比如Semaphore、CountDownLatch、 CyclicBarrier等。

### 自定义同步器

AQS使用了模板模式，使用AQS能简单高效地构造出一个自定义同步器。不同的自定义同步器争用共享资源的方式也不同，可能是独占的，也可能是共享的。简单来说，实现自定义同步器只需要实现共享资源的状态变量`state`的获取和释放。至于线程等待队列的维护，`AQS`已经在顶层实现好了。

JDK中有多个并发工具类依赖于AQS，比如ReentrantLock、Semaphore，如下图所示（图片来自 Java并发编程 课件）：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201029213837.png?token=AE4F4YIQ4NCKTMGYU2OKHPS7TLDHO)

具体地，要实现自定义的同步器类，需要继承AQS并实现其中的一些方法：

-   boolean tryAcquire(int)：在独占模式下，尝试获取资源，如果成功则返回true，否则返回false。
-   boolean tryRelease(int)：在独占模式下，尝试释放资源，如果释放则返回true，否则返回false。
-   int tryAcquireShared(int)：在共享模式下，尝试获取资源。
    -   负数表示失败。
    -   0表示成功，但没有可用资源。
    -   正数表示成功，且有可用资源。
    -   如果失败或没有可用资源，该线程会进入队列等待，直到被前面的线程通知。
-   boolean tryReleaseShared(int)：在共享模式下，尝试释放资源，如果成功则返回true，否则返回false。
-   boolean isHeldExclusively()：判断该线程是否处于独占模式。只有用到condition条件变量才需要去实现它。

默认情况下，每个方法都抛出`UnsupportedOperationException`。这些方法的实现必须是线程安全的，并且通常应该简短而不是阻塞。

另外，AQS类中的其他方法都是`final`修饰的，不能被重写，只是提供给子类使用。

#### 例子

以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state加1。此后，其他线程再tryAcquire()时就会失败，直到A线程调用unlock方法设置state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。

一般来说，自定义同步器要么是独占方法，要么是共享方式，前者实现tryAcquire-tryRelease，后者实现tryAcquireShared-tryReleaseShared。不过，AQS也支持自定义同步器同时实现独占和共享两种方式，比如ReentrantReadWriteLock。

### 底层实现和原理

> [Java并发之AQS详解](https://www.cnblogs.com/waterystone/p/4920797.html "Java并发之AQS详解")

AQS的相关源码如下所示：

```java
public abstract class AbstractQueuedSynchronizer
    extends AbstractOwnableSynchronizer
    implements java.io.Serializable {

    protected AbstractQueuedSynchronizer() { }  // 子类可用
    private transient volatile Node head;
    private transient volatile Node tail;
    private volatile int state;  // 同步状态
    ...
}
```

head和tail分别指向CLH双向队列的头尾结点。当队列为空时，二者没有指向。当队列插入第一个节点时，会先创建一个虚拟头结点，再插入要插入的结点。换句话说，队列中的虚拟头结点是延迟初始化的。

#### Node

Node类是AQS的静态内部类，用来表示CLH队列中的结点。Node结点封装了等待获取资源的线程，包含了线程本身及其相关状态信息，比如是否被阻塞、是否等待唤醒、是否已经被取消等。

Node类的相关源码如下所示：

```java
static final class Node {
    static final Node SHARED = new Node(); // 共享模式
    static final Node EXCLUSIVE = null;    // 独占模式
    
    static final int CANCELLED =  1;
    static final int SIGNAL    = -1;
    static final int CONDITION = -2;
    static final int PROPAGATE = -3;

    volatile int waitStatus;
    volatile Node prev;
    volatile Node next;
    volatile Thread thread;
    Node nextWaiter;
}
```

waitStatus属性用来表示Node结点的等待状态，共有五种取值：

1.  0：新结点入队时的默认状态；
2.  CANCELLED (1)：表示结点已取消调度。当timeout或被中断（响应中断的情况下），会把结点修改为该状态，进入该状态后的结点将不会再变化。
3.  SIGNAL (-1)：表示结点有责任唤醒后继结点。当一个结点入队时，会将前驱结点修改为该状态。
4.  CONDITION (-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal方法后，处于该状态的结点从等待队列转移到同步队列中，等待获取同步锁。
5.  PROPAGATE (-3)：共享模式下，处于该状态的结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。

注意：负值表示结点处于有效等待状态，正值表示结点已被取消，所以源码中很多地方用`waitStatus>0`、`waitStatus<0`来判断结点的状态是否正常。

### 获取资源acquire

acquire方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，就直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。

acquire方法的流程如下图所示（图片来自 [Java并发之AQS详解](https://www.cnblogs.com/waterystone/p/4920797.html "Java并发之AQS详解")）：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201029214830.png?token=AE4F4YKSM6RN37YWLG2CSV27TLEMM)

acquire方法的源码如下所示：

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}

static void selfInterrupt() {
    Thread.currentThread().interrupt();
}
```

tryAcquire方法默认返回异常，用来被子类实现，作用是尝试获取资源（第一次调用tryAcquire方法）。

-   如果tryAcquire方法返回true，表示线程获取资源成功。
-   如果tryAcquire方法返回false，表示线程获取资源失败，就需要执行addWaiter方法和acquireQueued方法，把线程加入等待队列。
-   如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。

addWaiter方法用于把当前线程加入到等待队列的队尾，需要创建一个Node结点封装该线程，标记该结点为独占模式，并返回该结点。源码如下所示：

```java
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);  // 独占模式
    Node pred = tail;
    if (pred != null) { // 如果虚拟头结点存在，尝试快速加入队尾，在没有争抢的情况下会成功
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node); // 如果虚拟头结点还不存在，或者快速加入队尾失败，就使用enq方法入队
    return node;
}

private Node enq(final Node node) {
    for (;;) { // 自旋，直到成功
        Node t = tail;
        if (t == null) { // 创建虚拟头结点
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

通过tryAcquire方法和addWaiter方法，该线程获取资源失败，已经被放入等待队列尾部。通过使用addWaiter方法返回的结点作为参数，acquireQueued方法主要用来帮助该结点关联的线程继续尝试获取资源，如果实在获取不到则暂停该线程，使线程在等待队列中等待，此时线程处于WAITING状态，直到获得资源才返回。如果该线程在整个等待过程中被中断过，acquireQueued方法返回true，否则返回false。

acquireQueued方法的相关源码如下所示：

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) { // 自旋
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) { // 如果前驱结点是虚拟头结点，就可以再次尝试获取资源
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}
```

如果当前结点的前驱结点是虚拟头结点，当前结点中的线程就可以再次尝试获取资源（第二次调用tryAcquire方法）。

-   如果tryAcquire方法返回true，表示线程获取资源成功，就修改头结点，返回打断标记。如果打断标记为true，就会执行acquire方法中的selfInterrupt进行自我打断，否则不会执行selfInterrupt。
-   如果tryAcquire方法返回false，表示线程获取资源失败，就需要执行shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法。

shouldParkAfterFailedAcquire方法如其名，用来判断在获取资源失败后是否应该暂停当前结点关联的线程：

-   如果当前结点的前驱结点的waitStatus是SIGNAL，返回true，就会接着执行parkAndCheckInterrupt方法，暂停当前结点关联的线程。
-   如果当前结点的前驱结点的waitStatus>0，表示前驱结点关联的线程被取消，需要一直向前找到没有被取消的结点作为前驱结点，最终该方法返回false。
-   如果当前结点的前驱结点的waitStatus<=0，表示前驱结点关联的线程没有被取消，需要用CAS修改前驱结点的waitStatus为SIGNAL，表示前驱结点有责任唤醒当前结点，最终该方法返回false。

shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法的源码如下所示：

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL) // 如果前驱结点的状态为SIGNAL，返回true
        return true; 
    if (ws > 0) { // ws > 0表示前驱结点关联的线程被取消
        do { // 找到一个没有被取消的前驱结点
            node.prev = pred = pred.prev; 
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); // 修改前驱结点的状态为SIGNAL
    }
    return false; 
}

private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); // 暂停当前线程
    return Thread.interrupted(); // 返回是否被打断，并清除打断标记
}
```

通过之前的分析，可以看出，第一次调用shouldParkAfterFailedAcquire方法一定返回false，因为当前结点的前驱结点状态不是SIGNAL，或者已经被取消。

所以，acquireQueued方法可以继续自旋，判断该结点的前驱结点是否是虚拟头结点，如果是，可以再次尝试获取资源（第三次调用tryAcquire方法）。如果获取资源失败，就需要执行shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法。假设当前结点的前驱结点关联的线程没有被取消，第二次调用shouldParkAfterFailedAcquire方法就会返回true，然后执行parkAndCheckInterrupt方法暂停该线程，线程进入WAITING状态。

当线程在队列中等待（WAITING），有两种方式可以唤醒该线程：

1.  被unpark，有机会获取资源，返回打断标记为false，不会执行selfInterrupt方法；
2.  被interrupt，有机会获取资源，返回打断标记为true，会执行selfInterrupt方法进行自我打断。

在一个线程持有资源不释放的情况下，其他想要获取该资源的线程都需要调用三次tryAcquire方法，尝试获取资源，有点像synchronized自旋锁，减少线程进入队列的可能性，有利于高并发。

最后总结一下acquire方法的流程：

-   调用自定义同步器的tryAcquire方法尝试直接去获取资源，如果成功则直接返回；
-   如果尝试获取资源失败，就调用addWaiter方法将该线程加入等待队列队尾，并标记为独占模式；
-   acquireQueued方法使线程在队列中等待（WAITING），被唤醒后会尝试获取资源，获取到资源后才返回，返回的是打断标记。如果线程在等待过程中被打断过，该方法就返回true，否则返回false。
-   如果线程在等待过程中被打断过，它是不响应的，只是获取到资源后才进行自我中断selfInterrupt，将打断补上。

### 释放资源release

release方法是独占模式下线程释放共享资源的顶层入口。它会释放指定数量的资源，如果彻底释放了所有资源（state=0），就会唤醒等待队列中的第一个没被取消的结点关联的线程，返回true。如果没有释放资源，返回false。

acquire方法的源码如下所示：

```java
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

protected boolean tryRelease(int arg) {
    throw new UnsupportedOperationException();
}
```

其中tryRelease方法默认返回异常，用来被子类实现，作用是尝试释放资源。

-   如果tryRelease方法返回true，表示线程释放资源成功。正常来说，tryRelease方法都会成功，因为该方法是独占模式的方法。
-   如果tryRelease方法返回false，表示线程释放资源失败。

所以，自定义独占模式的同步器在实现tryRelease方法时，如果已经彻底释放资源（state=0），要返回true，否则返回false。

unparkSuccessor方法意思是唤醒后继，用来唤醒等待队列中离head结点最近的没有被取消的结点。

unparkSuccessor方法的源码如下所示：

```java
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null) // 如果s不为空
        LockSupport.unpark(s.thread);
}
```

使用unparkSuccessor方法唤醒离head结点最近的没有被取消的结点后，该结点关联的线程在acquireQueued方法中的parkAndCheckInterrupt处被唤醒，继续运行，可以执行`if(p == head && tryAcquire(arg))`：

-   如果该结点的前驱结点p=head，可以调用tryAcquire方法尝试获取资源；
-   如果该结点的前驱结点p!=head，表示该结点和结点head之间存在取消的结点，需要执行shouldParkAfterFailedAcquire方法，删除这些被取消的结点。经过删除调整，该结点就会成为head的后继结点，此时该结点的前驱结点p=head，就可以调用tryAcquire方法尝试获取资源。

release方法是独占模式下线程释放共享资源的顶层入口。它会释放指定数量的资源，如果彻底释放了所有资源（state=0），就会唤醒等待队列中的第一个没被取消的结点关联的线程，返回true。如果没有释放资源，返回false。

### 获取资源acquireShared

acquireShared方法是共享模式下获取共享资源的顶层入口。它会获取指定数量的资源，如果获取成功，就直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。

acquireShared方法的源码如下所示：

```java
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

其中tryAcquireShared方法默认返回异常，用来被子类实现，作用是尝试获取资源。该方法的返回值已经被AQS规定：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以acquireShared方法的流程就是：

-   先调用tryAcquireShared方法尝试获取资源，成功则直接返回；
-   如果失败，就调用doAcquireShared方法，进入等待队列，直到获取到资源为止才返回。

doAcquireShared方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。该方法的相关源码如下所示：

```java
private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r); // 唤醒后继结点
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

setHeadAndPropagate的相关源码如下所示：

```java
private void setHeadAndPropagate(Node node, int propagate) {
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}
```

简单总结一下，acquireShared方法先尝试获取资源，成功则直接返回；如果失败，就进入等待队列等待，直到被unpark或interrupt并成功获取到资源才返回，整个等待过程也是忽略中断的。

acquireShared方法的流程和acquire方法类似，最大的区别是一个结点被唤醒并获得资源后，还会唤醒该结点的后继结点。

### 释放资源releaseShared

releaseShared方法是共享模式下线程释放共享资源的顶层入口。它会释放指定数量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。

releaseShared方法的相关源码如下所示：

```java
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
```

其中tryReleaseShared方法默认返回异常，用来被子类实现，作用是尝试释放资源。如果tryReleaseShared方法返回true，就执行doReleaseShared方法，唤醒后继结点。

doReleaseShared方法的源码如下所示：

```java
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                    !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

### 应用

#### 用AQS实现一个不可重入锁

自定义独占模式的同步器，代码如下所示：

```java
public final class MySync extends AbstractQueuedSynchronizer {
    @Override
    protected boolean tryAcquire(int acquires) {
        if (acquires == 1) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
        }
        return false;
    }

    @Override
    protected boolean tryRelease(int acquires) {
        if (acquires == 1) {
            if (getState() == 0) {
                throw new IllegalMonitorStateException();
            }
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
        return false;
    }

    protected Condition newCondition() {
        return new ConditionObject();
    }

    @Override
    protected boolean isHeldExclusively() {
        return getState() == 1;
    }
}
```

自定义不可重入锁，代码如下所示：

```java
public class MyLock implements Lock {
    static MySync sync = new MySync();

    // 尝试，不成功，进入等待队列
    @Override
    public void lock() {
        sync.acquire(1);
    }

    // 尝试，不成功，进入等待队列，可打断
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }

    // 尝试一次，不成功返回，不进入队列
    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    // 尝试，不成功，进入等待队列，有时限
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }

    @Override
    public void unlock() {
        sync.release(1);
    }

    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
}
```

测试代码如下所示：

```java
public class TestMyLock {
    public static void main(String[] args) {
        MyLock lock = new MyLock();
        new Thread(() -> {
            lock.lock();
            try {
                System.out.println("t1 locking...");
            } finally {
                System.out.println("t1 unlocking...");
                lock.unlock();
            }
        },"t1").start();
        new Thread(() -> {
            lock.lock();
            try {
                System.out.println("t2 locking...");
            } finally {
                System.out.println("t2 unlocking...");
                lock.unlock();
            }
        },"t2").start();
    }
}
```

## ReentrantLock

> 参考 **Java并发编程** 课件。

ReentrantLock是JDK提供的可重入锁，实现了`Lock`接口。

相关源码如下所示：

```java
public interface Lock {
    void lock(); // 获取锁
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock(); 
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}

public class ReentrantLock implements Lock, java.io.Serializable {
    private final Sync sync; // 同步器
    abstract static class Sync extends AbstractQueuedSynchronizer {...} // 自定义的同步器，继承自AQS
    static final class NonfairSync extends Sync {...} // 非公平同步器，用于实现非公平锁
    static final class FairSync extends Sync {...} // 公平同步器，用于实现公平锁
    
    public ReentrantLock() {
        sync = new NonfairSync(); // 默认使用非公平锁
    }
    
    public ReentrantLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync(); 
    }
    
    public void lock() {
        sync.lock();
    }
    
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
    
    public boolean tryLock() {
        return sync.nonfairTryAcquire(1);
    }
    
    public void unlock() {
        sync.release(1);
    }
    
    public Condition newCondition() {
        return sync.newCondition();
    }
    ...
}
```

ReentrantLock与synchronized有一些相同的作用，但功能更强大。ReentrantLock支持公平锁和非公平锁，默认使用非公平锁。

> 公平锁：在多个线程争用锁的情况下，按照线程在队列中的排队顺序，先到者先拿到锁，这对于每一个线程都是公平的。
> 非公平锁：在队列中存在等待线程的情况，新来的线程可以直接去抢锁，抢到就执行，抢不到就进入队列排队，这对于排队的线程是不公平的。

### 加锁lock

对于非公平锁，==TODO==

### ReentrantLock和synchronized的相同和不同

相同：

-   两者都是可重入锁。可重入锁的意思是可以多次获取自己已经获取的锁。

不同：

-   `synchoronized`语法上比较简洁，方便使用；`ReentrantLock`语法稍微复杂，如果忘记释放锁容易导致死锁。
-   `synchronized`是JVM实现的，由JVM保证锁的获取和释放；`ReentrantLock`是JDK实现的，必须由使用者主动获取锁和释放锁。
-   `synchronized`是非公平锁，`RenentrantLock`既能使用非公平锁，也能使用公平锁。
-   `synchronized`，线程如果没有获取到锁，会一直尝试，直到成功；`ReentrantLock`提供了尝试获取锁的机制。
-   `synchronized`与`wait/notify`方法相结合可以实现等待和通知唤醒机制，但是被通知的线程是由JVM决定的，无法做到“选择性通知”，存在错误通知的情况。`ReentrantLock`可以把线程注册在指定的条件变量`Condition`中，可以有选择性的进行线程通知，在调度线程上更加灵活。

## ReentrantReadWriteLock

ReentrantReadWriteLock是JDK提供的可重入读写锁，实现了读写锁ReadWriteLock接口。

可重入读写锁提供了两把锁：读锁和写锁，用于实现读写分离。读锁用于读操作，写锁用于写操作。这种锁适用于读多些少的场景，性能要高于可重入锁ReentrantLock。

可重入读写锁的原则包括：

-   读读共享：多个线程可同时读共享变量，即可同时获得读锁；
-   读写互斥：写线程正在执行写操作，其他线程禁止读，即一个线程获得写锁，其他线程不能获取读锁；
-   写写互斥：只允许一个线程写共享变量，即一个线程获得写锁，其他线程不能获取写锁；

可重入读写锁的升级和降级包括：

-   不支持锁的升级。线程先获得读锁，再获取写锁，这样会导致死锁；
-   支持锁的降级。可以先获取写锁，再获取读锁，释放写锁，释放读锁；
-   只有写锁支持条件变量。如果读锁调用`newCondition()`方法，会抛出异常；

相关源码如下所示：

```java
public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}

public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {
    private final ReentrantReadWriteLock.ReadLock readerLock;
    private final ReentrantReadWriteLock.WriteLock writerLock;
    final Sync sync;
    // 默认非公平锁
    public ReentrantReadWriteLock() {
        this(false);
    }
    // 指定非公平锁还是公平锁
    public ReentrantReadWriteLock(boolean fair) {
        sync = fair ? new FairSync() : new NonfairSync();
        readerLock = new ReadLock(this);
        writerLock = new WriteLock(this);
    }
    // 获取读锁
    public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
    // 获取写锁
    public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
    // 抽象同步器
    abstract static class Sync extends AbstractQueuedSynchronizer {...}
    // 非公平同步器
    static final class NonfairSync extends Sync {...}
    // 公平同步器
    static final class FairSync extends Sync {...}
    // 读锁
    public static class ReadLock implements Lock, java.io.Serializable {
        private final Sync sync;

        protected ReadLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
        }
        ...
    }
    // 写锁
    public static class WriteLock implements Lock, java.io.Serializable {
        private final Sync sync;

        protected WriteLock(ReentrantReadWriteLock lock) {
            sync = lock.sync;
        }
    }
```

## Atomic原子类

简单来说，原子类就是具有原子操作特征的类，主要存放在`java.util.concurrent.atomic`下。

原子类主要使用CAS（Compare and Swap，比较并交换）来保证线程安全，开销比synchronized小。简单来说，CAS从某一内存上取值V，和预期值A进行比较，如果二者相等，那么就把新值B更新到内存；如果不相等，那么就重复上述操作直到成功为止。CAS基于硬件实现，可以直接访问内存中的值。

基本类型原子类：

-   AtomicInteger：整形原子类。
-   AtomicLong：长整型原子类。
-   AtomicBoolean：布尔型原子类。
-   AtomicReference：引用型数据原子类。

数组类型原子类：

-   AtomicIntegerArray：整形数组原子类。
-   AtomicLongArray：长整形数组原子类。
-   AtomicReferenceArray：引用类型数组原子类。

对象的属性修改类型：

-   AtomicIntegerFieldUpdater：原子更新整形字段的更新器。
-   AtomicLongFieldUpdater：原子更新长整形字段的更新器。
-   AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可以解决使用CAS进行原子更新时出现的 ABA 问题。

基于AtomicInteger介绍一下原子类的原理，相关源码如下所示：

```java
public class AtomicInteger extends Number implements java.io.Serializable {
    // setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
    
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
    ...
}
```

AtomicInteger类主要利用CAS、volatile和native方法来保证原子操作，从而避免synchronized的高开销。CAS的原理是拿期望的值和原来的值作比较，如果相同则更新成新的值。另外value是一个volatile变量，保证了多线程间的可见性，因此JVM可以保证任何时刻任何线程总能拿到该变量的最新值。

### CAS存在哪些问题？

ABA问题。CAS无法感知变量从A变为B再变为A，只要变量为A就会进行更新，但是此时变量已经变化了两次。这种问题可以用AtomicStampedReference来解决。

自旋问题。如果一个线程要修改变量值，但是该变量一直被别的线程修改，那么该线程就会一直自旋，浪费CPU。

CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。这种问题可以用AtomicReference来解决。

### 乐观锁和悲观锁

> [Java 多线程之悲观锁与乐观锁](https://www.cnblogs.com/renhui/p/9755789.html "Java 多线程之悲观锁与乐观锁")

悲观锁的意思是线程在访问共享数据前必须先加互斥锁，使其他线程阻塞。悲观锁总是假设最坏的情况，认为有别的线程会修改共享数据，所以必须先上锁。synchronized和ReentrantLock属于悲观锁的实现。

乐观锁的意思是线程访问共享数据前不用加锁。乐观锁总是假设最好的情况，认为没有别的线程会修改共享数据，所以不会上锁。乐观锁通常使用CAS或版本号机制保证线程安全。Atomic原子类属于乐观锁的实现。

synchronized适用于写比较多的情况下（多写场景，冲突一般较多），而CAS适用于写比较少的情况下（多读场景，冲突一般较少），原因是：

1）对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁比较消耗资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

2）对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的资源，效率低于synchronized。

## Semaphore

Semaphore（信号量）允许多个线程同时访问。synchronized和ReentrantLock都是一次只允许一个线程访问某个资源，Semaphore可以允许多个线程同时访问某个资源。

## CountDownLatch

CountDownLatch（倒计时器）是一个同步工具类，用来协调多个线程之间的同步。它通常用来控制线程等待，可以让某一个线程等待，直到倒计时结束才开始执行。

## CyclicBarrier

CyclicBarrier（循环栅栏）意思是可循环使用的屏障，也可以实现线程间的等待，主要应用场景和CountDownLatch类似，但是它的功能比CountDownLatch更加复杂和强大。`CyclicBarrier`让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。

## 并发集合类

### CopyOnWriteArrayList

> [聊聊并发-Java中的Copy-On-Write容器](http://ifeve.com/java-copy-on-write/ "聊聊并发-Java中的Copy-On-Write容器")
> [CopyOnWriteArrayList详解](https://www.cnblogs.com/myseries/p/10877420.html "CopyOnWriteArrayList详解")

CopyOnWriteArrayList是一个线程安全的ArrayList，和ArrayList不在同一个包下，前者的完全路径为`java.util.concurrent.CopyOnWriteArrayList`，后者的完全路径为`java.util.ArrayList`。

CopyOnWrite是一种用于程序设计中的优化策略，其基本思路是，从一开始所有线程都共享同一个内容，当某个线程想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索，这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。

看一下CopyOnWriteArrayList的源码：

1）添加元素，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。

```java
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

2）读操作不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。

```java
public E get(int index) {
    return get(getArray(), index);
}
```

### ConcurrentHashMap

> [嘿嘿，我就知道面试官接下来要问我 ConcurrentHashMap 底层原理了，看我怎么秀他](https://www.cnblogs.com/starry-skys/p/12742500.html "嘿嘿，我就知道面试官接下来要问我 ConcurrentHashMap 底层原理了，看我怎么秀他")
> [ConcurrentHashMap1.7和1.8的底层不同实现](https://my.oschina.net/zupengliu/blog/1930025 "ConcurrentHashMap1.7和1.8的底层不同实现")

ConcurrentHashMap是一个线程安全的HashMap，和HashMap不在同一个包下，前者的完全路径为`java.util.concurrent.ConcurrentHashMap`，后者的完全路径为`java.util.HashMap`。

ConcurrentHa`shMap在J`DK1.7和1.8中的实现有区别，主要在于：

1.  在JDK1.7中，底层是Segment数组和HashEntry数组；在JDK1.8中，底层是数组+链表+红黑树，提升了读写性能。
2.  在JDK1.7中，锁的粒度是基于Segment的；在JDK1.8中，取消了Segment，锁的粒度是基于链表首结点的，粒度更小，减少了并发冲突。
3.  在JDK1.7中，锁是可重入锁ReentrantLock；在JDK1.8中，锁是synchronized，使用上更加简单。

#### JDK1.7

在JDK1.7中，ConcurrentHashMap底层是Segment数组和HashEntry数组，其中Segment继承自可重入锁ReentrantLock，用来担任锁的角色，一般称为分段锁。一个ConcurrentHashMap包含一个Segment数组，一个Segment包含一个HashEntry数组，其中Segment相当于一个小的HashMap，HashEntry数组相当于HashMap中的table。HashEntry相当于HashMap中的链表结点Node，用来表示一个键值对及其相关信息。

ConcurrentHashMap中的key可以为空，value不能为空。

相关源码如下所示：

```java
public class ConcurrentHashMap<K, V> extends AbstractMap<K, V>
        implements ConcurrentMap<K, V>, Serializable {
        
    final Segment<K,V>[] segments; // segment数组
        
    static final class Segment<K,V> extends ReentrantLock implements Serializable {
        transient volatile HashEntry<K, V>[] table;
        
        Segment(float lf, int threshold, HashEntry<K, V>[] tab) {
            this.loadFactor = lf;
            this.threshold = threshold;
            this.table = tab;
        }
    }
    
    static final class HashEntry<K,V> {
        final int hash; // hash值
        final K key; // 键
        volatile V value; // 值
        volatile HashEntry<K, V> next; // 下一个键值对
    }
}
```

put方法：首先定位Segment，当这个Segment在map初始化后，还为null，由ensureSegment方法负责填充这个segment。对Segment加锁，定位所在的table元素，并扫描table下的链表。

size方法：size的时候进行两次不加锁的统计，两次一致直接返回结果，不一致，重新加锁再次统计。

#### JDK1.8

在JDK1.8中，ConcurrentHashMap底层是数组和链表，与HashMap类似，没有使用Segment数组。虽然还能看到Segment类，但是并没有使用，只是为了兼容旧版本。并发控制使用了synchronized和CAS，看起来像是优化的线程安全的HashMap。

ConcurrentHashMap中的key和value都不能为空，否则会抛出空指针异常。

相关源码如下所示：

```java
public class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>, Serializable {
    transient volatile Node<K,V>[] table; // table数组，与HashMap类似
    
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        volatile V val;
        volatile Node<K,V> next; // 下一个结点
    }
}
```

put方法：

1.  如果没有初始化就先调用initTabl()方法来进行初始化过程
2.  如果没有hash冲突就直接CAS插入
3.  如果还在进行扩容操作就先进行扩容
4.  如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入，
5.  如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环
6.  如果添加成功就调用addCount()方法统计size，并且检查是否需要扩容

size方法：在JDK1.8版本中，对于size的计算，在扩容和addCount()方法就已经有处理了，JDK1.7是在调用size()方法才去计算，其实在并发集合中去计算size是没有多大的意义的，因为size是实时在变的，只能计算某一刻的大小，但是某一刻太快了，人的感知是一个时间段，所以并不是很精确。

### BlockingQueue

> [Java并发编程--BlockingQueue](https://www.cnblogs.com/zaizhoumo/p/7786793.html "Java并发编程--BlockingQueue")

BlockingQueue支持两个附加操作的Queue：

1.  当Queue为空时，获取元素线程被阻塞直到Queue变为非空；
2.  当Queue满时，添加元素线程被阻塞直到Queue不满。

BlockingQueue不允许元素为null，如果入队一个null元素，会抛NullPointerException。常用于生产者消费者模式。

BlockingQueue对于不能满足条件的操作，提供了四种处理方式：

1.  直接抛异常，抛出异常。如果队列已满，添加元素会抛出IllegalStateException异常；如果队列为空，获取元素会抛出NoSuchElementException异常；
2.  返回一个特殊值（null或false）；
3.  在满足条件之前，无限期的阻塞当前线程，当队列满足条件或响应中断退出；
4.  在有限时间内阻塞当前线程，超时后返回失败。

总结：

|    | 抛出异常      | 返回特殊值    | 阻塞     | 超时                   |
| -- | --------- | -------- | ------ | -------------------- |
| 入队 | add(e)    | offer(e) | put(e) | offer(e, time, unit) |
| 出队 | remove()  | poll()   | take() | poll(time, unit)     |
| 检查 | element() | peek()   |        |                      |

Java提供了多种阻塞队列：

-   ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列，遵循FIFO原则。
-   LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列，遵循FIFO原则，默认和最大长度为Integer.MAX\_VALUE。
-   PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
-   DelayQueue：一个使用优先级队列实现的无界阻塞队列。
-   SynchronousQueue：一个不存储元素的阻塞队列。
-   LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
-   LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

#### ArrayBlockingQueue

\==TODO==

#### LinkedBlockingQueue

\==TODO==

# 并发应用

## 固定线程运行顺序

控制两个线程的执行顺序，先执行线程t2，再执行线程t1。

### wait/notify/synchronized

```java
public class Test {
    // 用来同步的对象
    static Object object = new Object();
    // t2 运行标记， 代表 t2 是否执行过
    static boolean runed = false;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (object) {
                // 如果 t2 没有执行过
                while (!runed) {
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
            System.out.println(1);
        });
        
        Thread t2 = new Thread(() -> {
            System.out.println(2);
            synchronized (object) {
                // 修改运行标记
                runed = true;
                // 通知 object 上等待的线程（可能有多个，因此需要用 notifyAll）
                object.notifyAll();
            }
        });

        t1.start();
        t2.start();
    }
}
```

### park/unpark

使用wait/notify/synchronized版本比较麻烦：

-   wait/notify 需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒，因此需要使用**运行标记**来判断该不该wait。
-   wait/notify 存在错误唤醒问题，如果其他线程错误地 notify 了 wait 线程，while循环条件不满足时线程还要重新等待。
-   唤醒对象上的 wait 线程需要使用 notifyAll，因为**同步对象**上的等待线程可能不止一个。

使用LockSupport实现，代码如下：

```java
public static void main(String[] args) {
    Thread t1 = new Thread(() -> {
        // 当没有许可时，当前线程暂停运行；有许可时，用掉这个许可，当前线程恢复运行
        LockSupport.park();
        System.out.println("1");
    });
    Thread t2 = new Thread(() -> {
        System.out.println("2");
        // 给线程 t1 发放许可（多次连续调用unpark只会发放一个许可）
        LockSupport.unpark(t1);
    });
    t1.start();
    t2.start();
}
```

使用LockSupport比较简单，park/unpark方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行暂停和恢复，不需要同步对象和运行标记；

## 交替输出

给定线程 1 输出 a，线程 2 输出 b，线程 3 输出 c，要求三个线程轮流输出5次abc。

### wait/notify/synchronized

```java
public class WaitNotifyPrint {
    private int flag;
    private final int loopNumber;

    public WaitNotifyPrint(int flag, int loopNumber) {
        this.flag = flag;
        this.loopNumber = loopNumber;
    }

    public void printInTurn(int curFlag, int nextFlag, String str) {
        for (int i = 0; i < loopNumber; i++) {
            synchronized (this) {
                while (this.flag != curFlag) {
                    try {
                        this.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName() + ":" + str);
                flag = nextFlag;
                this.notifyAll();
            }
        }
    }

    public static void main(String[] args) {
        WaitNotifyPrint waitNotifyPrint = new WaitNotifyPrint(1, 5);
        new Thread(() -> {
            waitNotifyPrint.printInTurn(1, 2, "a");
        }).start();
        new Thread(() -> {
            waitNotifyPrint.printInTurn(2, 3, "b");
        }).start();
        new Thread(() -> {
            waitNotifyPrint.printInTurn(3, 1, "c");
        }).start();
    }
}
```

### park/unpark

```java
public class LockSupportPrint {
    private int loopNumber;
    private Thread[] threads;
    private int curThreadIdx;

    public LockSupportPrint(int loopNumber) {
        this.loopNumber = loopNumber;
        this.curThreadIdx = 0;
    }

    public void setThreads(Thread... threads) {
        this.threads = threads;
    }

    public void printInTurn(String str) {
        for (int i = 0; i < loopNumber; i++) {
            LockSupport.park();
            System.out.println(Thread.currentThread().getName() + ":" + str);
            LockSupport.unpark(nextThread());
        }
    }

    private Thread nextThread() {
        if (curThreadIdx < threads.length - 1) {
            curThreadIdx += 1;
            return threads[curThreadIdx];
        }
        curThreadIdx = 0;
        return threads[curThreadIdx];
    }

    public void start() {
        for (Thread thread : threads) {
            thread.start();
        }
        LockSupport.unpark(threads[curThreadIdx]);
    }

    public static void main(String[] args) {
        LockSupportPrint lockSupportPrint = new LockSupportPrint(5);
        Thread t1 = new Thread(() -> {
            lockSupportPrint.printInTurn("a");
        });
        Thread t2 = new Thread(() -> {
            lockSupportPrint.printInTurn("b");
        });
        Thread t3 = new Thread(() -> {
            lockSupportPrint.printInTurn("c");
        });
        lockSupportPrint.setThreads(t1, t2, t3);
        lockSupportPrint.start();
    }
}
```

### ReentrantLock

```java
public class LockPrint extends ReentrantLock {
    private int loopNumber;

    public LockPrint(int loopNumber) {
        this.loopNumber = loopNumber;
    }

    public void printInTurn(Condition current, Condition next, String str) {
        for (int i = 0; i < loopNumber; i++) {
            this.lock();
            try {
                current.await();
                System.out.println(Thread.currentThread().getName() + ":" + str);
                next.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                this.unlock();
            }
        }
    }

    public void start(Condition first) {
        this.lock();
        try {
            System.out.println("start");
            first.signal();
        } finally {
            this.unlock();
        }
    }

    public static void main(String[] args) {
        LockPrint lockPrint = new LockPrint(5);
        Condition aWaitSet = lockPrint.newCondition();
        Condition bWaitSet = lockPrint.newCondition();
        Condition cWaitSet = lockPrint.newCondition();
        new Thread(() -> {
            lockPrint.printInTurn(aWaitSet, bWaitSet, "a");
        }).start();
        new Thread(() -> {
            lockPrint.printInTurn(bWaitSet, cWaitSet, "b");
        }).start();
        new Thread(() -> {
            lockPrint.printInTurn(cWaitSet, aWaitSet, "c");
        }).start();
        lockPrint.start(aWaitSet);
    }
}
```

## 生产者消费者

```java
// 消息
class Message {
    private int id;

    public Message(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Message{id=" + id + '}';
    }
}
// 消息队列
class MessageQueue {
    private LinkedList<Message> queue;
    private int capacity;

    public MessageQueue(int capacity) {
        this.capacity = capacity;
        queue = new LinkedList<>();
    }

    public Message take() {
        synchronized (queue) {
            while (queue.isEmpty()) {
                System.out.println("没消息了, " + Thread.currentThread().getName() + " wait");
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Message message = queue.removeFirst();
            queue.notifyAll();
            return message;
        }
    }

    public void put(Message message) {
        synchronized (queue) {
            while (queue.size() == capacity) {
                System.out.println("消息满了, " + Thread.currentThread().getName() + " wait");
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            queue.addLast(message);
            queue.notifyAll();
        }
    }
}
// 生产者
class Producer implements Runnable {
    public MessageQueue queue;

    public Producer(MessageQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true) {
            Message message = new Message(new Random().nextInt(100));
            queue.put(message);
            System.out.println(Thread.currentThread().getName() + " 生产了 " + message);
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
// 消费者
class Consumer implements Runnable {
    public MessageQueue queue;

    public Consumer(MessageQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true) {
            Message message = queue.take();
            System.out.println(Thread.currentThread().getName() + " 消费了 " + message);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
// 测试
public class Test {
    public static void main(String[] args) throws InterruptedException {
        MessageQueue messageQueue = new MessageQueue(2);
        Producer p1 = new Producer(messageQueue);
        Consumer c1 = new Consumer(messageQueue);
        Consumer c2 = new Consumer(messageQueue);
        new Thread(p1, "生产者-" + 1).start();
        Thread.sleep(1000); // 保证先生产
        new Thread(c1, "消费者-" + 1).start();
        new Thread(c2, "消费者-" + 2).start();
    }
}
```

# JVM

> [大白话带你认识JVM](https://juejin.im/post/5e1505d0f265da5d5d744050#heading-28 "大白话带你认识JVM")
> [解密JVM](https://www.bilibili.com/video/BV1yE411Z7AP "解密JVM")

JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。

JVM屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

## Java内存区域/结构

> [Java内存区域 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md "Java内存区域 - JavaGuide")

Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。

Java内存区域如下图所示（图片来自JavaGuide）：

1）JDK1.6：

![image_SixTxotELf](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261013391.png)

2）JDK1.8：

![image_WbruWLA2pV](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261013361.png)

线程私有的区域：

-   程序计数器：用来指示下一条需要执行的指令，记录当前线程执行的位置。
-   虚拟机栈：用来保存线程栈帧，每个栈帧包含局部变量表、操作数栈等。
-   本地方法栈：用来存放该本地方法的局部变量表、操作数栈等。

线程共享的区域：

-   堆：所有线程共享，在虚拟机启动时创建，用于存放对象实例。
-   方法区：用于存储已经加载的类信息、运行时常量池、静态变量、编译后的字节码等数据。
-   直接内存：不在运行时数据区。

定义一个整数变量`int a=1`，变量`a`应该存储在哪个区域：

-   如果变量是局部变量，存储在栈中的局部变量表。
-   如果变量是成员变量，包含在所属的对象中，存储在堆中。
-   如果变量是静态变量，包含在所属的类中，存储在方法区中。

## Java内存模型

Java内存模型定义了一套多线程读写共享数据时，对数据的可见性、有序性和原子性的保障规则，所以也可以称为Java线程内存模型。

Java线程内存模型将虚拟机内存划分为两部分内存：主内存和线程工作内存，其中主内存是多个线程共享的内存，线程工作内存是每个线程独享的内存。

![image_U397JZqEVH](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261014508.png)

在上图中，方法区和堆内存就是主内存区域，而虚拟机栈、本地方法栈以及程序计数器则属于每个线程独享的工作内存。

在 JDK1.2 之前，Java内存模型实现总是从主存读取变量，是不需要特别注意的。

然而，在目前的Java内存模型下（如下图所示），所有成员变量都需要存储在主内存中，线程会在其工作内存中保存需要使用的成员变量的拷贝，而且线程对成员变量的操作（读取和赋值等）都是对其工作内存中的拷贝进行操作，然后再更新到主内存。 另外，各个线程之间不能互相访问工作内存，线程间变量的传递需要通过主内存来完成。

![image_K8tX9KGaJn](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261014405.png)

这就可能导致一个问题，比如一个线程修改了一个共享变量的值，而另外一个线程还继续使用工作内存中的这个变量的拷贝，造成了数据的不一致。

Java内存模型定义了8种原子操作来实现上图中的线程内存交互：

-   **read**：将主内存中的一个变量的值读取出来。
-   **load**：将read操作读取的变量值存储到工作内存的副本中。
-   **use**：把工作内存中的变量的值传递给执行引擎。
-   **assign**：把从执行引擎中接收的值赋值给工作内存中的变量。
-   **store**：把工作内存中一个变量的值传递到主内存。
-   **write**：将**store**操作传递的值写入到主内存的变量中。
-   **lock**：将主内存中的一个变量标识为某个线程独占的锁定状态。
-   **unlock**：将主内存中线程独占的一个变量从锁定状态中释放。

## 类的生命周期

> [类的生命周期 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md "类的生命周期 - JavaGuide")
> [深入理解Java类加载](https://www.cnblogs.com/czwbig/p/11127222.html "深入理解Java类加载")

一个类的生命周期包括类加载、使用和卸载。类文件需要加载到虚拟机中才能使用，类加载包括加载、连接和初始化，其中连接过程包括验证、解析和初始化。

类的生命周期如下图所示：

![image_CYXW-wop2W](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261029173.png)

### 类加载

#### 加载

加载是类加载的第一步，主要完成 2 件事情：

1.  通过全限定类名来获取定义此类的二进制字节流，把字节流代表的静态存储结构转化为方法区的运行时数据结构。
2.  在内存中生成一个代表该类的`java.lang.Class`对象，作为方法区该类数据的访问入口。

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段还没结束，连接阶段可能就已经开始了。

#### 连接

连接是类加载的第二步。连接阶段可以分为三步：验证、准备和解析。

连接阶段的第一步是验证。这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。该阶段包括：

-   文件格式验证：二进制文件是以魔数0xCAFEBABE开头，主次版本号是否在当前虚拟机处理范围之内等；
-   元数据验证：是否存在父类，父类的继承链是否正确；
-   字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的；
-   符号引用验证：保证可以将符号引用转化为直接引用；

连接阶段的第二步是准备。虚拟机为类变量分配内存并设置初始值，这些变量所使用的内存都将在方法区中进行分配。需要注意的是：

-   为类变量分配内存，不包括实例变量；
-   为类变量设置初始值（也称为零值），而不是我们指定的值。比如`public static int value=111`，该变量在准备阶段被设置为`0`，而不是`111`；
-   不同类型的初始值不同，比如`int`类型的初始值为`0`，`long`类型的初始值为`0L`，`double`类型的初始值为`0.0d`；
-   特殊情况：`public static final int value=111`，该变量用`final`修饰，在准备阶段就可以确定为`111`，不需要先设置为0；

连接阶段的第三步是解析，虚拟机将常量池内的符号引用替换为直接引用。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。符号引用仅仅是标识，而直接引用是对应的实际地址。

#### 初始化

初始化是类加载的最后一步。在初始化阶段，通过生成并执行类构造器`<cinit>()`方法，开始真正执行类中定义的语句。

类构造器`<cinit>()`方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值语句和静态代码块合并产生的。（不包括构造方法中的语句，构造方法是用来初始化对象的）

`<cinit>()`不需要调用父类的初始化方法`<cinit>()`（只有接口在使用到父接口中的静态变量时需要调用），虚拟机会保证在子类的`<cinit>()`方法执行之前，父类的`<cinit>()`方法已经执行完毕，也就意味着父类中定义的静态代码块要优先于子类的变量赋值操作。

`<cinit>()`方法对于类或接口来说并不是必需的，如果一个类中没有静态代码块，也没有对静态变量的赋值操作，那么编译器可以不为这个类生成`<cinit>()`方法。

虚拟机会保证一个类的`<cinit>()`方法在多线程环境中被正确地加锁。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的`<cinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行`<cinit>()`方法完毕。

#### 类初始化的时机

对于初始化阶段，虚拟机规范规定了有几种情况必须立即对类进行“初始化”（而加载、连接自然需要在此之前开始）：

-   遇到`new`、`getstatic`和`putstatic`或`invokestatic`这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。对应的场景分别是使用`new`实例化对象、读取或设置类的静态变量、以及调用类的静态方法。
-   对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
-   初始化一个类，如果其父类还未初始化，则需要先触发其父类的初始化。
-   运行一个包含`main()`方法的类，虚拟机启动，会先初始化这个类。

### 使用

使用没什么可说的。

### 卸载

卸载类即该类的Class对象被GC。卸载类需要满足3个要求:

1.  该类的所有对象都已经被GC，也就是说堆中不存在该类的对象。
2.  该类没有在其他任何地方被引用。
3.  该类的类加载器的实例已被GC。

JDK自带的BootstrapClassLoader，PlatformClassLoader，AppClassLoader负责加载JDK中的类，这三种类加载器的实例肯定不会被回收，所以这三种类加载器加载的类是不会被卸载的。但是，自定义的类加载器可以被回收，所以使用自定义的类加载器加载的类是可能被卸载的。

### 类加载器

类加载器（ClassLoader）用于加载`class`文件并创建一个`java.lang.Class`对象。

JVM自带三个重要的类加载器：

-   启动类加载器（BootstrapClassLoader）：最顶层的加载类，由C++实现，负责加载`%JAVA_HOME%/lib`目录下的`jar`包和类，以及`-Xbootclasspath`参数指定的路径中的类。
-   扩展类加载器（ExtensionClassLoader）：主要负责加载`%JRE_HOME%/lib/ext`目录下的jar包和类，以及`java.ext.dirs`系统变量指定的路径下的`jar`包。
-   应用程序类加载器（AppClassLoader）：面向用户程序的加载器，负责加载当前应用程序`classpath`下的`jar`包和类。

#### 类的唯一性

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。

即使两个类来源于同一个`class`文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类也不相等。

#### 双亲委派模式

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中。只有当父加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。

双亲委派的工作流程如下图所示：

![image_cV2OzRc-GH](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261030822.png)

类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。

Bootstrap类加载器是用C++实现的，是虚拟机自身的一部分，如果获取它的对象，将会返回`null`。扩展类加载器和应用类加载器是Java语言实现的，均继承自抽象类`java.lang.ClassLoader`，开发者可直接使用这两个类加载器。

Application类加载器对象可以由`ClassLoader.getSystemClassLoader()`方法返回，所以也称为系统类加载器。它负责加载用户类路径上所指定的类，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载，保证Java的核心API不被篡改。对于`java.lang.Object`类，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此`Object`类在各种类加载器环境中都是同一个类。

#### 自定义类加载器

为了避免双亲委托机制，可以自定义一个类加载器，需要继承`java.lang.ClassLoader`，并重写`findClass()`方法。

### 问题

#### Class.forName()和classLoader.loadClass()区别

> [学了这么久的java反射机制，你知道class.forName和classloader的区别吗?](https://zhuanlan.zhihu.com/p/101114197 "学了这么久的java反射机制，你知道class.forName和classloader的区别吗?")

`Class.forName(String)`方法会加载类并进行初始化，会执行静态代码块。另外还有一个重载方法：`Class.forName(String, boolean, ClassLoader)`，第二个参数表示是否初始化，如果为false，则不会初始化。

`ClassLoader`中的`loadclass(String)`方法只加载类，不会进行初始化，也就是不会执行静态代码块。

## 对象创建过程

Java创建对象的过程如下图所示（图片来自JavaGuide）：

![image_CCXVwsxZIw](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261030490.png)

### 类加载检查

当虚拟机遇到一条new指令时，先去检查这个指令的参数是否能在常量池中找到到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

### 分配内存

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从堆中划分出来。

### 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。这一步操作保证了对象的实例字段可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 设置对象头

初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、分代年龄等信息。 这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

### 执行\<init>方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始：`<init>`方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行`<init>`方法，把对象按照程序员的意愿进行初始化，即调用构造方法，完成成员变量的初始化。

# 垃圾回收

> [JVM 垃圾回收 - JavaGuide](https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md "JVM 垃圾回收 - JavaGuide")
> [Java垃圾回收](https://www.cnblogs.com/czwbig/p/11127159.html "Java垃圾回收")

## 如何判断对象需要被回收

判断对象需要被回收有以下两种方法：

1.  **引用计数法**。给对象添加一个引用计数器，被引用一次计数器就加 1，引用失效时减1。计数器为0时，对象不能再被使用，可以进行回收。该方法简单高效，缺点是无法解决对象之间存在循环引用的问题。
2.  **可达性分析算法**。以GC Roots对象为起始点，从这些节点往下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，表示此对象是不可用的。此算法解决了循环引用的问题，但是搜索需要耗费大量资源和时间，会暂停所有线程。Java**垃圾回收器采用这种方法**。

能作为GC Roots的对象：

-   虚拟机栈中的变量所引用的对象。
-   本地方法栈中的变量所引用的对象。
-   方法区中静态变量、常量引用的对象，比如自带类加载器加载的类对象。

垃圾回收管理堆区，不管理虚拟机栈、本地方法栈和方法区，可以选用这些区域中的变量所引用的对象作为GC Roots，因为这些对象不会被GC回收。

-   虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象是存活的。
-   方法区中静态变量或常量引用的对象显然是存活的。

Java中的四种引用：

-   强引用：最常用的引用，有强引用的对象不会被回收。
-   软引用：仅有软引用引用该对象，如果垃圾回收后内存仍然不足，则回收软引用对象。
-   弱引用：仅有弱引用引用该对象，在垃圾回收时，无论内存是否充足，都会回收弱引用对象。
-   虚引用：如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收，虚引用必须配合引用队列使用。

## 垃圾回收算法

三种常用的垃圾回收算法：

1）标记清除算法：

-   垃圾回收包括两个阶段：标记阶段，使用可达性分析算法标记可达对象（存活对象）；清除阶段，扫描堆内存的所有对象，如果不是可达对象，就进行回收；
-   优点：简单；
-   缺点：标记和清除的效率比较低下，会有内存碎片。

2）复制算法：

-   把内存划分为两个空间，活动空间和空闲空间。先标记活动空间中的可达对象，把可达对象复制到空闲空间中，然后把所有指向对象旧地址的指针调整到对象的新地址上，把活动空间中剩余的垃圾对象清除，最后把两个空间交换；
-   优点：不会有内存碎片；
-   缺点：只能利用一半的内存空间；在对象存活率高的时候会有一定的效率问题。

3）标记整理算法：

-   类似于标记清除算法，包括两个阶段：标记阶段，和标记清除算法相同；清理阶段，让所有可达对象都向一端移动，然后直接清理掉边界以外的内存；
-   优点：没有内存碎片；
-   缺点：速度慢，需要移动对象。

Java通常采用分代垃圾回收算法。这种算法没有什么新的思想，只是根据对象存活周期的不同把内存划分为不同的区域，根据各个区域的特点采用适当的收集算法。通常情况下，堆可以分为新生代（也称为年轻代）和老年代两个区域：

-   新生代一般占据堆空间的1/5。新生代又可以细分为Eden区，From存活区，To存活区，三个区的默认比例为`8:1:1`。在新生代中，对象存活时间短，每次收集都会有大量对象死去，所以通常选择复制算法，只需要付出少量对象的复制成本就可以完成垃圾回收。
-   老年代中，对象存活几率比较高，而且空间比较珍贵，所以通常选择标记清除或标记整理算法进行垃圾回收。

分代垃圾回收的过程大致包括：

-   大部分情况，对象都会首先在Eden区分配内存。
-   如果新生代空间不足，会触发一次Minor GC，Eden区和From存活区中存活的对象复制到To存活区，存活的对象年龄加1，并交换From存活区和To存活区（复制算法）。
-   Minor GC会引发STW(stop the world)，暂停用户线程，等垃圾回收结束，用户线程恢复运行。
-   一般当对象年龄达到15时，会从From存活区晋升到老年代，而不是留在存活区。
-   当老年代空间不足时，会先尝试触发Minor GC，如果之后空间仍不足，那么触发Full GC，STW的时间更长。

堆内存和垃圾回收的相关参数：

-   `-Xms`：设置堆内存的初始大小（最小堆内存）。比如`-Xms16m`，设置堆初始大小为`16MB`。
-   `-Xmx`或`-XX:MaxHeapSize=size`：设置堆内存可被分配的最大空间（最大堆内存）。比如`-Xmx16m`，设置堆内存最大大小为`16MB`。
-   `-XX:NewSize=size`：设置新生代的初始大小（最小新生代），应该小于`-Xms`的值。比如`-XX:NewSize=16m`，设置新生代内存的初始大小为`16MB`。
-   `-XX:MaxNewSize=size`：设置新生代可被分配的最大空间（最大新生代），应该小于`-Xmx`的值。比如`-XX:MaxNewSize=16m`。
-   `-Xmn`：设置新生代大小，相当于同时设置`-XX:NewSize=size`和`-XX:MaxNewSize=size`，并且二者相等，比如`-Xmn16m`。
-   `-XX:NewRatio=ratio`：设置新生代的比例，通常为4，表示新生代和老年代的比例为`1:4`，即新生代占堆内存的1/5。
-   `-XX:SurvivorRatio=ratio`：设置幸存区占新生代内存的比例，该值通常为8，表示两个幸存区和Eden区的比例为`2:8`，此时Eden区占4/5，From和To幸存区分别占1/10。
-   `-XX:InitialSurvivorRatio=ratio`：设置幸存区的初始比例，该值通常为8，表示两个幸存区和Eden区的比例为`2:8`，此时Eden区占4/5，From和To幸存区分别占1/10。
-   `-XX:MaxTenuringThreshold=threshold`：设置晋升阈值，最大为15。
-   `-XX:+PrintGCDetails`和`-verbose:gc`：打印GC详情。
-   `-XX:+PrintTenuringDistribution`：打印晋升详情。
-   `-XX:+ScavengeBeforeFullGC`：设置在Full GC之前进行Minor GC，默认为true。

## 垃圾收集器

> [Java的垃圾回收器](https://blog.csdn.net/weixin_38569499/article/details/85645867 "Java的垃圾回收器")

如果说垃圾回收算法是堆内存回收的方法论，那么垃圾收集器就是堆内存回收方法的具体实现。

到目前为止，还没有最好的垃圾收集器出现，也没有万能的垃圾收集器，需要根据不同的应用场景选择适合的垃圾收集器。

通过执行`java -XX:+PrintFlagsFinal -version`，可以查看垃圾收集器的相关参数。

### 垃圾收集策略

垃圾收集主要有三种不同策略：串行、吞吐量优先和响应时间优先。

#### 串行

串行策略是指使用单线程串行进行垃圾回收。

-   简单，内存开销小，适用于堆内存较小的个人电脑；
-   比如Serial收集器，Serial Old收集器。

串行回收垃圾的过程如下图所示（来自 解密JVM 课件）：

![image_KXnpYop4Ru](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261030038.png)

#### 吞吐量优先

吞吐量优先是指使用多线程进行垃圾回收，尽可能让单位时间内，STW的时间最短，即垃圾回收时间占比最低。

-   吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)；
-   吞吐量大，适用于堆内存较大，多核CPU的服务器；
-   比如Parallel Scavenge收集器、Parallel Old收集器；

吞吐量优先回收垃圾的过程如下图所示（来自 解密JVM 课件）：

![image_w_c6T9WRTk](https://raw.githubusercontent.com/shengchaohua/my-images/main/images/202311261031338.png)

#### 响应时间优先

响应时间优先是指使用多线程进行垃圾回收，尽可能让单次STW的时间最短。

垃圾回收暂停时间短，适用于堆内存较大，多核CPU的服务，比如CMS收集器。

### Serial收集器

Serial收集器是一个最基本的、针对新生代的单线程串行收集器，使用复制算法。它只会使用一个线程去完成垃圾收集，而且在垃圾收集时，必须暂停所有用户线程。

通过使用`XX:+UseSerialGC`，设置新生代使用Serial收集器，并且默认设置老年代使用Serial Old收集器。

相比于其他收集器，Serial收集器优点是简单高效，没有多线程线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器适合于运行在Client模式下的虚拟机、堆内存较小的个人电脑。

### ParNew收集器

ParNew收集器是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等）和Serial收集器完全一样，使用复制算法。

通过使用`-XX:+UseParNewGC`，设置新生代使用ParNew收集器，并且默认设置老年代使用Serial Old收集器。此时，新生代使用复制算法，老年代使用标记整理算法。

ParNew收集器是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。

### Parallel Scavenge收集器

Parallel Scavenge收集器也是针对新生代的多线程收集器，类似于ParNew收集器，使用多线程进行垃圾回收，使用复制算法。它的目的是达到一个可控的吞吐量，让单位时间内垃圾回收的时间占比最低。

Parallel Scavenge收集器是JDK1.8默认的收集器，可以在命令行窗口使用`java -XX:+PrintCommandLineFlags -version`命令查看。

Parallel Scavenge收集器提供了一些参数供用户找到最合适的停顿时间或吞吐量。

通过使用`-XX:+UseParallelGC`，设置新生代使用Parallel Scavenge收集器（不能和CMS收集器一起使用），并且默认设置老年代使用Parallel Old收集器（可以使用`-XX:-UseParallelOldGC`来禁用该功能）。此时，新生代采用复制算法，老年代采用标记整理算法。

通过使用`-XX:MaxGCPauseMillis=n`，设置垃圾回收的最大停顿时间为`n`毫秒，收集器将尽力保证垃圾回收时间不超过设定值。因为应用程序需要回收的垃圾总量是一定的，如果减小该参数，那么垃圾回收的频率将会增加。

通过使用`-XX:GCTimeRatio=n`，设置垃圾回收时间的比例。如果`n=19`，表示GC时间占总时间的5%（1/(1+19)）。

通过使用`-XX:+UseAdaptiveSizePolicy`，Parallel收集器可以设置自适应策略，即JVM会根据实际运行情况动态调整新生代大小、幸存区比例等参数。

### Serial Old收集器

Serial Old收集器实际上是Serial收集器的老年代版本，使用单线程和标记整理算法。

因为没有单独设置Serial Old收集器的参数，需要通过`XX:+UseSerialGC`，设置新生代使用Serial收集器，并且默认设置老年代使用Serial Old收集器。此时，新生代使用复制算法，老年代使用标记整理算法。

Serial Old收集器主要有两个用途：一是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，二是作为CMS收集器的后备方案。

### Parallel Old收集器

Parallel Old收集器实际上是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。

通过使用`-XX:+UseParallelOldGC`，设置老年代使用Parallel Old收集器。

通过使用`-XX:-UseParallelOldGC`，取消老年代使用Parallel Old收集器。

在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。

### CMS收集器

> [JVM实用参数（七）CMS收集器](http://ifeve.com/useful-jvm-flags-part-7-cms-collector/ "JVM实用参数（七）CMS收集器")
> [CMS几种GC模式解读](https://www.jianshu.com/p/be5389ca93f7 "CMS几种GC模式解读")

CMS（Concurrent Mark Sweep，并发标记清除）收集器是一款以获取最短回收停顿时间为目标的分代垃圾收集器。CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。CMS收集器不是默认的收集器，需要进行手动设置。

CMS收集器是一个针对老年代的并发收集器，使用标记清除算法，此时新生代通常使用ParNew收集器，使用复制算法。如果CMS回收老年代失败，会退化到Serial Old收集器。

优点：

-   并发收集、应用程序停顿时间短。
-   因为在CMS工作过程中，GC线程和用户线程可以并发执行，降低了垃圾回收的时间，所以应用程序停顿时间较短。

缺点：

-   CMS对CPU资源比较敏感，在并发标记时会降低吞吐量，应用程序变慢。
-   CMS无法处理浮动垃圾，浮动垃圾指的是并发清除阶段产生的垃圾。因为并发清除阶段用户程序也在运行，所以该阶段产生的垃圾不会被清理。
-   CMS使用标记清除算法，会产生空间碎片。

#### 触发条件和过程

CMS收集器触发GC的条件：

-   当新生代Eden区无法为一个新对象分配内存，触发Minor GC；
-   CMS会根据老年代内存的占用率进行垃圾回收，达到一定比例会触发Major GC，默认情况是根据运行时收集的数据进行垃圾会收；
-   通过`-XX:+UseCMSInitiatingOccupancyOnly`和`-XX:CMSInitiatingOccupancyFraction=`参数，使CMS在老年代占用率达到阈值时进行垃圾回收；

CMS收集器的过程如下图所示（来自 解密JVM 课件）：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030092808.png?token=AE4F4YKOJCO6KKX2WILOU5K7TNWMC)

解释，CMS收集器的过程分为4步：

1.  初始标记（initial mark）：需要STW，用户线程暂停，该阶段用于标记GC Roots直接关联的对象，速度很快；
2.  并发标记（concurrent mark）：不需要STW，用户线程可以运行，该阶段使用GC Roots搜索可达对象；
3.  重新标记（remark）：需要STW，用户线程暂停，该阶段用于修正并发标记期间因程序继续运作而导致标记产生变动的对象的标记记录。停顿时间略长于初始标记，但远远短于并发标记的时间；
4.  并发清除（concurrent sweep）：不需要STW，用户线程可以运行，GC线程开始对未标记的区域做清扫。

#### 相关的JVM参数

-   `-XX:+UseConcMarkSweepGC`：设置老年代使用CMS收集器，并且默认设置新生代使用ParNew收集器，可以使用`-XX:-UseParNewGC`取消；
-   `-XX:+CMSParallelInitialMarkEnabled`，设置并行进行初始标记，JDK1.7中是串行的，JDK1.8之后默认是并行的；
-   `-XX:+UseParNewGC`：设置新生代使用ParNew收集器，通常和CMS一起使用；
-   `-XX:-UseParNewGC`：取消新生代使用ParNew收集器；
-   `-XX:ParallelGCThreads=n`：设置并行收集器收集垃圾的线程数，通常和CPU核数相同，最大为8；
-   `-XX:ConcGCThreads=n`：设置并发线程数，主要用在并发标记和并发清除阶段，通常为(ParallelGCThreads+3)/4；
-   `-XX:+UseCMSInitiatingOccupancyOnly`：设置JVM不基于运行时收集的数据来启动CMS垃圾收集周期，而是通过`CMSInitiatingOccupancyFraction`条件触发垃圾回收；
-   `-XX:CMSInitiatingOccupancyFraction=n`：只有在老年代被占用`n%`时，CMS收集器才满足触发垃圾回收的条件（真正触发垃圾回收的时机由CMS后台扫描线程决定），通常`n`取值范围为70\~75；
-   `-XX:+UseCMSCompactAtFullCollection`：设置Full GC之后进行一次垃圾整理，清除内存碎片，默认为true；
-   `-XX:CMSFullGCsBeforeCompaction=n`：在上一次CMS并发垃圾回收之后，还要再执行`n`次Full GC才会做内存压缩（清理内存碎片），和`+UseCMSCompactAtFullCollection`参数配合使用，默认`n=0`，表示每次每次CMS并发垃圾回收顶不住了而要进行Full GC的时候都会做内存压缩。如果`n=10`，表示每隔10次真正的Full GC才做一次压缩；
-   `-XX:+DisableExplicitGC`：设置忽略显示GC（System.gc()），不管使用的收集器是什么类型；
-   `-XX:+CMSScavengeBeforeRemark`：在重新标记之前对新生代做一次Minor GC，如果重新标记阶段停顿时间过长，可以设置该参数；

#### CMS调优

CMS调优主要有两个挑战：

堆碎片，对象分配率高。

==TODO==

### G1收集器

> [JVM性能优化（三）G1垃圾收集器](https://blog.csdn.net/qq_14996421/article/details/105806571 "JVM性能优化（三）G1垃圾收集器")
> [Java GC G1 详解](https://blog.csdn.net/jiankunking/article/details/85626279 "Java GC G1 详解")
> [Garbage First Garbage Collector Tuning](https://www.oracle.com/technical-resources/articles/java/g1gc.html "Garbage First Garbage Collector Tuning")

G1（Gabage First，垃圾优先）收集器是一款面向服务端应用的收集器，适用于内存较大、多核CPU的机器。G1同时注重吞吐量和低延迟，默认的暂停目标是200ms。在JDK9中，G1是默认的垃圾收集器。

G1也属于分代垃圾收集器，但是相比于之前的收集器，G1没有在物理层面上划分新生代和老年代，而是将堆内存划分为多个大小相等的区域（Region），每个区域都可能是新生代（Eden区、存活区）或老年代，但是在同一时刻只能属于某一种。另外，还有一种特殊的区，称为Humongous区，用于存放巨型对象。如果一个对象的大小超过了一个区域的50%，G1就认为该对象是一个巨型对象，存放在专门的Humongous区。

G1收集器对堆的划分如下图所示（来自 [JVM性能优化（三）G1垃圾收集器](https://blog.csdn.net/qq_14996421/article/details/105806571 "JVM性能优化（三）G1垃圾收集器")）：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030094537.png?token=AE4F4YISMBWIPSVFV6AKW7C7TNYNU)

在G1提出之前，垃圾收集器主要有三种类型：串行收集器、并行收集器和CMS收集器。这三种收集器分别可以是满足Java应用三种不同的需求：内存占用及并发开销最小化、应用吞吐量最大化和应用GC暂停时间最小化。但是，这三种垃圾收集器有几个问题：（1）所有针对老年代的操作必须扫描整个老年代空间；（2）新生代和老年代是独立的内存空间，必须先确定年轻代和老年代的内存地址；（3）要么工作在老年代，要么工作在年轻代，不能同时兼顾二者。

G1收集器的优点：

1.  空间整合，内存碎片少。G1在整体上使用标记整理算法，在两个区域之间使用复制算法，意味着不会产生大量内存碎片。
2.  可预测的停顿。G1能建立可预测的停顿时间模型，可以明确指定在一个长度为M毫秒的时间片段内，GC的时间不得超过N毫秒。
3.  有计划的垃圾回收。G1可以有计划的在Java堆中进行全区域的垃圾收集。

#### 触发条件和过程

G1收集器触发GC的条件：==TODO==

G1的工作过程主要分为三步：

1）新生代垃圾回收（Young GC）。

新生代垃圾回收用于回收Eden区和存活区，使用复制算法。一旦Eden区空间不足，新生代GC就会启动，需要STW，暂停用户线程。新生代GC把Eden区的数据移动到存活区中，把存活区的数据移动到新的存活区或老年代。如果存活区空间不足，Eden区的部分数据会直接晋升到老年代。新生代GC结束后，Eden区被清空，存活区至少有一个，应用线程继续执行。

新生代GC的过程如下图所示：

![](https://raw.githubusercontent.com/shengchaohua/MyImages/main/images/20201030093637.png?token=AE4F4YPZE6IAFOP4BBBCKEK7TNXL4)

2）标记周期（Mark Cycle），用于标记需要垃圾回收的区域，主要作用于老年代。

与CMS有些类似，标记周期是为了降低一次停顿时间，把可以和应用程序并发执行的部分单独提取出来。

标记周期可以分为以下几个阶段：

1.  初始标记阶段（Initial mark phase）：G1收集器标记根对象。这个阶段伴随着一次正常的新生代GC，需要STW，应用程序暂停。
2.  根区域扫描阶段（Root region scanning phase）：由于初始标记伴随着一次新生代GC，所以初始标记后，Eden区被清空，存活对象被移到存活区或老年代。在这个阶段，G1收集器扫描初始标记的存活区，寻找其中对老年代的引用，并标记被引用的对象。这个阶段和应用程序并发执行，不需要STW，并且只有该阶段完成后，下一次新生代GC才能开始。
3.  并发标记阶段（Concurrent marking phase）：G1收集器在整个堆中寻找可达（存活）对象，并进行标记。这个阶段可以和应用程序并发执行，不需要STW，并且可以被一次新生代GC打断。
4.  重标记阶段（Remark phase）：由于在并发标记阶段中，应用程序依然运行，因此标记结果需要修正。在这个阶段，需要STW，应用程序暂停，帮助完成标记周期。G1收集器使用SATB（Snapshot-At-The-Begining）算法，追踪未访问的存活对象，执行引用处理。
5.  清理阶段（Cleanup phase）：在最后这个阶段，需要STW，G1收集器计算各个区域的存活对象并清理记忆集。在计算期间，G1收集器识别完全空闲的区域和混合垃圾回收的候选区域，并根据GC回收比例对候选区域进行排序，按垃圾比例从高到低。

3）混合垃圾回收（Mixed GC），用于回收在标记周期中标记的垃圾区域。

在标记周期中，G1收集器对标记的候选区域按垃圾比例从高到低进行排序，所以已经知道哪些区域含有比较多的垃圾对象。在混合回收阶段，G1收集器针对这些区域进行回收，并且优先回收垃圾比例较高的区域（性价比高），这也是G1（垃圾优先）名字的由来。垃圾优先指的就是垃圾回收时优先选取垃圾比例最高的区域。

在这个阶段，G1收集器同时处理了新生代和老年代：既会执行正常的新生代GC，也会选取一些被标记的老年代区域进行回收，所以该阶段称为混合回收。在G1收集器收集足够数量的内存空间后（可能通过多次混合垃圾收集），G1收集器可能又回头执行新生代GC和标记周期，因此G1收集器的整个过程在三个阶段循环进行。

#### 相关的JVM参数

-   `-XX:+UseG1GC`：设置使用G1收集器；
-   `-XX:G1HeapRegionSize=n`：设置G1区域的大小，大小必须2的幂次，范围从1MB到32MB，默认为堆内存的1/2000；
-   `-XX:MaxGCPauseMillis=200`：设置期望最大GC停顿时间，JVM会尽力实现，但不保证达到，默认值是200毫秒；
-   `-XX:G1NewSizePercent=5`：设置堆百分比，用作新生代大小的最小值。默认值是Java堆的5%；
-   `-XX:ParallelGCThreads=n`：设置并行收集器收集垃圾的线程数，通常和CPU核数相同，最大为8；
-   `-XX:InitiatingHeapOccupancyPercent=n`：设置触发Mixed GC的堆占用率阈值，默认值为45%；

### ZGC收集器

\==TODO==

## 常见问题

### 为什么不要用对象调用类方法？

因为编译时会产生两条没有用的多余的指令，本质还是用类来调用的。

### 内存溢出

> [OOM排查](https://blog.csdn.net/ywlmsm1224811/article/details/91866707 "OOM排查")

内存溢出是指程序在申请内存时，没有足够的内存，导致程序抛出OutOfMemoryError错误。

常见的错误有OutOfMemoryError（内存溢出）和StackOverFlowError（栈溢出错误）。内存溢出的情况有堆内存溢出、方法区溢出、栈溢出等。如果Java虚拟机在栈扩展时，没有申请到足够的空间时，则抛出OutOfMemeryError；当栈请求的深度大于Java虚拟机所允许的最大深度，则抛出StrackOverFlowError。

常见的堆内存溢出错误有：

-   java:java.lang.OutOfMemoryError
-   tomcat:java.lang.OutOfMemoryError: PermGen space
-   tomcat:java.lang.OutOfMemoryError: Java heap space
-   weblogic:Root cause of ServletException java.lang.OutOfMemoryError

内存溢出的原因可能有JVM堆内存过小、程序有问题，包括：

-   启动程序设置堆内存参数过小；
-   加载的类或创建的对象数量过多，比如一次从数据库取出过多数据；
-   集合类中有对象的引用，使用完未清空，导致JVM不能回收；
-   代码中存在死循环或循环产生过多重复的对象；
-   第三方软件（包）存在问题；

内存溢出的情况有排查方法一般为：

```bash
# 1. 先查看应用进程号pid
ps  -ef | grep 应用名
# 2. 查看pid进程的垃圾回收情况，每隔5秒，观察堆内存消耗和垃圾回收的情况
jstat -gc pid 5000
# 3. 开启OOM快照
-XX：+HeapDumpOnOutOfMemoryError、-XX：HeapDumpPath=C:/m.hprof
# 4. 查看方法栈信息
jstack -l pid  > /home/test/jstack.txt
```

内存溢出的解决办法有：

-   增加堆内存大小；
-   优化程序，避免一次载入过多的数据，及时地释放无用对象，释放内存空间；

### 内存泄漏

内存泄漏是指程序在申请内存后，无法释放已申请的内存空间。比如程序中有用不到的对象，占用着内存，无法释放。如果这样的对象越来越多，可用内存就会越来越少，最终会导致内存溢出。

在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点：

1.  这些对象是可达的，即在有向图中，存在通路可以与其相连；
2.  这些对象是无用的，即程序以后不会再使用这些对象。

如果一个对象满足这两个条件，该对象就可以判定为内存泄漏。

内存泄露和内存溢出的相同点是：都会都会导致应用程序运行出现问题，性能下降。

内存泄露和内存溢出的不同点是：

-   内存泄露是导致内存溢出的原因之一，内存泄露积累起来将导致内存溢出。
-   内存泄露可以通过完善代码来避免，内存溢出可以通过调整配置来减少发生频率，但无法彻底避免。

内存泄漏的表现有应用程序变慢，频繁发生垃圾回收等。

Java的内存泄露多半是因为对象存在无效的引用，对象得不到释放，如果发现Java应用程序占用的内存出现了泄露的迹象，那么我们一般采用下面的步骤分析：

```bash
# 1. 查看进程pid
ps -ef | grep java
# 2. 使用jmap初步分析内存映射
jmap pid
# 3. 使用jmap生成Java应用程序的堆快照（heap dump），找出内存占用超出预期的嫌疑对象
jmap -dump:live,format=b,file=heap.hprof pid
# 4. 分析嫌疑对象和其他对象的引用关系
# 5. 分析程序的源代码，找出嫌疑对象数量过多的原因。
```

